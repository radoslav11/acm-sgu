<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

165. Basketball
time limit per test: 0.25 sec.
memory limit per test: 4096 KB
input: standard
output: standard



A head of a rich company decided that the company needs to have its own basketball team in the NBA. He thinks that a team will be successful only if the heights of players don't differ from 2000 mm too much. He took on a coach and this coach selected N players. The height of each player was in range of 1950..2050 millimeters and their average height was exactly 2000 mm. Moreover, the height of each player was integer number of micrometers (micrometer is 1e-6 meters).
Now the head of that company wants to see his new team. He wants to check, if his will is done, but he is going to check it in quite a strange way. The players stands in a line in some order, then the head selects two players and counts the summary height H of these two players and players who are between them, and the number of these players K. If this sum H differs from 2000*K mm more than on 10 cm, then he says that the team is bad. Of course, the coach doesn't want his team to be named "bad", and he don't know, what players will be selected by the head. So he asks you to help him.
Write a program that will find the order of players in line, so that the head of a company will not say the team is bad.

Input
On the first line of input there is one integer N (1<=N<=6000) --- the number of players selected into a team (these are the base players and substitutions and so on). Then N real numbers follow --- the heights of the players in meters.

Output
If the solution exists, write on the first line of the output one word "yes" (without quotes). On the second line write the order of players in which they must stand in line. The players are numbered starting from 1 in that order how their heights are written in input. If several solutions exist, output any. If there exist no solution, write on the first line of output only one word "no" (without quotes).

Sample test(s)

Input
6
1.95 1.95 1.96 2.04 2.05 2.05

Output
yes
1 6 2 5 3 4
Author:	Nizhny Novgorod city mathematic olympiad jury
Resource:	Nizhny Novgorod city mathematic olympiad, 8th form
Date:	21.12.2002

<|response|>
1) Abridged problem statement
- You are given N heights hi (meters), each in [1.95, 2.05]. The average is exactly 2.00 m.
- Arrange the players in a line so that for every contiguous segment with K players and total height H, we have |H − 2.00·K| ≤ 0.10 m (10 cm).
- Print “yes” and any valid order (1-based indices). Under the given guarantees, a valid order always exists.

2) Key observations
- Shift heights by 2.00: let di = hi − 2.00 (meters). Then di ∈ [−0.05, 0.05] and ∑ di = 0.
- The check for any segment becomes: for any contiguous segment, |∑ di| ≤ 0.10.
- If every prefix sum Sk = ∑t=1..k dpt stays in [−0.05, 0.05], then any segment sum (difference of two prefixes) lies in [−0.10, 0.10]. So it suffices to keep all prefix sums within ±0.05.
- Greedy construction that guarantees this:
  - Sort di ascending.
  - Maintain two pointers: l at the most negative remaining, r at the most positive remaining. Keep running prefix sum S.
  - If S > 0, append the most negative element (at l). If S ≤ 0, append the most positive element (at r).
- Why it works:
  - Existence: If S > 0 and there were no negative remaining, the sum of remaining deviations would be ≥ 0, so total would be > 0, contradicting ∑ di = 0. Similarly for S ≤ 0. Therefore a suitable choice always exists.
  - Bounding S: Each di ∈ [−0.05, 0.05]. Adding a value of opposite sign (or zero) moves S toward 0 by at most 0.05, so S always stays within [−0.05, 0.05].
- Implementation tip: Read heights as integer micrometers to avoid floating-point errors; work with deviations in integer micrometers:
  - hi in μm, di = hi − 2,000,000, with di ∈ [−50,000, 50,000]. Keep S in [−50,000, 50,000].

3) Full solution approach
- Convert each input height string to integer micrometers: parse the decimal, pad/truncate to 6 fractional digits.
- Compute deviations di = micrometers(hi) − 2,000,000; store pairs (di, original_index).
- Sort by di ascending.
- Two-pointer greedy:
  - Initialize S = 0, l = 0, r = n − 1, order = [].
  - Repeat N times:
    - If S > 0, pick (di, idx) at l; l += 1. Else pick at r; r -= 1.
    - S += di; append idx to order.
- Output:
  - Print “yes” and the permutation.
- Correctness: By the observations above, all prefix sums stay within ±50,000 μm (±0.05 m), so any subarray sum is within ±100,000 μm (±0.10 m).
- Complexity: O(N log N) time for sorting, O(N) memory.

4) C++ implementation with detailed comments
```cpp
#include <bits/stdc++.h>
using namespace std;

// Parse a decimal string in meters into integer micrometers.
// Examples:
//   "2" -> 2,000,000
//   "1.95" -> 1,950,000
// Assumption from the statement: inputs are integer micrometers,
// so at most 6 fractional digits.
static long long parse_micrometers(const string& s_in) {
    string s = s_in;
    bool neg = false;
    if (!s.empty() && s[0] == '-') {
        neg = true;
        s = s.substr(1);
    }
    size_t dot = s.find('.');
    string left = (dot == string::npos) ? s : s.substr(0, dot);
    string right = (dot == string::npos) ? string() : s.substr(dot + 1);

    // Pad or truncate to exactly 6 digits (micrometers)
    if (right.size() < 6) right.append(6 - right.size(), '0');
    if (right.size() > 6) right = right.substr(0, 6);

    long long L = 0, R = 0;
    if (!left.empty()) L = stoll(left);
    if (!right.empty()) R = stoll(right);
    long long value = L * 1'000'000LL + R;
    return neg ? -value : value;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin >> n)) return 0;
    vector<pair<int, int>> dev_idx; // (deviation in μm, original index)
    dev_idx.reserve(n);

    const int TWO_M_MICROS = 2'000'000;

    for (int i = 0; i < n; ++i) {
        string s;
        cin >> s;
        long long mic = parse_micrometers(s);
        int d = static_cast<int>(mic - TWO_M_MICROS); // in [-50'000, 50'000]
        dev_idx.emplace_back(d, i + 1); // store 1-based index
    }

    // Sort by deviation ascending
    sort(dev_idx.begin(), dev_idx.end(),
         [](const pair<int,int>& a, const pair<int,int>& b) {
             return a.first < b.first;
         });

    // Two-pointer greedy to keep prefix sums within [-50'000, 50'000]
    long long S = 0;
    int l = 0, r = n - 1;
    vector<int> order;
    order.reserve(n);

    for (int k = 0; k < n; ++k) {
        int d, idx;
        if (S > 0) {
            d = dev_idx[l].first;
            idx = dev_idx[l].second;
            ++l;
        } else {
            d = dev_idx[r].first;
            idx = dev_idx[r].second;
            --r;
        }
        S += d;
        order.push_back(idx);
    }

    // Under the problem guarantees, the answer always exists
    cout << "yes\n";
    for (int i = 0; i < n; ++i) {
        if (i) cout << ' ';
        cout << order[i];
    }
    cout << '\n';
    return 0;
}
```

5) Python implementation with detailed comments
```python
import sys

def parse_micrometers(s: str) -> int:
    """
    Parse a decimal string s (meters) into integer micrometers.
    Assumes input heights are integer micrometers (<= 6 fractional digits).
    """
    s = s.strip()
    neg = s.startswith('-')
    if neg:
        s = s[1:]
    if '.' in s:
        left, right = s.split('.', 1)
    else:
        left, right = s, ''
    # pad or truncate fractional part to exactly 6 digits
    right = (right + '000000')[:6]
    mic = int(left) * 1_000_000 + (int(right) if right else 0)
    return -mic if neg else mic

def main():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    it = iter(data)
    n = int(next(it))
    heights = [next(it) for _ in range(n)]

    TWO_M_MICROS = 2_000_000

    # Store (deviation in μm, original 1-based index)
    dev_idx = []
    for i, s in enumerate(heights, start=1):
        mic = parse_micrometers(s)
        d = mic - TWO_M_MICROS            # in [-50_000, 50_000]
        dev_idx.append((d, i))

    # Sort by deviation ascending
    dev_idx.sort(key=lambda x: x[0])

    # Two-pointer greedy to keep prefix sum within [-50_000, 50_000]
    S = 0
    l, r = 0, n - 1
    order = []
    for _ in range(n):
        if S > 0:
            d, idx = dev_idx[l]
            l += 1
        else:
            d, idx = dev_idx[r]
            r -= 1
        S += d
        order.append(idx)

    # Under the guarantees, a valid order always exists
    print("yes")
    print(" ".join(map(str, order)))

if __name__ == "__main__":
    main()
```