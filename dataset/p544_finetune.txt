<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

544. Chess Championship
Time limit per test: 3 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard



Chess Championship is set up in the New Basyuki City. Two national teams, of Berland and Byteland, are going to have a match there. Each team is represented by n players. The championship consists of n games — in each game a pair of players from different teams meets. A game victory brings 1 point to the team and a game defeat doesn't add or subtract points.

The championship starts with the sortition — the process that determines opponent pairs. Each player from the first team plays with exactly one player from the second team (and vice versa).

A recent research conducted by Berland scientists showed that every player of either team is characterized by a single number — the level of his chess mastership. No two people among the 2n players play at the same level. Funny as it is, the game winner always is the player with the higher level.

The contest organizers received information that a high-ranking Berland official Mr. B. bet 100500 burles on the victory of his team with a k points gap. Immediately an unofficial "recommendation" came from very important people to "organize" the sortition so that the Berland team gets exactly k points more than the Byteland team.

Write a program that finds the number of distinct sortition results after which Berland gets exactly k points more than Byteland. Two sortitions are considered distinct if there is such player, that gets different opponents by the sortitions' results.

Input
The first line contains a pair of integers n and k (1 ≤ n ≤ 500; 1 ≤ k ≤ n) — the number of participants in each team and the required gap in points that Berland must win. The second and the third input lines contain n integers each: the i-th number of the second line characterizes the i-th Berland player's chess mastership level, and the j-th number of the third line characterizes the j-th Byteland player's chess mastership level. It is guaranteed that all numbers that characterize mastership levels are distinct integers from 0 to 109.

Output
Print a single integer — the number of ways to set up the sortition so that the Berland team wins k points more than the Byteland team in the championship. The answer can be rather large, so print it modulo 1000000009 (109+9).

Example(s)
sample input
sample output
4 2
5 35 15 45
40 20 10 30
4

sample input
sample output
2 2
3 4
1 2
2



Note
In the first example the acceptable sortition results are: (5-40, 35-20, 15-10, 45-30), (5-40, 45-20, 15-10, 35-30), (45-40, 5-20, 15-10, 35-30) and (45-40, 35-20, 15-10, 5-30).

<|response|>
1) Abridged problem statement
- There are two teams, Berland (A) and Byteland (B), each with n players. Every player has a distinct skill; the stronger player always wins.
- A sortition is a perfect matching between A and B (each A plays exactly one B).
- Count the number of sortitions in which Berland wins exactly k more games than Byteland, modulo 1,000,000,009.

2) Key observations
- Let wins(A) and wins(B) be the total wins of the two teams. Then:
  - wins(A) + wins(B) = n
  - wins(A) − wins(B) = k
  - Hence wins(B) = (n − k) / 2 and wins(A) = (n + k) / 2. If n − k is odd or k > n, the answer is 0.

- Sort all 2n players by skill (ascending), labeling each as team A or B.
  - Any match connects a weaker earlier player with a stronger later player.
  - When scanning left-to-right, the current player (as the stronger endpoint) can be matched only with an earlier unmatched opponent of the opposite team.

- DP idea while scanning:
  - Let cnt_a, cnt_b be the counts of A and B seen so far (in the already processed prefix).
  - Let dp[wa][wb] = number of ways such that wa A-wins and wb B-wins have already been formed within this prefix.
  - Unmatched earlier A’s = cnt_a − (wa + wb), unmatched earlier B’s = cnt_b − (wa + wb).

- Transition for the current player of team T:
  - Option 1: Leave current player unmatched (will serve as the weaker endpoint later).
    - dp'[wa][wb] += dp[wa][wb].
  - Option 2: Match current player now (as stronger) with an earlier unmatched opponent of the other team:
    - If T = A: candidates = cnt_b − (wa + wb). For each choice, we form an A-win:
      - dp'[wa + 1][wb] += dp[wa][wb] × candidates.
    - If T = B: candidates = cnt_a − (wa + wb). We form a B-win:
      - dp'[wa][wb + 1] += dp[wa][wb] × candidates.
  - Only apply Option 2 when candidates > 0.

- Final answer is dp[(n + k)/2][(n − k)/2] modulo 1e9+9.

- Complexity:
  - States: (wins(A)+1) × (wins(B)+1) ≤ ((n+1)/2)².
  - Steps: 2n (scan all players).
  - Time: O(n · wins(A) · wins(B)) = O(n^3) in the worst case, fine in C++.
  - Memory: O(wins(A) · wins(B)).

3) Full solution approach
- Compute wins(B) = (n − k) / 2 and wins(A) = (n + k) / 2. If (n − k) is odd or k > n, print 0.
- Merge both teams’ skills into one list of pairs (skill, team), with team = 0 for A and 1 for B, and sort by skill ascending.
- Initialize dp[0][0] = 1; cnt_a = cnt_b = 0.
- For each player in sorted order:
  - Create a fresh new_dp table filled with 0.
  - For every state (wa, wb) with dp[wa][wb] > 0:
    - Leave unmatched: new_dp[wa][wb] += dp[wa][wb].
    - Match now:
      - If team == A:
        - candidates = cnt_b − (wa + wb).
        - If candidates > 0 and wa + 1 ≤ wins(A): new_dp[wa + 1][wb] += dp[wa][wb] × candidates.
      - If team == B:
        - candidates = cnt_a − (wa + wb).
        - If candidates > 0 and wb + 1 ≤ wins(B): new_dp[wa][wb + 1] += dp[wa][wb] × candidates.
    - Take all additions modulo 1e9+9.
  - Assign dp = new_dp.
  - Update cnt_a or cnt_b according to the current player’s team.
- Output dp[wins(A)][wins(B)].

Why this works:
- Sorting ensures every pair connects an earlier weaker player to a later stronger player.
- At each step, either the current (stronger than all earlier) is matched to an earlier unmatched opponent (counted by “candidates”), or left for a future stronger player to match with.
- The counts of unmatched earlier A’s/B’s are precisely cnt_a − (wa + wb) and cnt_b − (wa + wb), because wa + wb pairs have consumed that many from each team in the prefix.
- This DP enumerates each valid perfect matching exactly once.

4) C++ implementation with detailed comments
```cpp
#include <bits/stdc++.h>
using namespace std;

static const int MOD = 1'000'000'009;

int addmod(int a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
    return a;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    if (!(cin >> n >> k)) return 0;

    vector<int> A(n), B(n);
    for (int i = 0; i < n; ++i) cin >> A[i];
    for (int i = 0; i < n; ++i) cin >> B[i];

    // Calculate required numbers of wins
    if (k > n || ((n - k) & 1)) {
        cout << 0 << '\n';
        return 0;
    }
    int winB = (n - k) / 2;
    int winA = n - winB; // (n + k) / 2

    // Build combined and sort by skill
    vector<pair<int,int>> people;
    people.reserve(2 * n);
    for (int i = 0; i < n; ++i) people.push_back({A[i], 0}); // 0 = A (Berland)
    for (int i = 0; i < n; ++i) people.push_back({B[i], 1}); // 1 = B (Byteland)
    sort(people.begin(), people.end()); // ascending skill

    // dp[wa][wb] = ways for current prefix to have wa A-wins and wb B-wins already formed
    vector<vector<int>> dp(winA + 1, vector<int>(winB + 1, 0));
    dp[0][0] = 1;

    int cntA = 0, cntB = 0; // how many A/B seen so far (before current player)
    for (auto [skill, team] : people) {
        vector<vector<int>> ndp(winA + 1, vector<int>(winB + 1, 0));

        for (int wa = 0; wa <= winA; ++wa) {
            for (int wb = 0; wb <= winB; ++wb) {
                int ways = dp[wa][wb];
                if (!ways) continue;

                // Option 1: leave current player unmatched for now
                ndp[wa][wb] = addmod(ndp[wa][wb], ways);

                // Option 2: match current player (as stronger) with earlier unmatched opponent
                int pairs_so_far = wa + wb;
                if (team == 0) {
                    // Current is A: match with earlier unmatched B
                    int candidates = cntB - pairs_so_far;
                    if (candidates > 0 && wa + 1 <= winA) {
                        long long add = (1LL * ways * candidates) % MOD;
                        ndp[wa + 1][wb] = addmod(ndp[wa + 1][wb], (int)add);
                    }
                } else {
                    // Current is B: match with earlier unmatched A
                    int candidates = cntA - pairs_so_far;
                    if (candidates > 0 && wb + 1 <= winB) {
                        long long add = (1LL * ways * candidates) % MOD;
                        ndp[wa][wb + 1] = addmod(ndp[wa][wb + 1], (int)add);
                    }
                }
            }
        }

        dp.swap(ndp);

        // Update prefix counts after processing this player
        if (team == 0) ++cntA; else ++cntB;
    }

    cout << dp[winA][winB] << '\n';
    return 0;
}
```

5) Python implementation with detailed comments
Note: This Python solution uses the same O(n^3) DP. With n ≤ 500, it may be near the time limit in some environments; the C++ version is recommended for performance-critical submissions.

```python
import sys

MOD = 1_000_000_009

def main():
    data = list(map(int, sys.stdin.buffer.read().split()))
    it = iter(data)
    n = next(it)
    k = next(it)
    A = [next(it) for _ in range(n)]
    B = [next(it) for _ in range(n)]

    # Compute required wins
    if k > n or ((n - k) & 1):
        print(0)
        return
    winB = (n - k) // 2
    winA = n - winB  # (n + k) // 2

    # Combine and sort by skill
    people = [(x, 0) for x in A] + [(x, 1) for x in B]  # team 0 = A, 1 = B
    people.sort()

    # dp[wa][wb] = number of ways with wa A-wins and wb B-wins formed so far
    dp = [[0] * (winB + 1) for _ in range(winA + 1)]
    dp[0][0] = 1

    cntA = 0  # how many A seen so far
    cntB = 0  # how many B seen so far

    for _, team in people:
        # new dp for the step
        new_dp = [[0] * (winB + 1) for _ in range(winA + 1)]

        for wa in range(winA + 1):
            row = dp[wa]
            new_row = new_dp[wa]
            for wb in range(winB + 1):
                ways = row[wb]
                if ways == 0:
                    continue

                # Option 1: leave current player unmatched
                val = new_row[wb] + ways
                if val >= MOD:
                    val -= MOD
                new_row[wb] = val

                # Option 2: match current (as stronger) with earlier unmatched opponent
                pairs_so_far = wa + wb
                if team == 0:
                    # current is A: match with earlier unmatched B
                    candidates = cntB - pairs_so_far
                    if candidates > 0 and wa + 1 <= winA:
                        new_dp[wa + 1][wb] = (new_dp[wa + 1][wb] + ways * candidates) % MOD
                else:
                    # current is B: match with earlier unmatched A
                    candidates = cntA - pairs_so_far
                    if candidates > 0 and wb + 1 <= winB:
                        new_dp[wa][wb + 1] = (new_dp[wa][wb + 1] + ways * candidates) % MOD

        dp = new_dp

        # Update counts for the next step
        if team == 0:
            cntA += 1
        else:
            cntB += 1

    print(dp[winA][winB] % MOD)

if __name__ == "__main__":
    main()
```

Explanation recap:
- Sorting converts the problem into matching earlier-weaker with later-stronger.
- The DP tracks how many wins have already been formed and how many earlier opponents remain unmatched.
- At each step, either keep the current player for the future (as a weaker endpoint) or match now (as a stronger endpoint) with any earlier unmatched opponent of the other team.
- The required difference k fixes the exact counts of A- and B-wins we must reach.