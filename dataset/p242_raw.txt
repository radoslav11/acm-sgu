p242.in1
======================
4 2
1 1
2 1 2
1 2
2 1 2

=================
p242.ans1
======================
YES
2 1 2
2 3 4


=================
p242.in2
======================
3 2
2 1 2
2 1 2
2 1 2


=================
p242.ans2
======================
NO

=================
p242.py
======================
import sys


class Dinic:
    def __init__(self, n):
        self.n = n
        self.adj = [[] for _ in range(n)]
        self.level = [0] * n
        self.it = [0] * n

    def add_edge(self, u, v, c):
        self.adj[u].append([v, c, len(self.adj[v])])
        self.adj[v].append([u, 0, len(self.adj[u]) - 1])

    def bfs(self, s, t):
        from collections import deque

        self.level = [-1] * self.n
        q = deque([s])
        self.level[s] = 0
        while q:
            u = q.popleft()
            for v, cap, _ in self.adj[u]:
                if cap > 0 and self.level[v] < 0:
                    self.level[v] = self.level[u] + 1
                    q.append(v)
        return self.level[t] >= 0

    def dfs(self, u, t, f):
        if u == t:
            return f
        for i in range(self.it[u], len(self.adj[u])):
            self.it[u] = i
            v, cap, _ = self.adj[u][i]
            if cap > 0 and self.level[v] == self.level[u] + 1:
                pushed = self.dfs(v, t, min(f, cap))
                if pushed:
                    self.adj[u][i][1] -= pushed
                    rv = self.adj[u][i][2]
                    self.adj[v][rv][1] += pushed
                    return pushed
        return 0

    def maxflow(self, s, t):
        flow = 0
        INF = 10**9
        while self.bfs(s, t):
            self.it = [0] * self.n
            while True:
                pushed = self.dfs(s, t, INF)
                if not pushed:
                    break
                flow += pushed
        return flow


def main():
    # The main idea is to solve this problem with max flow. We don't have
    # to assign all students, so we can assume that each university is
    # visited by exactly two students. Then we can form this as a maxflow
    # problam. Let's build a bipartite graph for max flow:
    #   Source -> each university (cap 2)
    #   University -> student (cap 1 if student can attend)
    #   Student -> Sink (cap 1)
    # There is a feasible configuration if and only if the maximum flow is
    # exactly 2*K. Then we can recover assignment by looking at the paths.

    data = list(map(int, sys.stdin.read().strip().split()))
    if not data:
        return

    it = iter(data)
    N = next(it)
    K = next(it)

    pref = [[] for _ in range(N)]
    for i in range(N):
        cnt = next(it)
        lst = [next(it) for _ in range(cnt)]
        pref[i] = lst

    S = 0
    uni_offset = 1
    stu_offset = uni_offset + K
    T = stu_offset + N
    V = T + 1

    din = Dinic(V)

    for u in range(1, K + 1):
        din.add_edge(S, uni_offset + (u - 1), 2)

    for s_idx in range(N):
        for u in pref[s_idx]:
            if 1 <= u <= K:
                din.add_edge(uni_offset + (u - 1), stu_offset + s_idx, 1)

    for s_idx in range(N):
        din.add_edge(stu_offset + s_idx, T, 1)

    need = 2 * K
    flow = din.maxflow(S, T)

    if flow != need:
        print("NO")
        return

    print("YES")
    for u in range(K):
        uni_node = uni_offset + u
        assigned = []
        for v, cap, _ in din.adj[uni_node]:
            if stu_offset <= v < stu_offset + N and cap == 0:
                student_id = v - stu_offset + 1
                assigned.append(student_id)
        print(len(assigned), *assigned)


if __name__ == "__main__":
    main()

=================
statement.txt
======================
242. Student's Morning
time limit per test: 0.25 sec.
memory limit per test: 6144 KB
input: standard
output: standard



One Monday morning after some very fun party N students woke up at the flat of one of them. Notice that it was a Monday morning and every student of that party needs to be in his university this day. But nobody wants to go to his university alone (there were students from different universities). So, they decided to select from all universities only K of them to visit. Every selected university must be visited by at least two of the students. Every student has his own preference list of universities. It means, if some university is in list of some student's preferred universities, this student can go to this university with some non-empty company of students. Notice, that some of students can stay at the flat and continue drinking "juices" and playing "games". For example, student Shokman was to stay home (due to failed exam) with foreign student Chokman, who remained home because of runny nose.
In that problem there are no preferences between students, because if they have very fun party that already means that everyone of them prefers anybody from this company.

More formally, your task is, given numbers of students, selected universities and preference list of every student, to decide whether it is possible to visit all universities by at least two of students or no, and if it is possible you must output for each university numbers of students, which have to go to it in one company. One student can't be in more than one company.

Input
First line of input file contains two numbers N and K (0<=K<=N<=200). Next N lines contain preference lists of each student. Every preference list is started by number of preferred universities followed by numbers of these universities.

Output
First line of output file must contain word "YES" (without quotes), if it possible to visit all universities, satisfying rules of that task or word "NO" (also without quotes) when it is impossible. In case of positive answer next K lines must contain lists of students, who are going to corresponding university. First number in list of students must be a number of students in the list, followed by numbers of these students.

Sample test(s)

Input
Test #1
4 2
1 1
2 1 2
1 2
2 1 2

Test #2
3 2
2 1 2
2 1 2
2 1 2

Output
Test #1
YES
2 1 2
2 3 4

Test #2
NO
Author:	Alexey Preobrajensky
Resource:	---
Date:	October, 2003







=================
