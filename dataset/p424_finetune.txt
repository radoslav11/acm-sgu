<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

424. Beautiful graph
Time limit per test: 0.25 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard



Misha is currently interested in undirected graphs that contain no two simple cycles sharing exactly one edge and contains no loops. Let's call them beautiful graphs. He wants to find the maximal beatiful graph, that is the beautiful graph that contains the most edges among all beautiful graphs with at most n vertices. But Misha is going to leave on vacation, so he asked you to help him with this problem.

Input
The input file contains a single integer n (1 ≤ n ≤ 100) — the maximum number of vertices your graph can contain.

Output
Output the number of vertices V (1 ≤ V ≤ n) and the number of edges E of your graph to the first line of the output file, separated with a space. Then output E lines with two integer numbers each, again separated with a space. The two numbers should be the numbers of the vertices connected by the corresponding edge. The vertices of the graph are numbered from 1 to V. You can output edges in any order. If there are several maximal graphs, output any.

Example(s)
sample input
sample output
1
1 0

sample input
sample output
2
2 1
1 2

sample input
sample output
3
3 3
1 2
2 3
1 3

<|response|>
1. Abridged problem statement
------------------------------

We must construct an undirected simple graph (no loops, no multiple edges) using at most `n` vertices such that:

- It has **no pair of simple cycles that share exactly one common edge**.
- Among all such “beautiful” graphs with at most `n` vertices, it has the **maximum possible number of edges**.

We must output:

- The actual number of vertices `V` we use (1 ≤ V ≤ n) and the number of edges `E`.
- Then `E` lines with edges `u v` (1 ≤ u, v ≤ V).

Any maximally edged beautiful graph is acceptable.

---

2. Key observations
-------------------

1. **Small cases are trivial to handle directly**:
   - `n = 1`: no edges.
   - `n = 2`: one edge between the two vertices.
   - `n = 3`: the triangle (complete graph K3) is allowed (only one cycle, so there cannot be a forbidden pair).

2. **For larger `n`, bound the maximum number of edges** by looking at:
   - A **DFS spanning tree** of any connected component.
   - Tree edges: exactly `V - 1` edges.
   - All remaining edges are **back edges** (in an undirected DFS: edges that connect a node to an ancestor).

3. **Each back edge forms exactly one simple cycle**:
   - Back edge `(u, v)` where `v` is an ancestor of `u` creates the cycle: tree path from `v` to `u` plus the edge `(u, v)`.

4. **Forbidden configuration via back-edge “coverage”**:
   - Consider depths in the DFS tree.
   - Associate a back edge `(u, v)` (with `v` ancestor of `u`) with the depth interval `[depth(v), depth(u)]` along the tree.
   - If one back edge’s interval “covers” another in a certain way, we can construct **two cycles that share exactly one tree edge**, which is forbidden.
   - This puts strong restrictions on how back edges can be arranged.

   The usable compressed conclusion (from the editorial reasoning) is:

   > The depths of the deeper endpoints of back edges must form a strictly increasing sequence within a limited depth range.

   This yields an **upper bound on the number of back edges**: at most `n - 3` for `n ≥ 4`.

5. **Upper bound on total edges**:
   - Tree edges: `V - 1` (with `V ≤ n`; in the optimal case we will take `V = n`).
   - Back edges: ≤ `n - 3`.
   - So total edges ≤ `(n - 1) + (n - 3) = 2n - 4`, for `n ≥ 4`.

   Thus **no beautiful graph on at most `n` vertices can have more than `2n - 4` edges** when `n ≥ 4`.

6. **We can construct a graph that reaches this bound**:
   - Use all `n` vertices.
   - For each `i` in `1 .. n-2`, connect `i` to both `n-1` and `n`.
   - This yields `2(n-2) = 2n - 4` edges, matching the upper bound.

7. **Why the construction is beautiful**:
   - There are no edges among `{1, 2, ..., n-2}`.
   - There is no edge between `n-1` and `n`.
   - Any cycle must use both `n-1` and `n`, and exactly two distinct vertices `a, b` from `1..n-2`:
     - Cycle: `a - (n-1) - b - n - a` (a 4-cycle).
   - So:
     - Every cycle has length 4.
     - Every cycle includes both `n-1` and `n`.
   - Two such cycles can:
     - Share no vertices at all, hence share 0 edges, or
     - Share exactly one of the outer vertices (say they both use `a`); then they share **two** edges `(a, n-1)` and `(a, n)`.
   - They **cannot** share exactly one edge.
   - Thus the graph is beautiful and has the maximum number of edges.

---

3. Full solution approach
-------------------------

### 3.1. Overall plan

Given `n` (1 ≤ n ≤ 100):

1. Handle small cases directly:
   - `n = 1`:
     - Use `V = 1`, `E = 0`.
   - `n = 2`:
     - Use `V = 2`, `E = 1`, edge `(1, 2)`.
   - `n = 3`:
     - Use `V = 3`, `E = 3`, edges `(1, 2)`, `(2, 3)`, `(1, 3)`.

2. For `n ≥ 4`, construct the maximal beautiful graph with `2n - 4` edges:
   - Use all `n` vertices: `V = n`.
   - For each vertex `i` from `1` to `n-2`:
     - Add edge `(i, n-1)`.
     - Add edge `(i, n)`.
   - Total edges: `E = 2(n - 2)`.

3. Output format:
   - First line: `V E`.
   - Then `E` lines, each with `u v` describing one edge.

### 3.2. Why this is correct and optimal

- For `n ≤ 3`, we obviously cannot add more edges than the complete graph `K_n`, and these chosen graphs are beautiful because:
  - `n = 1, 2`: no cycles → no forbidden pair.
  - `n = 3`: single cycle (triangle) → still no pair of cycles.

- For `n ≥ 4`, we rely on the DFS + back edges argument for the upper bound:
  - Any connected component with `V` vertices has:
    - Tree edges: `V - 1`.
    - Back edges: limited by cycle-sharing restriction → ≤ `V - 3`.
    - Total ≤ `2V - 4 ≤ 2n - 4`.
  - Even if the graph is disconnected, the sum of edges across components with total vertices ≤ n can’t beat this bound; making the graph connected lets you use more edges for the same number of vertices.

- Our specific construction uses `V = n` and exactly `2n - 4` edges, hitting the bound. So it has the maximum possible number of edges.

- The cycle-structure argument shows it’s beautiful:
  - All cycles are 4-cycles using both `n-1` and `n`.
  - Any two such cycles share 0 or 2 edges.
  - Hence the forbidden configuration (exactly 1 shared edge) never occurs.

### 3.3. Complexity

- Time: `O(n)` — we just print `O(n)` edges.
- Memory: `O(1)` beyond output buffering.

This easily fits within the limits (`n ≤ 100`, very small).

---

4. C++ implementation with detailed comments
--------------------------------------------

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
 We construct a "beautiful" graph (no two simple cycles share exactly one edge)
 with the maximum possible number of edges using at most n vertices.

 Strategy:
 - For n = 1, 2, 3: handle directly with hard-coded optimal graphs.
 - For n >= 4: use the construction:
       vertices: 1..n
       for i in 1..n-2:
           add edges (i, n-1) and (i, n)
   This yields 2(n-2) edges, which is optimal by the DFS + back-edges argument.
*/

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin >> n)) {
        return 0;  // no input
    }

    // Small cases that match the samples and are obviously optimal.
    if (n == 1) {
        // Only one vertex, cannot have any edges.
        cout << "1 0\n";
        return 0;
    }

    if (n == 2) {
        // Two vertices; the single possible edge is allowed (no cycles).
        cout << "2 1\n";
        cout << "1 2\n";
        return 0;
    }

    if (n == 3) {
        // Three vertices; the triangle (complete graph K3) is allowed.
        // There is only one cycle (1-2-3-1), so no forbidden pair of cycles.
        cout << "3 3\n";
        cout << "1 2\n";
        cout << "2 3\n";
        cout << "1 3\n";
        return 0;
    }

    // For n >= 4:
    // Construction:
    //   V = n
    //   E = 2 * (n - 2)
    //
    // For each i in [1, n-2], add edges:
    //   (i, n-1) and (i, n)
    //
    // This graph:
    //  - Has 2(n-2) edges.
    //  - Every cycle is of the form a-(n-1)-b-n-a, a 4-cycle.
    //  - Any two cycles share either 0 edges or 2 edges,
    //    never exactly 1 edge, so the graph is beautiful.

    int V = n;
    int E = 2 * (n - 2);

    cout << V << " " << E << "\n";

    // Output each edge.
    for (int i = 1; i <= n - 2; ++i) {
        // Edge between i and (n-1)
        cout << i << " " << (n - 1) << "\n";
        // Edge between i and n
        cout << i << " " << n << "\n";
    }

    return 0;
}
```

---

5. Python implementation with detailed comments
-----------------------------------------------

```python
import sys

"""
We construct a "beautiful" graph (no two simple cycles share exactly one edge)
with the maximum possible number of edges, using at most n vertices.

Plan:
- For n = 1, 2, 3: directly output optimal graphs.
- For n >= 4: use n vertices and connect every i in 1..n-2 to both n-1 and n.

This gives exactly 2(n-2) edges, which is optimal by the DFS/back-edges bound.
"""

def main():
    data = sys.stdin.read().strip()
    if not data:
        return
    n = int(data)

    out_lines = []

    # Handle small n directly.
    if n == 1:
        # Only one vertex, no edges.
        out_lines.append("1 0")
        sys.stdout.write("\n".join(out_lines))
        return

    if n == 2:
        # Two vertices, one possible edge, no cycles.
        out_lines.append("2 1")
        out_lines.append("1 2")
        sys.stdout.write("\n".join(out_lines))
        return

    if n == 3:
        # Three vertices, use full triangle K3.
        # Only one cycle, so no forbidden pair of cycles.
        out_lines.append("3 3")
        out_lines.append("1 2")
        out_lines.append("2 3")
        out_lines.append("1 3")
        sys.stdout.write("\n".join(out_lines))
        return

    # For n >= 4, use the 2-center construction:
    # vertices: 1..n
    # edges: for each i in 1..n-2:
    #          (i, n-1) and (i, n)
    V = n
    E = 2 * (n - 2)
    out_lines.append(f"{V} {E}")

    for i in range(1, n - 1):   # i goes from 1 to n-2 inclusive
        out_lines.append(f"{i} {n - 1}")
        out_lines.append(f"{i} {n}")

    sys.stdout.write("\n".join(out_lines))


if __name__ == "__main__":
    main()
```

This completes a step-by-step explanation and two fully commented reference implementations for the problem.