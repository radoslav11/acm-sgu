p539.in2
======================
5
5 4 3 2 1

=================
p539.ans3
======================
2
2 1 2 3 4
1 4 2

=================
p539.ans2
======================
1
2 1 5 2 4

=================
p539.in3
======================
4
3 1 2 2

=================
p539.in1
======================
3
1 2 3

=================
p539.ans1
======================
0

=================
p539.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

int n;
vector<int> p;

void read() {
    cin >> n;
    p.resize(n);
    cin >> p;
}

pair<bool, vector<pair<int, int>>> check_1(
    const vector<int>& p, const vector<int>& q
) {
    vector<bool> visited(p.size(), false);
    vector<pair<int, int>> swaps;

    for(int i = 0; i < (int)p.size(); i++) {
        if(visited[i] || p[i] == q[i]) {
            continue;
        }

        int found = -1;
        for(int j = 0; j < (int)p.size(); j++) {
            if(!visited[j] && p[i] == q[j] && p[j] == q[i]) {
                found = j;
                break;
            }
        }

        if(found == -1) {
            return {false, {}};
        }

        visited[i] = true;
        visited[found] = true;
        swaps.push_back({i, found});
    }

    return {true, swaps};
}

void solve() {
    // To solve this, the most important observation is that we need at most 2
    // swaps. Let's first check if the answer is 0 or 1. Checking for 0 is
    // trivial by sorting and check if equal. For 1, we can greedily assign
    // swaps - let p be the initial array, and q the target, so we can find
    // pairs (i, j) such that p[i] = q[j] and p[j] = q[i] such that every
    // position is in at most one pair.
    //
    // Now let's say we can't solve this in one turn. We start by turning p
    // into a permutation (any should work in the case of duplicates). We would
    // like in two turns to fix all cycles of this new permutation. Consider an
    // arbitrary one v[1], ..., v[k]. We want to cyclically shift it to
    // v[k], v[1], ..., v[k-1]. In the first step, we will try to make
    // independent cycles of length 2. This can be done by swapping v[1] with
    // v[k-1], then v[2] with v[k-2], and so on. This results in v[k-1] (placed
    // at index 1) and v[k] being together in a cycle, v[k-2] (placed at index
    // 2) with v[k-1] (placed at index k-1) also being together, and so on. This
    // means we can fix all these cycles in one more step. Here is an example
    // for a cycle of length 5:
    //
    //         v[1] v[2] v[3] v[4] v[5]        (1, 4) (2, 3)
    //         v[4] v[3] v[2] v[1] v[5]        (1, 5) (2, 4)
    //         v[5] v[1] v[2] v[3] v[4]

    vector<int> q = p;
    sort(q.begin(), q.end());

    if(p == q) {
        cout << 0 << endl;
        return;
    }

    auto [ok_1, swaps_1] = check_1(p, q);

    if(ok_1) {
        cout << 1 << endl;
        cout << swaps_1.size() << " ";
        for(auto [i, j]: swaps_1) {
            cout << i + 1 << " " << j + 1 << " ";
        }
        cout << endl;
        return;
    }

    vector<int> perm;
    map<int, int> cnt;
    for(int i = 0; i < n; i++) {
        int pi = lower_bound(q.begin(), q.end(), p[i]) - q.begin() + cnt[p[i]];
        cnt[p[i]]++;
        perm.push_back(pi);
    }

    vector<pair<int, int>> turns[2];
    vector<bool> visited(n, false);
    for(int i = 0; i < n; i++) {
        if(!visited[i]) {
            int u = i;
            vector<int> cycle;
            while(!visited[u]) {
                cycle.push_back(u);
                visited[u] = true;
                u = perm[u];
            }

            if(cycle.size() == 1) {
                continue;
            } else if(cycle.size() == 2) {
                turns[0].push_back({cycle[0], cycle[1]});
            } else {
                int l = 0, r = (int)cycle.size() - 2;
                while(l < r) {
                    turns[0].push_back({cycle[l], cycle[r]});
                    turns[1].push_back({cycle[l], cycle[r + 1]});
                    l++;
                    r--;
                }

                if(r == l) {
                    turns[1].push_back({cycle[l], cycle[r + 1]});
                }
            }
        }
    }

    cout << 2 << endl;
    for(int t = 0; t < 2; t++) {
        cout << turns[t].size() << " ";
        for(auto [i, j]: turns[t]) {
            cout << i + 1 << " " << j + 1 << " ";
        }
        cout << endl;
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
statement.txt
======================
539. Multiswap Sorting
Time limit per test: 1 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard

You are employed to implement a new fast sorting algorithm called multiswap sorting. The basic idea is simultaneous execution of multiple parallel swaps. You are given an array containing n integer elements a1, a2,..., an. At each step of the algorithm you must select one or more nonintersecting pairs of elements and swap the elements in each of the selected pairs.

For example, you are given the array [5, 4, 3, 2, 1]. At one step you can select two pairs (5, 1) and (4, 2), swap elements in them and get the array 1, 2, 3, 4, 5. Pairs (1, 2) and (2, 3) cannot be selected at one step, because they have the common element 2. So it is possible to sort the array [5, 4, 3, 2, 1] in one step.

Sort the given array in the minimum possible number of steps carrying out selection of pairs at each step optimally. Note that you are not required to minimize the total number of single swaps but the number of steps.

Input
The first line contains an integer n (1 ≤ n ≤ 1000) — the number of elements in the array. In the second line the elements ai are given. The numbers ai are integers not exceeding 109 by absolute value.

Output
In the first line output the minimum number of steps k. The next k lines should describe multiswaps in the form "p i1 j1 i2 j2 ip jp", where p > 0 is a number of pairs selected at the current step, is js are the indices of elements in the s-th pair (is ≠ js, indices of elements in distinct pairs must be distinct). The elements are indexed by integers from 1 to n according to their positions in the array at the current step. The order of pairs and the order of elements in pairs are unimportant. If there are multiple solutions with the minimum number of steps, output any.

Example(s)
sample input
sample output
3
1 2 3
0

sample input
sample output
5
5 4 3 2 1
1
2 1 5 2 4

sample input
sample output
4
3 1 2 2
2
2 1 2 3 4
1 4 2



Note
In the last example, after the first step the array takes the form 1, 3, 2, 2. At the second step 3 is swapped with the last 2. Note that the swap of the 3-rd and the 4-th elements at the first step does not change the array (these elements are equal). However, the answer with this pointless swap, as well as without it, is optimal, because your goal is to minimize the number of steps but not the number of swaps.

=================
