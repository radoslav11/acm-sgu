p318.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

int n, m;
vector<vector<int>> resource_users;

void read() {
    cin >> n >> m;
    resource_users.resize(n + 1);

    for(int u = 1; u <= m; u++) {
        int k;
        cin >> k;
        for(int j = 0; j < k; j++) {
            int r;
            cin >> r;
            resource_users[r].push_back(u);
        }
    }
}

void solve() {
    // The solution is fairly simple - we can just check for every file the set
    // of people that should have access to it. We don't want any other person
    // to have access to the same file, so this corresponds to a group. The only
    // way to share groups is if there is another file with the same set of
    // people. We can simply sort the ids of the people that should have access
    // to every file, and then sort all of these - the number of groups will be
    // the number of unique vectors.

    set<vector<int>> unique_groups;
    for(int r = 1; r <= n; r++) {
        if(!resource_users[r].empty()) {
            sort(resource_users[r].begin(), resource_users[r].end());
            unique_groups.insert(resource_users[r]);
        }
    }

    cout << unique_groups.size() << "\n";
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
p318.in1
======================
5 2
2 1 3
3 3 4 5

=================
statement.txt
======================
318. Grants
Time limit per test: 0.25 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



Berland City Central School has a lot of computers connected to the network. The network has a number of shared network resources and a number of users willing to access these resources. There are N resources numbered 1, 2,..., N and M users numbered 1, 2,..., M.

Let the user i require an access to the finite set of the resources Si = {ri1, ri2,... }. System administrator needs to grant each user each resource he or she wishes. The solution he chose is to use user groups.

User group is an object that allows to link users and resources. Each user group is associated with an arbitrary number of users and resources. Let Ug = {uj1, uj2,... } be the finite set of users associated with the group g. Let Rg = {rk1, rk2,... } be the finite set of resources associated with the same group g.

The system administrator should obey the following rules while creating the user groups:
No two different user groups can have common resources, i.e. each resource can belong to at most one user group.
A user has an access to a resource if this user belongs to the user group containing this resource.
Each user should have access to all resources he or she wishes, but to no any other resource.
A user can belong to any number of user groups.


Your task is to help the system administrator to create the user groups in such a way that the rules above are satisfied and the number of user groups is minimal.

Input
The first line of the input contains two integer numbers N and M (1 ≤ N, M≤ 100). Each of the following M lines contains the description of Si. Each description consists of the size of Si (non-negative integer not exceeding N) followed by the items of Si (different positive integers not exceeding N). Numbers in each line are separated by one or several spaces.

Output
Write the minimal number of the user groups required to the output.

Example(s)
sample input
sample output
5 2
2 1 3
3 3 4 5
3



Note
You need at least three user groups to grant desired access privileges to each user. For example, first group may contain first user and first object. Second group may contain both users and third object. Third group may contain second user and fourth and fifth objects.


=================
p318.ans1
======================
3

=================
