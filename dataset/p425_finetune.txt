<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

425. Control function
Time limit per test: 1 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard



A matrix T of non-negative integers with n rows and m columns is called a control matrix when its first row is different from all other rows. Formally speaking,   T1j ≠ Tij.

A function f from non-negative integers to non-negative integers is called a control function for the given control matrix T when the matrix f(T) obtained by applying f to every element of T is also a control matrix. Formally speaking,   f(T1j) ≠ f(Tij).

Find a control function with all values not exceeding 50 for the given control matrix T.

Input
The first line of the input file contains two integers n and m (1 ≤ n, m ≤ 1000). The next n lines contain m integers each, representing the matrix Tij (). It is guaranteed that the matrix T is a control matrix.

Output
Output "Yes" (without quotes) to the first line of the output file if such a function exists, and "No" (without quotes) otherwise. If the answer is positive, then output the function via "key -> value" pairs (without quotes). Order keys in increasing order. All different numbers from matrix T must appear as a key exactly once, and no other keys should be printed.

Example(s)
sample input
sample output
1 5
1 2 3 4 5
Yes
1 -> 0
2 -> 0
3 -> 0
4 -> 0
5 -> 0

sample input
sample output
2 2
1 2
1 3
Yes
1 -> 1
2 -> 1
3 -> 0

sample input
sample output
4 2
0 2
4 5
7 6
3 1
Yes
0 -> 1
1 -> 0
2 -> 1
3 -> 0
4 -> 1
5 -> 0
6 -> 1
7 -> 0

<|response|>
## 1) Abridged problem statement (concise)

You are given an `n × m` matrix `T` of non‑negative integers (`1 ≤ n,m ≤ 1000`). It is guaranteed that for every row `i > 1`, row `i` differs from the first row in at least one column.

Define a function `f : ℕ → ℕ`. After applying `f` to every matrix element, the first row must still differ from every other row (i.e., for each `i>1` there exists a column `j` with `f(T[1][j]) ≠ f(T[i][j])`).

Construct such a function where **all produced values are ≤ 50**, and output `f(x)` for every **distinct** number `x` appearing in `T`, as `x -> f(x)` in increasing order of `x`. Print `"No"` if impossible.

---

## 2) Key observations

1. **You only need one surviving mismatch per row.**  
   For each row `i>1`, it suffices that *some* column where `T[i][j] ≠ T[1][j]` remains different after mapping.

2. **Turn the task into “must be different” constraints between values.**  
   For each row `i>1`, pick **one** column `j` where it differs from row 1 (e.g., the first such `j`). Then we must enforce:
   \[
   f(T[i][j]) \ne f(T[1][j]).
   \]
   This is a single inequality constraint between two values from the matrix.

3. **Model constraints as a graph coloring problem.**  
   - Vertices: distinct values in the matrix.
   - Edge `(u,v)`: means `f(u) != f(v)`.

   If we properly color this graph, using the color as `f(value)`, all constraints are satisfied.

4. **There are few edges, so few colors suffice.**  
   We add at most one edge per row `i>1`, so:
   \[
   E \le n-1 \le 999.
   \]
   Graphs with at most 999 edges can be greedily colored using **< 50** colors (a known bound is `≤ ⌊√(2E)⌋ + 1`, and `√(2·999) ≈ 44.7`).

5. **Values not in any constraint can map to 0.**  
   Only vertices that appear in at least one edge need a positive color; all others can be safely assigned `0`.

---

## 3) Full solution approach

### Step A: Read input and collect all distinct values
- Read the matrix.
- Gather all numbers, sort, unique → list `vals` (these are the keys you must output).

### Step B: Build the constraint graph
For each row `i = 2..n`:
- Find the first column `j` such that `T[i][j] != T[1][j]`.
- Add an undirected edge between:
  - `u = T[i][j]`
  - `v = T[1][j]`

This ensures that after mapping, row `i` still differs from row 1 at that chosen column.

### Step C: Greedy color the graph (values → colors 1..)
- Consider only vertices with positive degree (appear in constraints).
- Process vertices in increasing degree order (helps keep colors small).
- For each vertex, choose the smallest positive color not used by its already-colored neighbors.

This yields a proper coloring with < 50 colors under the constraints above.

### Step D: Output the function
- Print `"Yes"`.
- For each value `x` in `vals` (in increasing order):
  - if `x` is colored: print `x -> color[x]`
  - else: print `x -> 0`

**Complexity**
- Building constraints: worst-case `O(nm)` to find mismatch per row (≤ 1e6 operations).
- Coloring: `O(E + V)` up to log factors (very small here).
- Fits easily within limits.

---

## 4) C++ implementation (detailed comments)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
  Idea:
  - For each row i>0, pick one mismatch column j with row0 and add constraint:
        f(tbl[i][j]) != f(tbl[0][j])
  - This becomes graph coloring on values; edges are constraints.
  - E <= n-1 <= 999, greedy coloring uses < 50 colors.
  - Output color for constrained values, 0 otherwise.
*/

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    vector<vector<int>> tbl(n, vector<int>(m));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> tbl[i][j];

    // Collect all distinct values to print them later as keys.
    vector<int> vals;
    vals.reserve((size_t)n * m);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            vals.push_back(tbl[i][j]);

    sort(vals.begin(), vals.end());
    vals.erase(unique(vals.begin(), vals.end()), vals.end());

    // Build constraint graph: value -> list of neighbor values.
    // Using map because values can be large, we want coordinate-free storage.
    map<int, vector<int>> adj;
    map<int, int> deg;

    // Add at most one edge per row i>0 (one constraint per row is enough).
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < m; j++) {
            int u = tbl[i][j];
            int v = tbl[0][j];
            if (u != v) {
                adj[u].push_back(v);
                adj[v].push_back(u);
                deg[u]++;
                deg[v]++;
                break;
            }
        }
    }

    // Prepare vertices that actually have constraints (degree>0),
    // and sort by increasing degree for a nicer greedy coloring order.
    vector<pair<int,int>> vertices; // (degree, value)
    vertices.reserve(deg.size());
    for (auto &kv : deg) {
        vertices.push_back({kv.second, kv.first});
    }
    sort(vertices.begin(), vertices.end());

    // color[value] = assigned positive color for constrained vertices
    map<int, int> color;

    // Greedy coloring:
    // For each vertex, pick the smallest positive integer not used by colored neighbors.
    for (auto [d, v] : vertices) {
        // Track colors used by already-colored neighbors.
        // Since degrees are small, this is fast.
        unordered_set<int> used;
        used.reserve(adj[v].size() * 2 + 1);

        for (int u : adj[v]) {
            auto it = color.find(u);
            if (it != color.end()) used.insert(it->second);
        }

        int c = 1;
        while (used.count(c)) c++;
        color[v] = c;

        // By theory (E<=999) c will stay <= 50 here.
        // The official approach relies on this bound.
    }

    cout << "Yes\n";
    // Output mapping for ALL distinct values in increasing order.
    // Unconstrained values get 0.
    for (int x : vals) {
        auto it = color.find(x);
        cout << x << " -> " << (it == color.end() ? 0 : it->second) << "\n";
    }

    return 0;
}
```

---

## 5) Python implementation (detailed comments)

```python
import sys
from collections import defaultdict

def solve() -> None:
    data = sys.stdin.buffer.read().split()
    it = iter(data)
    n = int(next(it))
    m = int(next(it))

    # Read matrix
    tbl = [[int(next(it)) for _ in range(m)] for _ in range(n)]

    # Collect all distinct values (keys that must be printed), sorted
    vals = sorted({tbl[i][j] for i in range(n) for j in range(m)})

    # Build constraint graph from one mismatch per row i>0
    adj = defaultdict(list)
    deg = defaultdict(int)

    for i in range(1, n):
        # find first mismatch with row 0
        for j in range(m):
            u = tbl[i][j]
            v = tbl[0][j]
            if u != v:
                adj[u].append(v)
                adj[v].append(u)
                deg[u] += 1
                deg[v] += 1
                break

    # Vertices involved in constraints, sorted by increasing degree
    vertices = sorted((d, v) for v, d in deg.items())

    # Greedy coloring: color[value] = smallest positive integer not used by colored neighbors
    color = {}

    for _, v in vertices:
        used = set()
        for u in adj[v]:
            if u in color:
                used.add(color[u])

        c = 1
        while c in used:
            c += 1
        color[v] = c
        # With E <= 999, this stays < 50 in this construction.

    # Output
    out = ["Yes"]
    for x in vals:
        out.append(f"{x} -> {color.get(x, 0)}")

    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    solve()
```

This construction guarantees that for every row `i>1`, at least one chosen mismatch remains a mismatch after applying `f`, so the transformed matrix is still a control matrix, with all outputs ≤ 50.