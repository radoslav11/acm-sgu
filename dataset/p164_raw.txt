p164.ans1
======================
2
1 3

=================
p164.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

int n, k;
vector<vector<int>> G;

void read() {
    cin >> n >> k;
    G.assign(n, vector<int>(n, 0));
    cin >> G;
}

bool solve_even() {
    vector<vector<int>> dist(n, vector<int>(n, (int)1e9));
    for(int i = 0; i < n; i++) {
        dist[i][i] = 0;
    }
    for(int i = 0; i < n; i++) {
        for(int j = i + 1; j < n; j++) {
            if(G[i][j] == 0) {
                dist[i][j] = 1;
                dist[j][i] = 1;
            }
        }
    }

    for(int k = 0; k < n; k++) {
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(dist[i][j] > 3) {
                return false;
            }
        }
    }
    return true;
}

void solve() {
    // In problems like this, it's always good to ask the question of when this
    // is actually possible. Turns out it always is. In particular, let's
    // consider the case of only 2 colours, as reducing k colours to that case
    // is trivial - just split into "odd" and "even" colours.
    //
    // The claim is that for 2 colours, one of them always satisfies that the
    // distance between each pair is <= 3. Let's consider the case of n=4 first.
    // We can go through all examples to convince ourselves, but there is a
    // simpler argument for why this is true - for any graph G, either G or K_n
    // - G is connected (this is a standard results which we can get convinced
    // about by thinking about the complementary edges and that they connect all
    // connected components in G), and with n nodes the distance is always <= 3
    // (as 4 edges means a cycle and so not a simple path).
    //
    // Now let's look at n > 4 and assume for contradiction. This means that for
    // both colours, there are 2 vertices (u_black, v_black) and (u_white,
    // v_white) such that the black distance between u_black and v_black is > 3,
    // and the white distance between u_white and v_white is > 3. However, we
    // already have a result for n = 4: consider the subgraph with V = {u_black,
    // v_black, u_white, v_black} and the result implying that there is at least
    // one colour that has distance less than or equal to 3 between all pairs.
    // This means there is a trivial contradiction between one of the two
    // assumptions.
    //
    // Now that we have some results, let's actually solve the problem. The
    // first step is to split the K colours into 2. This will be done via the
    // parity. Afterwards, we can just do Floyd to check if all distances are
    // less than or equal to 3, as the constraints are n <= 200. We should
    // technically be able to do this a bit faster with bitsets - it's enought
    // to compute G^1, G^2 and G^3, but for this problem Floyd is enough.

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            G[i][j] = G[i][j] % 2;
        }
    }

    vector<int> ans;
    for(int i = 1 + solve_even(); i <= k; i += 2) {
        ans.push_back(i);
    }

    cout << ans.size() << endl;
    cout << ans << endl;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
statement.txt
======================
164. Airlines
time limit per test: 0.25 sec.
memory limit per test: 4096 KB
input: standard
output: standard



Microland country has very big territory, so its citizens always travel by air between cities. This is why transporting people by air is very profitable in Microland, and some years ago there was exactly one direct air flight between any two cities and there had survived only one air company, "Microland airlines". But then some Microland states suited it for violating the antitrust law and, according to the decision of the court, that company was divided into M independent parts, which later become known as "Microland airlines 1", "Microland airlines 2" and so on. Every flight previously owned by "Microland airlines" became owned by exactly one of its parts.

Now the president elections are coming in this country. To increase his rating, current president of Microland decided to buy some parts of "Microland airlines" and make flights of these companies free. He wants to make it easier to travel from any city to any, so for any two cities he wants to make it able to fly from one to other making not more than 2 changes, i.e. using not more than 3 free flights. In other words, for any two cities A and B: direct flight between these cities must be done free, or there must exist a city C so that flights from A to C and from C to B will be done free, or there must exist two cities C and D so that flights from A to C, from C to D, from D to B will be done free. But, of course, the president is avoid of breaking that antitrust law (the court is really independent in Microland!). Not to violate it, president has to buy not more than ((M+1) div 2) "Microland airlines" parts.

You are working in president's team. You are to write a program that will decide, what parts of "Microland airlines" the president should buy.

Input
On the first line of input there are two integers N and M (1<=N<=200) --- the number of cities in Microland and the number of "Microland airlines" parts. Next N lines contain N integers each. i-th integer in i-th line is 0; and j-th, if j<>i, is the number of "Microland airlines" part which owns direct flight from i-th city to j-th (and from j-th to i-th too). Each "Microland airlines" part owns at least one flight.

Output
If the solution exists, write on the first line of output one integer --- the number of "Microland airlines" parts that should be bought by president. On the second line of output write the numbers of these parts in any order. If several solutions exist, output any. If no solutions exist, output only one integer "-1".

Sample test(s)

Input
4 3
0 3 2 2
3 0 1 2
2 1 0 1
2 2 1 0

Output
2
1 3
Author:	NNSU #2 team
Resource:	Lazurny olympiad in informatics, 2002
Date:	July-August 2002







=================
p164.in1
======================
4 3
0 3 2 2
3 0 1 2
2 1 0 1
2 2 1 0

=================
