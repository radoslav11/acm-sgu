<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

478. Excursion
Time limit per test: 0.25 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



One day a group of students, consisting of boys (a heads) and girls (b heads), got to an idea to make an excursion led by their school teacher over the city, they lived in. At the very start of the party schoolboys went away walking separately from the teacher, rather than obedient school girls, who stayed with the teacher. Anyhow, when approaching any boutique during the excursion, some girls can leave the group to go for a fitting their lovely dresses, and they will never come back again. On the contrary, ruddy cheeked and cheered up boys can go back to the teacher and stay with him with great enjoy until the end of excursion. At some points of time scrupulous teacher recalculates the number of students in the group and writes it down in his notebook.

Now the teacher wants to evaluate the effectiveness of extracurricular work, so he askes you to find any feasible student joining/disjoining schedule.

Input
The first line of input contains two integers a and b (1 ≤ a, b ≤ 100) — the number of boys and girls respectively. The second line has the only integer n (1 ≤ n ≤ 100) — the number of notes in teacher's book. The third one contains exactly n non-negative integers not exceeding 200, denoting numbers the teacher wrote down, in the order of their appearance in the notebook.

Output
If there are any mistakes in teacher's notes, that is no feasible schedule exists, print "ERROR". Otherwise, print to output n lines. i-th line should contain two non-negative integers, denoting the number of schoolboys joined and the number of schoolgirls separated from the teacher respectively exactly before he recalculated students at i-th time. If there are multiple solutions, output any.

Example(s)
sample input
sample output
3 3
2
2 3
1 2
2 1

sample input
sample output
3 3
3
1 2 5
ERROR

sample input
sample output
2 2
1
2
0 0

<|response|>
1) Abridged problem statement

- There are a boys and b girls. Initially, 0 boys are with the teacher and all b girls are with the teacher.
- The teacher takes n notes. For each note i:
  - Before counting, some nonnegative number of boys may join (boys never leave afterward).
  - Some nonnegative number of girls may leave (girls never return).
  - Then the teacher writes the current group size.
- Given the n recorded sizes, output any sequence of moves (boys_joined_i, girls_left_i) for i = 1..n that matches the notes. If impossible, print "ERROR".


2) Key observations

- Monotonicity:
  - Boys with the teacher never decrease (only join): B_i ≥ B_{i−1}.
  - Girls with the teacher never increase (only leave): G_i ≤ G_{i−1}.
- Bounds: 0 ≤ B_i ≤ a and 0 ≤ G_i ≤ b for all i.
- Sum constraint at each recorded note: B_i + G_i = recorded_count_i.
- Convenient initialization: treat an implicit note 0 with total b (because we start with 0 boys and b girls). So cnt[0] = b and the given notes become cnt[1..n].
- Transition from step i−1 to i:
  - Let current girls be G_{i−1} = cnt[i−1] − B_{i−1}. Choose any y in [0..G_{i−1}] girls to leave.
  - Then G_i = G_{i−1} − y is fixed, so B_i = cnt[i] − G_i is determined.
  - Validity requires B_i ≥ B_{i−1}, 0 ≤ B_i ≤ a.


3) Full solution approach

- Dynamic programming over states (pos, boys):
  - pos ∈ [0..n] is how many notes have been processed.
  - boys is the number of boys with the teacher at that time.
  - dp[pos][boys] = reachable or not.
- Initialization: dp[0][0] = true (0 boys, b girls).
- Transition:
  - For each reachable state (pos, boys), compute girls = cnt[pos] − boys. If girls is outside [0..b], skip.
  - For all girls_left in [0..girls]:
    - new_girls = girls − girls_left
    - new_boys = cnt[pos+1] − new_girls
    - If new_boys ≥ boys and 0 ≤ new_boys ≤ a, mark dp[pos+1][new_boys] = true.
    - Store a parent pointer to reconstruct the move:
      - prev_boys = boys
      - boys_joined = new_boys − boys
      - girls_left = girls_left
- After filling DP, if any dp[n][end_boys] is true, backtrack using the parent pointers to produce the sequence of (boys_joined, girls_left) for each step. Otherwise, print "ERROR".
- Complexity:
  - States: (n+1) × (a+1) ≤ 101 × 101.
  - For each state, we try up to b options of girls leaving.
  - Time O(n · a · b) ≤ about 10^6 operations; memory O(n · a).


4) C++ implementation with detailed comments

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Step {
    int prev_boys;   // boys at previous position
    int joined;      // boys joined at this step
    int left;        // girls left at this step
    bool used;       // whether this parent is set
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int a, b;       // total boys, total girls
    int n;          // number of notes
    if (!(cin >> a >> b)) return 0;
    cin >> n;
    vector<int> rec(n);
    for (int i = 0; i < n; ++i) cin >> rec[i];

    // Prepend the implicit initial "note": starting total is b (0 boys + b girls)
    vector<int> cnt(n + 1);
    cnt[0] = b;
    for (int i = 0; i < n; ++i) cnt[i + 1] = rec[i];

    // dp[pos][boys] = reachable after processing 'pos' notes with 'boys' boys present
    vector<vector<char>> dp(n + 1, vector<char>(a + 1, 0));
    // Parent pointers to reconstruct solution
    vector<vector<Step>> par(n + 1, vector<Step>(a + 1, {-1, -1, -1, false}));

    dp[0][0] = 1; // initial: 0 boys, b girls

    for (int pos = 0; pos < n; ++pos) {
        for (int boys = 0; boys <= a; ++boys) {
            if (!dp[pos][boys]) continue;
            // Current girls must match cnt[pos] - boys
            int girls = cnt[pos] - boys;
            if (girls < 0 || girls > b) continue;

            // Try all possible numbers of girls leaving before the next note
            for (int left = 0; left <= girls; ++left) {
                int new_girls = girls - left;
                // The next recorded total fixes the new number of boys
                int new_boys = cnt[pos + 1] - new_girls;

                // Validate: boys are non-decreasing and within [0, a]
                if (new_boys < boys || new_boys < 0 || new_boys > a) continue;

                if (!dp[pos + 1][new_boys]) {
                    dp[pos + 1][new_boys] = 1;
                    par[pos + 1][new_boys] = {boys, new_boys - boys, left, true};
                }
            }
        }
    }

    // Find any reachable final state
    int end_boys = -1;
    for (int boys = 0; boys <= a; ++boys) {
        if (dp[n][boys]) { end_boys = boys; break; }
    }

    if (end_boys == -1) {
        cout << "ERROR\n";
        return 0;
    }

    // Reconstruct actions from par
    vector<pair<int,int>> actions; // (boys_joined, girls_left)
    int pos = n, boys = end_boys;
    while (pos > 0) {
        Step s = par[pos][boys];
        // Since dp[pos][boys] is true for pos>0, par must be set
        actions.push_back({s.joined, s.left});
        boys = s.prev_boys;
        --pos;
    }
    reverse(actions.begin(), actions.end());

    for (auto [joined, left] : actions) {
        cout << joined << ' ' << left << '\n';
    }
    return 0;
}
```

5) Python implementation with detailed comments

```python
import sys

def solve():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    a = int(next(it))  # total boys
    b = int(next(it))  # total girls
    n = int(next(it))  # number of notes
    rec = [int(next(it)) for _ in range(n)]

    # Prepend the implicit initial note: starting total is b (0 boys + b girls)
    cnt = [b] + rec  # cnt[0..n]

    # dp[pos][boys] = reachable after processing pos notes with 'boys' boys
    dp = [[False] * (a + 1) for _ in range(n + 1)]
    # par[pos][boys] = (prev_boys, boys_joined, girls_left)
    par = [[None] * (a + 1) for _ in range(n + 1)]

    dp[0][0] = True  # initial: 0 boys, b girls

    for pos in range(n):
        for boys in range(a + 1):
            if not dp[pos][boys]:
                continue
            girls = cnt[pos] - boys  # must match current recorded total
            if girls < 0 or girls > b:
                continue

            # Try all numbers of girls leaving before next note
            for left in range(girls + 1):
                new_girls = girls - left
                new_boys = cnt[pos + 1] - new_girls

                # Validate: boys non-decreasing and in range
                if new_boys < boys or new_boys < 0 or new_boys > a:
                    continue

                if not dp[pos + 1][new_boys]:
                    dp[pos + 1][new_boys] = True
                    par[pos + 1][new_boys] = (boys, new_boys - boys, left)

    # Find any reachable final state
    end_boys = None
    for boys in range(a + 1):
        if dp[n][boys]:
            end_boys = boys
            break

    if end_boys is None:
        print("ERROR")
        return

    # Reconstruct actions
    actions = []
    pos = n
    boys = end_boys
    while pos > 0:
        prev_boys, joined, left = par[pos][boys]
        actions.append((joined, left))
        boys = prev_boys
        pos -= 1

    actions.reverse()
    out_lines = ['{} {}'.format(j, l) for j, l in actions]
    print('\n'.join(out_lines))

if __name__ == "__main__":
    solve()
```