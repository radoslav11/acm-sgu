p421.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

const int base = 1000000000;
const int base_digits = 9;

struct bigint {
    vector<int> z;
    int sign;

    bigint() : sign(1) {}

    bigint(long long v) { *this = v; }

    bigint(const string& s) { read(s); }

    void operator=(const bigint& v) {
        sign = v.sign;
        z = v.z;
    }

    void operator=(long long v) {
        sign = 1;
        if(v < 0) {
            sign = -1, v = -v;
        }
        z.clear();
        for(; v > 0; v = v / base) {
            z.push_back(v % base);
        }
    }

    bigint operator+(const bigint& v) const {
        if(sign == v.sign) {
            bigint res = v;

            for(int i = 0, carry = 0;
                i < (int)max(z.size(), v.z.size()) || carry; ++i) {
                if(i == (int)res.z.size()) {
                    res.z.push_back(0);
                }
                res.z[i] += carry + (i < (int)z.size() ? z[i] : 0);
                carry = res.z[i] >= base;
                if(carry) {
                    res.z[i] -= base;
                }
            }
            return res;
        }
        return *this - (-v);
    }

    bigint operator-(const bigint& v) const {
        if(sign == v.sign) {
            if(abs() >= v.abs()) {
                bigint res = *this;
                for(int i = 0, carry = 0; i < (int)v.z.size() || carry; ++i) {
                    res.z[i] -= carry + (i < (int)v.z.size() ? v.z[i] : 0);
                    carry = res.z[i] < 0;
                    if(carry) {
                        res.z[i] += base;
                    }
                }
                res.trim();
                return res;
            }
            return -(v - *this);
        }
        return *this + (-v);
    }

    void operator*=(int v) {
        if(v < 0) {
            sign = -sign, v = -v;
        }
        for(int i = 0, carry = 0; i < (int)z.size() || carry; ++i) {
            if(i == (int)z.size()) {
                z.push_back(0);
            }
            long long cur = z[i] * (long long)v + carry;
            carry = (int)(cur / base);
            z[i] = (int)(cur % base);
        }
        trim();
    }

    bigint operator*(int v) const {
        bigint res = *this;
        res *= v;
        return res;
    }

    friend pair<bigint, bigint> divmod(const bigint& a1, const bigint& b1) {
        int norm = base / (b1.z.back() + 1);
        bigint a = a1.abs() * norm;
        bigint b = b1.abs() * norm;
        bigint q, r;
        q.z.resize(a.z.size());

        for(int i = a.z.size() - 1; i >= 0; i--) {
            r *= base;
            r += a.z[i];
            int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;
            int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;
            int d = ((long long)s1 * base + s2) / b.z.back();
            r -= b * d;
            while(r < 0) {
                r += b, --d;
            }
            q.z[i] = d;
        }

        q.sign = a1.sign * b1.sign;
        r.sign = a1.sign;
        q.trim();
        r.trim();
        return make_pair(q, r / norm);
    }

    friend bigint sqrt(const bigint& a1) {
        bigint a = a1;
        while(a.z.empty() || a.z.size() % 2 == 1) {
            a.z.push_back(0);
        }

        int n = a.z.size();

        int firstDigit = (int)sqrt((double)a.z[n - 1] * base + a.z[n - 2]);
        int norm = base / (firstDigit + 1);
        a *= norm;
        a *= norm;
        while(a.z.empty() || a.z.size() % 2 == 1) {
            a.z.push_back(0);
        }

        bigint r = (long long)a.z[n - 1] * base + a.z[n - 2];
        firstDigit = (int)sqrt((double)a.z[n - 1] * base + a.z[n - 2]);
        int q = firstDigit;
        bigint res;

        for(int j = n / 2 - 1; j >= 0; j--) {
            for(;; --q) {
                bigint r1 =
                    (r - (res * 2 * base + q) * q) * base * base +
                    (j > 0 ? (long long)a.z[2 * j - 1] * base + a.z[2 * j - 2]
                           : 0);
                if(r1 >= 0) {
                    r = r1;
                    break;
                }
            }
            res *= base;
            res += q;

            if(j > 0) {
                int d1 =
                    res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;
                int d2 =
                    res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;
                int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;
                q = ((long long)d1 * base * base + (long long)d2 * base + d3) /
                    (firstDigit * 2);
            }
        }

        res.trim();
        return res / norm;
    }

    bigint operator/(const bigint& v) const { return divmod(*this, v).first; }

    bigint operator%(const bigint& v) const { return divmod(*this, v).second; }

    void operator/=(int v) {
        if(v < 0) {
            sign = -sign, v = -v;
        }
        for(int i = (int)z.size() - 1, rem = 0; i >= 0; --i) {
            long long cur = z[i] + rem * (long long)base;
            z[i] = (int)(cur / v);
            rem = (int)(cur % v);
        }
        trim();
    }

    bigint operator/(int v) const {
        bigint res = *this;
        res /= v;
        return res;
    }

    int operator%(int v) const {
        if(v < 0) {
            v = -v;
        }
        int m = 0;
        for(int i = z.size() - 1; i >= 0; --i) {
            m = (z[i] + m * (long long)base) % v;
        }
        return m * sign;
    }

    void operator+=(const bigint& v) { *this = *this + v; }
    void operator-=(const bigint& v) { *this = *this - v; }
    void operator*=(const bigint& v) { *this = *this * v; }
    void operator/=(const bigint& v) { *this = *this / v; }

    bool operator<(const bigint& v) const {
        if(sign != v.sign) {
            return sign < v.sign;
        }
        if(z.size() != v.z.size()) {
            return z.size() * sign < v.z.size() * v.sign;
        }
        for(int i = z.size() - 1; i >= 0; i--) {
            if(z[i] != v.z[i]) {
                return z[i] * sign < v.z[i] * sign;
            }
        }
        return false;
    }

    bool operator>(const bigint& v) const { return v < *this; }
    bool operator<=(const bigint& v) const { return !(v < *this); }
    bool operator>=(const bigint& v) const { return !(*this < v); }
    bool operator==(const bigint& v) const {
        return !(*this < v) && !(v < *this);
    }
    bool operator!=(const bigint& v) const { return *this < v || v < *this; }

    void trim() {
        while(!z.empty() && z.back() == 0) {
            z.pop_back();
        }
        if(z.empty()) {
            sign = 1;
        }
    }

    bool isZero() const { return z.empty() || (z.size() == 1 && !z[0]); }

    bigint operator-() const {
        bigint res = *this;
        res.sign = -sign;
        return res;
    }

    bigint abs() const {
        bigint res = *this;
        res.sign *= res.sign;
        return res;
    }

    long long longValue() const {
        long long res = 0;
        for(int i = z.size() - 1; i >= 0; i--) {
            res = res * base + z[i];
        }
        return res * sign;
    }

    friend bigint gcd(const bigint& a, const bigint& b) {
        return b.isZero() ? a : gcd(b, a % b);
    }
    friend bigint lcm(const bigint& a, const bigint& b) {
        return a / gcd(a, b) * b;
    }

    void read(const string& s) {
        sign = 1;
        z.clear();
        int pos = 0;
        while(pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')) {
            if(s[pos] == '-') {
                sign = -sign;
            }
            ++pos;
        }
        for(int i = s.size() - 1; i >= pos; i -= base_digits) {
            int x = 0;
            for(int j = max(pos, i - base_digits + 1); j <= i; j++) {
                x = x * 10 + s[j] - '0';
            }
            z.push_back(x);
        }
        trim();
    }

    friend istream& operator>>(istream& stream, bigint& v) {
        string s;
        stream >> s;
        v.read(s);
        return stream;
    }

    friend ostream& operator<<(ostream& stream, const bigint& v) {
        if(v.sign == -1) {
            stream << '-';
        }
        stream << (v.z.empty() ? 0 : v.z.back());
        for(int i = (int)v.z.size() - 2; i >= 0; --i) {
            stream << setw(base_digits) << setfill('0') << v.z[i];
        }
        return stream;
    }

    static vector<int> convert_base(
        const vector<int>& a, int old_digits, int new_digits
    ) {
        vector<long long> p(max(old_digits, new_digits) + 1);
        p[0] = 1;
        for(int i = 1; i < (int)p.size(); i++) {
            p[i] = p[i - 1] * 10;
        }
        vector<int> res;
        long long cur = 0;
        int cur_digits = 0;
        for(int i = 0; i < (int)a.size(); i++) {
            cur += a[i] * p[cur_digits];
            cur_digits += old_digits;
            while(cur_digits >= new_digits) {
                res.push_back(int(cur % p[new_digits]));
                cur /= p[new_digits];
                cur_digits -= new_digits;
            }
        }
        res.push_back((int)cur);
        while(!res.empty() && res.back() == 0) {
            res.pop_back();
        }
        return res;
    }

    typedef vector<long long> vll;

    static vll karatsubaMultiply(const vll& a, const vll& b) {
        int n = a.size();
        vll res(n + n);
        if(n <= 32) {
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
                    res[i + j] += a[i] * b[j];
                }
            }
            return res;
        }

        int k = n >> 1;
        vll a1(a.begin(), a.begin() + k);
        vll a2(a.begin() + k, a.end());
        vll b1(b.begin(), b.begin() + k);
        vll b2(b.begin() + k, b.end());

        vll a1b1 = karatsubaMultiply(a1, b1);
        vll a2b2 = karatsubaMultiply(a2, b2);

        for(int i = 0; i < k; i++) {
            a2[i] += a1[i];
        }
        for(int i = 0; i < k; i++) {
            b2[i] += b1[i];
        }

        vll r = karatsubaMultiply(a2, b2);
        for(int i = 0; i < (int)a1b1.size(); i++) {
            r[i] -= a1b1[i];
        }
        for(int i = 0; i < (int)a2b2.size(); i++) {
            r[i] -= a2b2[i];
        }

        for(int i = 0; i < (int)r.size(); i++) {
            res[i + k] += r[i];
        }
        for(int i = 0; i < (int)a1b1.size(); i++) {
            res[i] += a1b1[i];
        }
        for(int i = 0; i < (int)a2b2.size(); i++) {
            res[i + n] += a2b2[i];
        }
        return res;
    }

    bigint operator*(const bigint& v) const {
        vector<int> a6 = convert_base(this->z, base_digits, 6);
        vector<int> b6 = convert_base(v.z, base_digits, 6);
        vll a(a6.begin(), a6.end());
        vll b(b6.begin(), b6.end());
        while(a.size() < b.size()) {
            a.push_back(0);
        }
        while(b.size() < a.size()) {
            b.push_back(0);
        }
        while(a.size() & (a.size() - 1)) {
            a.push_back(0), b.push_back(0);
        }
        vll c = karatsubaMultiply(a, b);
        bigint res;
        res.sign = sign * v.sign;
        for(int i = 0, carry = 0; i < (int)c.size(); i++) {
            long long cur = c[i] + carry;
            res.z.push_back((int)(cur % 1000000));
            carry = (int)(cur / 1000000);
        }
        res.z = convert_base(res.z, 6, base_digits);
        res.trim();
        return res;
    }
};

int n, m, k;
vector<int> a;

void read() {
    cin >> n >> m >> k;
    a.resize(n);
    cin >> a;
}

struct State {
    vector<int> pos_indices;
    vector<int> neg_indices;
    int pos_lo, pos_hi;
    int neg_lo, neg_hi;
    mutable bigint cached_product;
    mutable bool has_cache;

    State(vector<int> pos, vector<int> neg, int pl, int ph, int nl, int nh)
        : pos_indices(pos),
          neg_indices(neg),
          pos_lo(pl),
          pos_hi(ph),
          neg_lo(nl),
          neg_hi(nh),
          has_cache(false) {}

    bigint compute_product() const {
        if(!has_cache) {
            cached_product = 1;
            for(int idx: neg_indices) {
                cached_product *= a[idx];
            }
            for(int idx: pos_indices) {
                cached_product *= a[idx];
            }
            has_cache = true;
        }
        return cached_product;
    }

    bool operator<(const State& other) const {
        if(neg_indices != other.neg_indices) {
            return neg_indices < other.neg_indices;
        }
        return pos_indices < other.pos_indices;
    }
};

struct StateComparator {
    bool operator()(const State& a, const State& b) const {
        return a.compute_product() < b.compute_product();
    }
};

State create_initial_state(int num_negs, int split) {
    bool minimize_abs = (num_negs % 2 == 0);

    int num_pos = m - num_negs;
    vector<int> pos_indices(num_pos);
    vector<int> neg_indices(num_negs);

    int pos_lo, pos_hi, neg_lo, neg_hi;
    if(minimize_abs) {
        for(int i = 0; i < num_pos; i++) {
            pos_indices[i] = n - 1 - i;
        }
        pos_lo = split;
        pos_hi = n;

        for(int i = 0; i < num_negs; i++) {
            neg_indices[i] = i;
        }
        neg_lo = 0;
        neg_hi = split;
    } else {
        for(int i = 0; i < num_pos; i++) {
            pos_indices[i] = split + i;
        }
        pos_lo = split;
        pos_hi = n;

        for(int i = 0; i < num_negs; i++) {
            neg_indices[i] = split - 1 - i;
        }
        neg_lo = 0;
        neg_hi = split;
    }

    return State(pos_indices, neg_indices, pos_lo, pos_hi, neg_lo, neg_hi);
}

void solve() {
    // Before we start, we should notice that the problem requires big integers
    // as the product can end up fairly large. Also, we should be careful with
    // negative numbers as they make the problem trickier. There are a couple
    // way of solving this, but a lot of them start with creating a (n + 1) x (m
    // + 1) graph, with nodes being (i, c) corresponding that we have looked at
    // element up to i, and currently have selected c <= m elements. We will
    // have edges from (i, c) to (i + 1, c) and (i + 1, c + 1), with weights 1
    // and a[i]. Now the problem ends up being trying to find k-th largest path
    // if the length is the product instead of the sum. A popular approach is to
    // use log(weight) and convert back to sums, but in this problem we have the
    // negative numbers (which is still doable by maintaining on more state),
    // but also we are interested in the exact product and this step would be
    // unneeded. We should keep in mind that this graph is a DAG, which makes
    // the solution a bit easier.
    //
    // One memory efficient approach is to binary search the answer and now try
    // to find K arbitrary paths <= MID. We will precompute a dp[node] = {min,
    // max} where min and max are the smallest and largest achievable product.
    // This is trivial to compute, as when we have a positive weight we simply
    // scale them, while the negative weights swap them and scale afterwards.
    // Now we can perform a DFS and greedily prune the search. This guarantees
    // that we will visit at least one new product <= MID on every O(n+m) steps,
    // giving us a O((n+m)*k*log(ans)) solution. The DFS does make this quicker
    // in practice, but it's unclear how easy it is to make it pass.
    //
    // However, in this problem we have plenty of memory, so we can go for an
    // alternative approach. Particularly, it would have been nice if we could
    // incrementally build a heap of all paths starting from some vertex and
    // ending in (n, m), and then quickly merge this when going to neighbours.
    // This is actually possible using the randomized meldable heap data
    // structure. Let's keep a similar dp[node] = {min, max}, but this time the
    // min and max are the full heaps rather than just the top values. The
    // update is fairly similar in terms of the weight being negative being
    // equivalent to a swap of min/max heaps first, while the scaling can be
    // implemented with a lazy. This solution will naively have O(log(C(n, m)))
    // as the depth of the heaps, but that might be a bit large and not
    // necessary needed. We can try cutting the merge short after C*log(k) for
    // some C, as we don't really care about element that aren't in the first k.
    // In practice, log(k) <= 14, so we can cut the merge once the depth reaches
    // around 80-100. Unfortunately, this is still somewhat tricky to squeeze so
    // we will use a few more observations.
    //
    // We have both positive and negative numbers, but the final result's sign
    // is determined based on whether we use an even or odd number of negative
    // numbers. Instead of trying to choose m numbers, let's try to choose x
    // negative numbers and m-x positive numbers. This would be O(m) vectors of
    // size O(k), which we will then merge and output the smallest k. The nice
    // thing about a fixed x is that the sign is already determined and we can
    // treat all numbers are positive. The only difference is that if we have a
    // negative sign we are interested in making the product large, while if
    // it's positive we would want it low. Let's consider the case of positive
    // product. The smallest product is clearly achieved by sorting and then
    // taking the largest x negative numbers, and smallest m-x positive. If we
    // want to then get the second largest product, it would be one of these m
    // selected numbers replaced with the next unused. The key observation is
    // that there are only O(m) transitions. This means that we can use a
    // regular priority queue, and discover at least one new subset every O(m)
    // transitions. One potential issue is that we could go through the same
    // state multiple times, so we would need to have some visited array / map.
    // Ignoring the big integers, and the visited array complexity, this gives
    // us a direct solution in O(k * m * log k). We do have to perform this
    // solution O(m) times, but the nice part here is that the constant is
    // significantly lower compared to the meldable heaps. Furthermore, we don't
    // need to explicitly do the O(m) independent solutions, as we can directly
    // do one priority queue for all. This can remove this additional factor of
    // O(m).

    sort(a.begin(), a.end());

    int split = 0;
    while(split < n && a[split] < 0) {
        split++;
    }

    int total_pos = n - split;
    int total_neg = split;

    set<State> visited;
    priority_queue<State, vector<State>, StateComparator> pq;

    for(int num_negs = 0; num_negs <= m; num_negs++) {
        int num_pos = m - num_negs;
        if(num_negs > total_neg || num_pos > total_pos) {
            continue;
        }

        State initial = create_initial_state(num_negs, split);
        if(visited.find(initial) == visited.end()) {
            visited.insert(initial);
            pq.push(initial);
        }
    }

    for(int step = 0; step < k && !pq.empty(); step++) {
        State current = pq.top();
        pq.pop();

        if(step == k - 1) {
            cout << current.compute_product() << '\n';
            return;
        }

        for(int i = 0; i < (int)current.pos_indices.size(); ++i) {
            bool moving_up =
                (current.pos_indices[0] < current.pos_indices.back());

            int cur_val = current.pos_indices[i];
            int new_val = moving_up ? cur_val + 1 : cur_val - 1;

            int limit = (i + 1 < (int)current.pos_indices.size())
                            ? current.pos_indices[i + 1]
                            : (moving_up ? current.pos_hi : current.pos_lo - 1);

            bool valid = moving_up ? (new_val < limit) : (new_val > limit);

            if(valid) {
                State neighbor = current;
                neighbor.pos_indices[i] = new_val;
                neighbor.has_cache = false;
                if(visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    pq.push(neighbor);
                }
            }
        }

        for(int i = 0; i < (int)current.neg_indices.size(); ++i) {
            bool moving_up =
                current.neg_indices.empty() ||
                (current.neg_indices[0] < current.neg_indices.back());

            int cur_val = current.neg_indices[i];
            int new_val = moving_up ? cur_val + 1 : cur_val - 1;

            int limit = (i + 1 < (int)current.neg_indices.size())
                            ? current.neg_indices[i + 1]
                            : (moving_up ? current.neg_hi : current.neg_lo - 1);

            bool valid = moving_up ? (new_val < limit) : (new_val > limit);

            if(valid) {
                State neighbor = current;
                neighbor.neg_indices[i] = new_val;
                neighbor.has_cache = false;
                if(visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    pq.push(neighbor);
                }
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    for(int test = 1; test <= T; test++) {
        read();
        solve();
    }

    return 0;
}

=================
p421.in1
======================
4 3 3
2 3 3 5

=================
p421.ans1
======================
30

=================
statement.txt
======================
421. k-th Product
Time limit per test: 0.75 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard



Consider n integer numbers a1, a2,..., an. Consider the products of their  m-tuples: b1, b2,..., bN. You are to find k-th largest product, i.e., k-th item in the list (bi) sorted in non-increasing order (items of the list are numbered starting from 1).

Note that the numbers can be negative.

Input
The input file contains three integer numbers n, m, k (1 ≤ n, k ≤ 10000, 1 ≤ m ≤ 13, k ≤ Cnm), followed by n integer numbers ai (-106 ≤ ai ≤ 106).

Output
Output one integer number — the k-th largest product.

Example(s)
sample input
sample output
4 3 3
2 3 3 5
30



There are four possible products in the example: 3 · 3 · 5 = 45, 2 · 3 · 5 = 30 (involving the first 3), 2 · 3 · 5 = 30 (involving the second 3), 2 · 3 · 3 = 18.


=================
