p165.ans1
======================
yes
1 6 2 5 3 4

=================
p165.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

int n;
vector<double> a;

void read() {
    cin >> n;
    a.resize(n);
    cin >> a;
}

void solve() {
    // The key observation is that the initial sequence has average of 2.0, and
    // all elements are within [1.95; 2.05]. We will show that the answer is
    // always "yes". A helpful reformulation is that we want all subarrays to
    // have average within [1.90;2.10], or equivalently, if we subtract 2.0 from
    // each element, all subarrays must have sum within [-0.10;0.10]. The
    // initial average of 2.0 also means that the sum of all elements is 0.0. To
    // have each sum within [-0.10;0.10], it sufficient for all prefix sums to
    // be within [-0.05;0.05], which we can guarantee by constructing the
    // permutation greedily:
    //
    // - If the current prefix sum is positive, we know that there is certainly
    //   at least one negative element remaining (since the total sum is 0.0),
    //   so we add the smallest element remaining.
    //
    // - If the current prefix sum is non-positive, we add the largest element
    //   remaining. We are guaranteed that there is at least one positive
    //   element remaining, since otherwise the total sum would be negative.
    //
    // This way, we guarantee that the prefix sum always stays within
    // [-min_element;max_element], which is a subset of [-0.05;0.05].

    for(auto& x: a) {
        x -= 2.0;
    }

    vector<int> perm(n), ans;
    iota(perm.begin(), perm.end(), 0);
    sort(perm.begin(), perm.end(), [&](int i, int j) { return a[i] < a[j]; });

    double sum = 0.0;
    int l = 0, r = n - 1;
    for(int i = 0; i < n; i++) {
        if(sum > 0) {
            sum += a[perm[l++]];
            ans.push_back(perm[l - 1] + 1);
        } else {
            sum += a[perm[r--]];
            ans.push_back(perm[r + 1] + 1);
        }
    }

    cout << "yes\n";
    cout << ans << '\n';
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
statement.txt
======================
165. Basketball
time limit per test: 0.25 sec.
memory limit per test: 4096 KB
input: standard
output: standard



A head of a rich company decided that the company needs to have its own basketball team in the NBA. He thinks that a team will be successful only if the heights of players don't differ from 2000 mm too much. He took on a coach and this coach selected N players. The height of each player was in range of 1950..2050 millimeters and their average height was exactly 2000 mm. Moreover, the height of each player was integer number of micrometers (micrometer is 1e-6 meters).
Now the head of that company wants to see his new team. He wants to check, if his will is done, but he is going to check it in quite a strange way. The players stands in a line in some order, then the head selects two players and counts the summary height H of these two players and players who are between them, and the number of these players K. If this sum H differs from 2000*K mm more than on 10 cm, then he says that the team is bad. Of course, the coach doesn't want his team to be named "bad", and he don't know, what players will be selected by the head. So he asks you to help him.
Write a program that will find the order of players in line, so that the head of a company will not say the team is bad.

Input
On the first line of input there is one integer N (1<=N<=6000) --- the number of players selected into a team (these are the base players and substitutions and so on). Then N real numbers follow --- the heights of the players in meters.

Output
If the solution exists, write on the first line of the output one word "yes" (without quotes). On the second line write the order of players in which they must stand in line. The players are numbered starting from 1 in that order how their heights are written in input. If several solutions exist, output any. If there exist no solution, write on the first line of output only one word "no" (without quotes).

Sample test(s)

Input
6
1.95 1.95 1.96 2.04 2.05 2.05

Output
yes
1 6 2 5 3 4
Author:	Nizhny Novgorod city mathematic olympiad jury
Resource:	Nizhny Novgorod city mathematic olympiad, 8th form
Date:	21.12.2002








=================
p165.in1
======================
6
1.95 1.95 1.96 2.04 2.05 2.05

=================
