<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

498. Coins
Time limit per test: 0.75 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard

Andrew has just made a breakthrough in gambling: he has invented a way to make coins which have probability p of landing heads-up and 1 - p of landing tails-up when tossed, where p is some number between 0 and 1. He can't, however, control the number p itself, and creates coins with any p from 0 to 1 with equal probability. That is, the value of p is a random value uniformly distributed on . Andrew has generated two coins independently. One with probability p and another with probability q of landing heads-up. Random values p and q are both uniformly distributed on  and are independent. Of course, neither Andrew nor we know the numbers p and q, we can only try to guess them using our observations. The observations are the following: the first coin was tossed n1 times, and m1 of them landed heads-up. The second coin was tossed n2 times, and m2 of them landed heads-up. Your task is to compute the probability that p < q.
Input
The first line of the input file contains one integer T () — the number of test cases to solve. Each of the following T lines contains 4 integers each: n1, m1, n2, m2. 1 ≤ n1, n2 ≤ 1000, 0 ≤ m1, m2 ≤ 50, 0 ≤ m1 ≤ n1, 0 ≤ m2 ≤ n2.
Output
For each test case output one line with a floating-point number, the probability of p < q. Your answer will be considered correct if it is within 10-4 of the right answer.
Example(s)
sample input
sample output
4
2 1 4 3
8 4 16 8
2 0 6 1
2 0 2 1
0.7142857142
0.5000000000
0.5333333333
0.8000000000

<|response|>
## 1) Abridged problem statement (concise)

You observe results of tossing two different coins:

- Coin 1: unknown head probability \(p\), tossed \(n_1\) times, got \(m_1\) heads  
- Coin 2: unknown head probability \(q\), tossed \(n_2\) times, got \(m_2\) heads  

Before observing data, \(p\) and \(q\) are independent and uniformly random on \([0,1]\).

For each test case, compute the posterior probability:
\[
\Pr(p < q \mid \text{observations})
\]
Output as a floating-point number (absolute error \(\le 10^{-4}\)).

---

## 2) Key observations

1. **Uniform prior + binomial observations ⇒ Beta posterior**  
   Uniform\([0,1]\) is \(\text{Beta}(1,1)\). After observing \(m\) heads in \(n\) tosses:
   \[
   p \mid \text{data} \sim \text{Beta}(m+1,\, n-m+1)
   \]

2. **Independence remains after conditioning**  
   Since the two experiments are independent and priors are independent:
   \[
   (p \mid \text{coin1 data}) \perp (q \mid \text{coin2 data})
   \]

3. **We need \(\Pr(p<q)\) for two independent Beta variables**  
   This can be expressed as:
   \[
   \Pr(p<q)=\int_0^1 F_p(x)\, f_q(x)\, dx
   \]
   where \(F_p\) is the Beta CDF of coin 1, and \(f_q\) is the Beta PDF of coin 2.

4. **For integer parameters, Beta CDF becomes a binomial-tail polynomial**  
   For \(p\sim \text{Beta}(a,b)\) with integers \(a,b\):
   \[
   F_p(x)=I_x(a,b)=\sum_{j=a}^{a+b-1} \binom{a+b-1}{j} x^j(1-x)^{a+b-1-j}
   \]
   Here \(a=m_1+1\), \(b=n_1-m_1+1\), so \(a+b-1=n_1+1\).

5. **After swapping sum and integral, each integral is a Beta function**  
   Result becomes a single sum with Beta functions, computable in \(O(n_1)\).

6. **Avoid factorial overflow using a multiplicative recurrence**  
   Compute the first term carefully by products of ratios, then iterate:
   \[
   \frac{T(j+1)}{T(j)}=
   \frac{(n_1+1-j)(j+m_2+1)}{(j+1)(n_1+n_2-m_2-j+1)}
   \]
   This is stable with `long double` / `double`.

---

## 3) Full solution approach

### Step A: Posterior distributions
With uniform priors:
- Coin 1:
  \[
  p \mid data \sim \text{Beta}(a_1,b_1),\quad a_1=m_1+1,\; b_1=n_1-m_1+1
  \]
- Coin 2:
  \[
  q \mid data \sim \text{Beta}(a_2,b_2),\quad a_2=m_2+1,\; b_2=n_2-m_2+1
  \]

We need \(\Pr(p<q)\) where these two Beta variables are independent.

### Step B: Turn into one-dimensional integral
\[
\Pr(p<q)=\int_0^1 \left(\int_0^q f_p(p)\,dp\right) f_q(q)\,dq
= \int_0^1 F_p(q)\, f_q(q)\, dq
\]

### Step C: Use integer-parameter Beta CDF expansion
Since \(a_1,b_1\) are integers,
\[
F_p(q)=\sum_{j=m_1+1}^{n_1+1} \binom{n_1+1}{j} q^j(1-q)^{n_1+1-j}
\]

Plug into integral and swap sum/integral:
\[
\Pr(p<q)=\sum_{j=m_1+1}^{n_1+1} \binom{n_1+1}{j}
\int_0^1 q^j(1-q)^{n_1+1-j}\, f_q(q)\,dq
\]

### Step D: Each integral is a Beta function
Beta PDF of \(q\):
\[
f_q(q)=\frac{1}{B(m_2+1,n_2-m_2+1)} q^{m_2}(1-q)^{n_2-m_2}
\]

Combine exponents:
\[
\int_0^1 q^{j+m_2}(1-q)^{(n_1+1-j)+(n_2-m_2)}\,dq
= B(j+m_2+1,\; n_1+n_2-m_2-j+2)
\]

Therefore:
\[
\Pr(p<q)=\frac{1}{B(m_2+1,n_2-m_2+1)}
\sum_{j=m_1+1}^{n_1+1}\binom{n_1+1}{j}\,
B(j+m_2+1,\; n_1+n_2-m_2-j+2)
\]

Let
\[
T(j)=\binom{n_1+1}{j}\cdot
\frac{B(j+m_2+1,\; n_1+n_2-m_2-j+2)}{B(m_2+1,n_2-m_2+1)}
\]
Then answer is \(\sum_{j=m_1+1}^{n_1+1} T(j)\).

### Step E: Compute in \(O(n_1)\) via recurrence
Compute \(T(m_1+1)\) by multiplicative products (no factorials), then:
\[
T(j+1)=T(j)\cdot
\frac{(n_1+1-j)(j+m_2+1)}{(j+1)(n_1+n_2-m_2-j+1)}
\]
Sum all terms.

**Complexity:** \(O(n_1)\) per test case, with \(n_1\le 1000\).  
**Precision:** use `long double` (C++) / `float` (Python double) and print ~10 decimals.

---

## 4) C++ implementation (detailed comments)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
We compute:
  p|data ~ Beta(m1+1, n1-m1+1)
  q|data ~ Beta(m2+1, n2-m2+1)

Target:
  P(p < q)

Closed form reduces to:
  ans = sum_{j=m1+1}^{n1+1} T(j)
where
  T(j)= C(n1+1, j) * B(j+m2+1, n1+n2-m2-j+2) / B(m2+1, n2-m2+1)

We compute T(m1+1) by multiplicative products (no factorials),
then use the recurrence:
  T(j+1)/T(j) = (n1+1-j)(j+m2+1) / ((j+1)(n1+n2-m2-j+1))
*/

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        int n1, m1, n2, m2;
        cin >> n1 >> m1 >> n2 >> m2;

        // j starts at m1+1
        int j0 = m1 + 1;

        long double term = 1.0L;

        // 1) Build binomial coefficient C(n1+1, j0) multiplicatively:
        // C(N,K) = Π_{i=0}^{K-1} (N-i)/(i+1)
        // Here N=n1+1, K=j0=m1+1.
        for (int i = 0; i <= m1; i++) {
            term *= (long double)(n1 + 1 - i) / (long double)(i + 1);
        }

        // 2) Multiply by Beta ratio to transform into T(j0).
        //
        // term *= B(j0+m2+1, n1+n2-m2-j0+2) / B(m2+1, n2-m2+1)
        //
        // For integer arguments, expand ratio into safe products:
        // This matches the editorial/reference solution’s derivation.

        // Multiply by (m2+1)(m2+2)...(m2+m1+1)
        for (int i = 1; i <= m1 + 1; i++) {
            term *= (long double)(m2 + i);
        }

        // Multiply by (n2-m2+1)...(n2-m2 + (n1-m1))
        for (int i = 1; i <= n1 - m1; i++) {
            term *= (long double)(n2 - m2 + i);
        }

        // Divide by (n2+2)(n2+3)...(n2+n1+2)
        for (int i = 1; i <= n1 + 1; i++) {
            term /= (long double)(n2 + 1 + i);
        }

        // term is now T(j0)
        long double ans = term;

        // 3) Add remaining terms using recurrence up to j = n1+1
        // Loop j = j0..n1 produces next term T(j+1) and includes it.
        for (int j = j0; j <= n1; j++) {
            term *= (long double)(n1 + 1 - j) * (long double)(j + m2 + 1);
            term /= (long double)(j + 1) * (long double)(n1 + n2 - m2 - j + 1);
            ans += term;
        }

        cout << fixed << setprecision(10) << (double)ans << "\n";
    }
    return 0;
}
```

---

## 5) Python implementation (detailed comments)

```python
import sys

def solve_case(n1: int, m1: int, n2: int, m2: int) -> float:
    """
    Computes P(p < q | observations) where:
      p|data ~ Beta(m1+1, n1-m1+1)
      q|data ~ Beta(m2+1, n2-m2+1)

    Uses O(n1) summation with a stable recurrence between consecutive terms,
    avoiding factorials/Gamma functions.
    """
    j0 = m1 + 1

    term = 1.0

    # Build C(n1+1, j0) = C(n1+1, m1+1) multiplicatively
    for i in range(m1 + 1):  # i=0..m1
        term *= (n1 + 1 - i) / (i + 1)

    # Multiply by product expansion of:
    # B(j0+m2+1, n1+n2-m2-j0+2) / B(m2+1, n2-m2+1)

    # Multiply by (m2+1)(m2+2)...(m2+m1+1)
    for i in range(1, m1 + 2):
        term *= (m2 + i)

    # Multiply by (n2-m2+1)...(n2-m2 + (n1-m1))
    for i in range(1, n1 - m1 + 1):
        term *= (n2 - m2 + i)

    # Divide by (n2+2)(n2+3)...(n2+n1+2)
    for i in range(1, n1 + 2):
        term /= (n2 + 1 + i)

    ans = term

    # Recurrence:
    # T(j+1)/T(j) = (n1+1-j)(j+m2+1) / ((j+1)(n1+n2-m2-j+1))
    for j in range(j0, n1 + 1):  # j=j0..n1
        term *= (n1 + 1 - j) * (j + m2 + 1)
        term /= (j + 1) * (n1 + n2 - m2 - j + 1)
        ans += term

    return ans


def main() -> None:
    data = sys.stdin.read().strip().split()
    if not data:
        return
    t = int(data[0])
    idx = 1
    out = []
    for _ in range(t):
        n1 = int(data[idx]); m1 = int(data[idx+1])
        n2 = int(data[idx+2]); m2 = int(data[idx+3])
        idx += 4
        out.append(f"{solve_case(n1, m1, n2, m2):.10f}")
    sys.stdout.write("\n".join(out))


if __name__ == "__main__":
    main()
```

