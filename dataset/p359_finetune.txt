<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

359. Pointers
Time limit per test: 0.25 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



Pete learns dynamic pointers. In informatics tutorial he read about pointers in Pascal. Pointer is a special variable, containing address of some location in RAM. That location can contain value of a certain type. Pete declared four pointers pointing to memory cells with integer values in a following manner:

var a, b, c, d : ^integer;

Than he allocated memory with instruction new:

new(a); new(b); new(c); new(d);

and assigned zero values to memory cells, pointed by these pointers:

a^:=0; b^:=0; c^:=0; d^:=0;

Please note that a^ means accessing location of memory, pointed by the pointer. Notation a (without symbol "^") means accessing to the pointer itself. Pete uses four types of operators in his program:
pointer^:=constant, e.g. a^:=5. This operator puts value constant into the memory area pointed by pointer (compare fig. 1 and fig. 2);
pointer1^:=pointer2^, e.g. c^:=a^. This operator puts value from the memory area pointed by pointer2 to the memory area pointed by pointer1 (compare fig. 2 and fig. 3);
pointer1:=pointer2, e.g. b:=c. After execution of this operator pointer1 will point to the same memory area as pointer2 (compare fig. 3 and fig. 4);
writeln(pointer^), e.g. writeln(b^). Prints value from the memory area pointed by pointer^ (operator writeln(b^) will print 5 in our example).



Pete use digits 0 to 9 as constants, and letters a, b, c or d as pointer variables.

Input
The first line of the input file contains integer number N (1 ≤ N ≤ 30). N lines follow. Each of the following lines contains exactly one operator of one of four described types. Each operator finished with symbol ";" (semicolon). Input file contains no blanks. You may assume that before executing of this program pointers a, b, c, d were declared, the memory was allocated for them, and memory areas pointed by them were filled with 0.

Output
Print to the output file numbers that will be printed by Pete's program.

Example(s)
sample input
sample output
10 
writeln(a^); 
a^:=7; 
b^:=a^; 
writeln(b^); 
c:=a; 
c^:=5; 
writeln(a^); 
a:=b; 
writeln(a^); 
a^:=a^; 
0 
7 
5 
7 

sample input
sample output
3 
a:=b; 
b^:=3; 
writeln(a^); 
3

<|response|>
## 1) Abridged problem statement (concise)

You have four Pascal-like pointer variables `a, b, c, d`. Initially, each points to its own distinct integer memory cell, and all those cells contain `0`.

You are given `N (1..30)` statements (no spaces, each ends with `;`) of one of these types:

1. `x^:=k` where `k` is digit `0..9` (store constant into the cell pointed by `x`)
2. `x^:=y^` (copy value from cell pointed by `y` into cell pointed by `x`)
3. `x:=y` (make pointer `x` point to the same cell as `y`)
4. `writeln(x^)` (print the value in the cell pointed by `x`)

Simulate execution and output every printed number (each on its own line).

---

## 2) Key observations

- There are **two levels**:
  - **Pointers** (`a,b,c,d`) store *addresses* (which cell they point to).
  - **Cells** store integer values.
- Statement `x:=y` changes **where a pointer points** (aliasing).
- Statements with `^` (`x^:=...`, `writeln(x^)`) read/write the **cell value** that the pointer currently refers to.
- Because pointers can alias (point to the same cell), updating one cell may affect what another pointer “sees”.

So we must simulate:
- the current target cell for each pointer, and
- each cell’s current integer value.

---

## 3) Full solution approach

### Data model
Create 4 distinct “cells” initially holding `0`.  
Maintain a mapping `ptr['a'..'d'] -> cell`.

A “cell” can be:
- in C++: an `int*` pointing to dynamically allocated `int`, or
- in Python: a mutable object like a one-element list `[value]`.

### How to process statements
Each line has no spaces and ends with `;`.

1. Strip trailing `;`.
2. If line starts with `"writeln("`:
   - extract pointer letter inside `writeln(x^)`, output the value of the cell `ptr[x]`.
3. Else it must be an assignment containing `":="`:
   - split into `left` and `right`.
   - If `left` ends with `'^'`, it’s a **cell assignment**:
     - `x^:=k` → write constant into cell `ptr[x]`
     - `x^:=y^` → copy `value(ptr[y])` into `ptr[x]`
   - Otherwise it’s a **pointer assignment**:
     - `x:=y` → set `ptr[x] = ptr[y]` (aliasing)

### Complexity
`N ≤ 30`, so simulation is trivial:
- Time: `O(N)`
- Memory: `O(1)`

---

## 4) C++ implementation (detailed comments)

```cpp
#include <bits/stdc++.h>
using namespace std;

// Return reference to the C++ pointer variable (pa/pb/pc/pd) for letter 'a'..'d'
static int*& ptrRef(char name, int*& pa, int*& pb, int*& pc, int*& pd) {
    if (name == 'a') return pa;
    if (name == 'b') return pb;
    if (name == 'c') return pc;
    return pd; // name == 'd'
}

// Return the int* value (the target cell address) currently held by pointer 'a'..'d'
static int* ptrVal(char name, int* pa, int* pb, int* pc, int* pd) {
    if (name == 'a') return pa;
    if (name == 'b') return pb;
    if (name == 'c') return pc;
    return pd; // name == 'd'
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;

    // Initially: each pointer points to its own distinct cell with value 0.
    int* pa = new int(0);
    int* pb = new int(0);
    int* pc = new int(0);
    int* pd = new int(0);

    for (int i = 0; i < N; i++) {
        string s;
        cin >> s;

        // Remove trailing ';'
        if (!s.empty() && s.back() == ';') s.pop_back();

        // Case: writeln(x^)
        if (s.rfind("writeln(", 0) == 0) { // starts with "writeln("
            // s looks like: writeln(a^)
            // Extract the pointer letter: it's right after '('
            char x = s[8]; // "writeln(" has length 8
            int* cell = ptrVal(x, pa, pb, pc, pd);
            cout << *cell << "\n";
            continue;
        }

        // Otherwise it's an assignment containing ":="
        auto pos = s.find(":=");
        string left = s.substr(0, pos);
        string right = s.substr(pos + 2);

        // If left ends with '^', we assign to the cell value: x^ := ...
        if (!left.empty() && left.back() == '^') {
            char x = left[0];             // left is "x^"
            int* destCell = ptrVal(x, pa, pb, pc, pd);

            // Right side can be a digit "0".."9" or "y^"
            if (right.size() == 1 && isdigit(right[0])) {
                *destCell = right[0] - '0'; // store constant into *destCell
            } else {
                char y = right[0];          // right is "y^"
                int* srcCell = ptrVal(y, pa, pb, pc, pd);
                *destCell = *srcCell;       // copy value between cells
            }
        } else {
            // Pointer assignment: x := y (alias pointers)
            char x = left[0];   // "x"
            char y = right[0];  // "y"
            int* target = ptrVal(y, pa, pb, pc, pd);

            // Make pointer x point to the same cell as y
            ptrRef(x, pa, pb, pc, pd) = target;
        }
    }

    // (No need to free memory in contest setting; program ends immediately.)
    return 0;
}
```

---

## 5) Python implementation (detailed comments)

```python
import sys

def solve() -> None:
    data = sys.stdin.read().strip().split()
    n = int(data[0])
    lines = data[1:1 + n]

    # Each memory cell is represented by a one-element list [value].
    # Lists are mutable and can be shared => perfect for aliasing pointers.
    cell_a = [0]
    cell_b = [0]
    cell_c = [0]
    cell_d = [0]

    # ptr maps pointer variable name to the cell object it points to.
    ptr = {
        'a': cell_a,
        'b': cell_b,
        'c': cell_c,
        'd': cell_d,
    }

    out = []

    for s in lines:
        # Remove trailing ';'
        if s.endswith(';'):
            s = s[:-1]

        # Case: writeln(x^)
        if s.startswith("writeln("):
            # s is like "writeln(a^)"
            x = s[len("writeln(")]  # the letter right after '('
            out.append(str(ptr[x][0]))
            continue

        # Otherwise: assignment with ':='
        left, right = s.split(":=")

        if left.endswith('^'):
            # Cell assignment: x^ := ...
            x = left[0]

            if len(right) == 1 and right.isdigit():
                # x^ := k
                ptr[x][0] = int(right)
            else:
                # x^ := y^
                y = right[0]
                ptr[x][0] = ptr[y][0]
        else:
            # Pointer assignment: x := y (alias)
            x = left[0]
            y = right[0]
            ptr[x] = ptr[y]

    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    solve()
```

These implementations directly simulate pointer aliasing and dereferenced reads/writes exactly as described, producing the correct output for all `writeln` statements.