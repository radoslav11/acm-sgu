<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

362. Robot-Annihilator
Time limit per test: 0.25 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



Old factory in Berland is in accident condition. Danger of its demolition forced government to shut down the factory, destroy it completely, and build new modern factory in this area. For the safety of people destruction of the factory will be performed by specially constructed . On the map the factory has the shape of rectangle N x M, i. e. N rows of M buildings. Robot-annihilator has infinite amount of bombs. Each bomb completely destroys exactly one building. The robot runs using very simple algorithm: if the robot located at building (i, j) (i. e. building in row i in column j), it puts the bomb in this building and goes to the next building. As soon as robot leaves building (i, j), the bomb in that building explodes. Robot selects next building from the four neighbors: (i + 1, j), (i, j - 1), (i - 1, j), (i, j + 1); some of these buildings may not exist, because robot may stay at the boundary of factory. Robot chooses first existed non-exploded building out of that list. After that, the same procedure repeats. If all neighboring buildings are destroyed, robot doesn't move and explodes with the building. Task of your program is to make full report about robot's actions, given its initial position (is, js).

Input
The first line of the input file contains two integer numbers N, M (1 ≤ N ≤ 10; 1 ≤ M ≤ 10). The second line of the input file contains coordinates (is, js) of the initial robot position (1 ≤ is ≤ N, 1 ≤ js ≤ M).

Output
Print sequence of robot's moves. Each move describes by one capital Latin letter: "D" (moving down), "L" (left), "U" (up), "R" (right). If the robot is located at the point (i, j), down direction corresponds to the point (i + 1, j), left - (i, j - 1), up - (i - 1, j), right - (i, j + 1). There should be no extra spaces or characters, so the output file contains only characters "D", "L", "U" and "R".

Example(s)
sample input
sample output
3 3
1 2
DDLUU

<|response|>
1) Abridged problem statement
- You have an N×M grid (1 ≤ N, M ≤ 10). The robot starts at cell (is, js), 1-based.
- At each step, the robot destroys its current cell and tries to move to the first neighbor (in this exact order): Down, Left, Up, Right.
- It moves to the first neighbor that exists and is not yet destroyed. If none exist, it stops.
- Output the sequence of moves as a string of letters D, L, U, R.

2) Key observations
- The robot never revisits a destroyed cell, so it visits each cell at most once.
- The move order is fixed (DLUR), making the path deterministic.
- A direct simulation suffices: mark visited cells and always try neighbors in DLUR order.
- The process takes at most N⋅M iterations and checks up to 4 neighbors per step, so it is trivial within the constraints.

3) Full solution approach
- Maintain a 2D boolean array visited (1-based) to mark destroyed cells.
- Set the current position to (is, js).
- Repeat:
  - Mark visited[i][j] = true.
  - In order D, L, U, R, check the neighbor (i+1,j), (i,j−1), (i−1,j), (i,j+1).
  - If a neighbor is in bounds and not visited, append its direction letter to the answer, move to it, and continue.
  - If none qualifies, stop.
- Print the collected move string.
- Correctness: This exactly simulates the robot’s rule. Since each cell is visited at most once, the loop terminates after at most N⋅M steps.
- Complexity: Time O(N⋅M), Space O(N⋅M).

4) C++ implementation with detailed comments
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M, is, js;
    if (!(cin >> N >> M)) return 0;
    cin >> is >> js;

    // visited[i][j] == true means cell (i, j) is already destroyed.
    // Use 1-based indexing for simplicity.
    vector<vector<char>> visited(N + 1, vector<char>(M + 1, 0));

    // Current position
    int i = is, j = js;

    // Record the moves
    string result;

    // Direction vectors and corresponding letters in fixed order: D, L, U, R
    const int di[4] = {1, 0, -1, 0};
    const int dj[4] = {0, -1, 0, 1};
    const char letter[4] = {'D', 'L', 'U', 'R'};

    while (true) {
        // The current cell will explode as we leave it: mark it visited now
        visited[i][j] = 1;

        bool moved = false;

        // Try to move in DLUR order
        for (int k = 0; k < 4; k++) {
            int ni = i + di[k];
            int nj = j + dj[k];
            // Check bounds and that the next cell hasn't been destroyed yet
            if (1 <= ni && ni <= N && 1 <= nj && nj <= M && !visited[ni][nj]) {
                result.push_back(letter[k]); // record the move
                i = ni;                      // move to the neighbor
                j = nj;
                moved = true;
                break;
            }
        }

        // If no movement is possible, we stop
        if (!moved) break;
    }

    cout << result;
    return 0;
}
```

5) Python implementation with detailed comments
```python
import sys

def main():
    data = list(map(int, sys.stdin.read().strip().split()))
    if len(data) < 4:
        return
    N, M, is_, js_ = data[0], data[1], data[2], data[3]

    # visited[i][j] indicates whether cell (i, j) has been destroyed.
    # Use 1-based indexing for clarity.
    visited = [[False] * (M + 1) for _ in range(N + 1)]

    # Current position
    i, j = is_, js_

    # Direction vectors and letters in fixed order: D, L, U, R
    di = [1, 0, -1, 0]
    dj = [0, -1, 0, 1]
    letters = ['D', 'L', 'U', 'R']

    res = []

    while True:
        # Mark current cell as destroyed (it explodes when leaving)
        visited[i][j] = True

        moved = False
        # Try to move in DLUR order
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            if 1 <= ni <= N and 1 <= nj <= M and not visited[ni][nj]:
                res.append(letters[k])
                i, j = ni, nj
                moved = True
                break

        if not moved:
            break

    sys.stdout.write(''.join(res))

if __name__ == "__main__":
    main()
```