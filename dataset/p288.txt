## 1) Abridged problem statement

Given **N (1 ≤ N ≤ 2005)** players in a **round-robin** tournament, every pair of players must play **exactly once**. Split all matches into **tours/rounds** so that **no player plays more than one match in the same tour**, and the **number of tours is minimal**.

Output:
- First line: minimal number of tours **T**.
- Then an **N×N** matrix `A` where `A[i][j]` is the tour number (1..T) of the match between players `i` and `j`, `A[i][i]=0`, and `A[i][j]=A[j][i]`.

Any optimal schedule is accepted.

---

## 2) Detailed editorial (how the solution works)

This is exactly the classic problem of **edge-coloring the complete graph** \(K_N\) with the minimum number of colors, where:
- vertices = players,
- edges = matches,
- colors = tours,
- constraint “a player plays at most once per tour” means each color class must be a **matching**.

### Key facts (lower bound and optimal value)

- In one tour, each player can play at most one match.
- So a single tour can contain at most \(\lfloor N/2 \rfloor\) matches.
- Total matches are \(\binom{N}{2}\).

Also, for any vertex, its degree in \(K_N\) is \(N-1\). Since all incident edges must have distinct colors (a player cannot play twice in one tour), we need at least \(N-1\) colors.

Therefore:
- If **N is even**, it’s possible to do it in **T = N − 1** tours (this is optimal).
- If **N is odd**, it’s possible to do it in **T = N** tours (also optimal), because in each tour one player must sit out (a perfect matching cannot exist in odd-sized complete graph).

This matches a known theorem:
- \(\chi'(K_N) = N-1\) if \(N\) even, else \(N\).

### Constructing an optimal schedule (circle / round-robin method)

We explicitly build a **1-factorization** (decomposition into perfect matchings) for even case, and a near-perfect decomposition for odd case.

#### Case A: N is odd (T = N)
Arrange players 0..N-1 around a “table” (a circle idea). For each round `r`:
- Pair people symmetric around the table:
  - for `i = 1..(N-1)/2`, pair:
    - `p1 = (i - r) mod N`
    - `p2 = (N - i - r) mod N`
- Player at “head seat” is left out implicitly (no pairing uses it).

Rotating by `r` ensures every pair appears exactly once across the N rounds.

#### Case B: N is even (T = N − 1)
Use only the first `N-1` players (0..N-2) around the table (so table size is odd, which makes the rotation property work cleanly), and keep player `N-1` as the “standing” player.
For each round `r`:
1) Standing player `N-1` plays the current “head” person:
   - `head = (table_size - r) mod table_size`
   - pair `head` with `N-1`
2) Among seated players, pair symmetric positions as in the odd case on the table of size `N-1`:
   - for `i = 1..(table_size-1)/2`, pair
     - `p1 = (i - r) mod table_size`
     - `p2 = (table_size - i - r) mod table_size`

This creates `N-1` rounds, each round is a perfect matching of all N players, and every pair appears exactly once.

### Output matrix
We fill `schedule[i][j]` with the round index (1-based) whenever players i and j are paired in that round; diagonal remains 0.

Complexity:
- Filling pairings per round is \(O(N^2)\).
- Outputting the matrix is also \(O(N^2)\).
- Fits for N ≤ 2005.

---

## 3) Provided C++ solution with detailed line-by-line comments

```cpp
#include <bits/stdc++.h>          // Includes almost all standard headers (competitive programming shortcut)

using namespace std;

// Overload operator<< for pairs (not essential for this problem, but kept as template utility)
template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

// Overload operator>> for pairs (utility)
template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

// Overload operator>> for vectors: reads all elements sequentially (utility)
template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {            // iterate by reference to assign
        in >> x;
    }
    return in;
};

// Overload operator<< for vectors: prints all elements separated by spaces (utility)
template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {             // prints each element
        out << x << ' ';
    }
    return out;
};

int n;                           // number of participants

void read() { cin >> n; }        // read input N

void solve() {
    // Constructs an optimal round-robin schedule using the classic circle method.
    // For odd N -> N rounds; for even N -> N-1 rounds.

    if (n == 1) {                // Special case: only one player, no matches
        cout << "0\n0\n";        // T=0, and matrix is [0]
        return;
    }

    // Minimal number of rounds:
    // even n -> n-1; odd n -> n
    int num_rounds = (n % 2 == 0) ? n - 1 : n;
    cout << num_rounds << '\n';

    // We will arrange players on a "table" used for rotation.
    // If n is odd, table has n players.
    // If n is even, we place only n-1 players on the table, and keep player n-1 as "standing".
    int table_size = (n % 2 == 0) ? n - 1 : n;

    // schedule[i][j] will store the round number (1..T) when i plays j; diagonal remains 0.
    vector<vector<int>> schedule(n, vector<int>(n, 0));

    // Iterate through each round r
    for(int r = 0; r < num_rounds; r++) {

        // If n is even, we also schedule the match between the standing player (n-1)
        // and the "head" person in the current rotation.
        if(n % 2 == 0) {
            int head_person = (table_size - r) % table_size; // who sits at the head this round
            schedule[head_person][n - 1] = r + 1;            // round numbers are 1-based
            schedule[n - 1][head_person] = r + 1;            // symmetric matrix
        }

        // Pair people seated on the table symmetrically.
        // There are (table_size-1)/2 such pairs each round.
        for(int i = 1; i <= (table_size - 1) / 2; i++) {

            // Compute the two paired players after rotation by r.
            // We use modular arithmetic; the extra "+ table_size" and "% table_size"
            // ensures non-negative mod for C++.
            int p1 = ((i - r) % table_size + table_size) % table_size;
            int p2 =
                ((table_size - i - r) % table_size + table_size) % table_size;

            // Assign this round to their match (both directions).
            schedule[p1][p2] = r + 1;
            schedule[p2][p1] = r + 1;
        }
    }

    // Output the schedule matrix
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(j > 0) {          // spacing between numbers
                cout << ' ';
            }
            cout << schedule[i][j];
        }
        cout << '\n';
    }
}

int main() {
    ios_base::sync_with_stdio(false); // fast I/O
    cin.tie(nullptr);                 // untie cin/cout for speed

    int T = 1;                        // single test case
    // cin >> T;                      // (disabled) would read multiple test cases
    for(int test = 1; test <= T; test++) {
        read();                       // read N
        // cout << "Case #" << test << ": "; // (disabled) format for multi-case problems
        solve();                      // produce schedule
    }

    return 0;
}
```

---

## 4) Python solution (same algorithm, detailed comments)

```python
import sys

def main():
    data = sys.stdin.read().strip().split()
    n = int(data[0])

    # Special case: N=1, no matches and thus 0 rounds; matrix is just [0].
    if n == 1:
        sys.stdout.write("0\n0\n")
        return

    # Minimal number of tours for complete graph K_n edge-coloring:
    # even n -> n-1, odd n -> n
    num_rounds = n - 1 if (n % 2 == 0) else n
    out_lines = [str(num_rounds)]

    # Size of the rotating "table":
    # odd n -> table has all n players
    # even n -> table has n-1 players, last player is "standing" and pairs with head each round
    table_size = n - 1 if (n % 2 == 0) else n

    # Initialize NxN schedule matrix with zeros
    schedule = [[0] * n for _ in range(n)]

    # For each round r (0-based internally; store r+1 in the matrix)
    for r in range(num_rounds):

        # Even case: pair the standing player (n-1) with the current "head" of the table
        if n % 2 == 0:
            head = (table_size - r) % table_size
            schedule[head][n - 1] = r + 1
            schedule[n - 1][head] = r + 1

        # Pair symmetric players on the table
        # There are (table_size-1)//2 pairs among table_size players each round
        half = (table_size - 1) // 2
        for i in range(1, half + 1):
            # Compute indices after rotation by r; Python % is already non-negative
            p1 = (i - r) % table_size
            p2 = (table_size - i - r) % table_size

            schedule[p1][p2] = r + 1
            schedule[p2][p1] = r + 1

    # Output the matrix with spaces
    for i in range(n):
        out_lines.append(" ".join(map(str, schedule[i])))

    sys.stdout.write("\n".join(out_lines) + "\n")

if __name__ == "__main__":
    main()
```

---

## 5) Compressed editorial

We need a round-robin schedule with minimum tours where each player plays at most once per tour. This is an edge-coloring of \(K_N\): minimum tours is \(N-1\) if \(N\) even, else \(N\).

Construction (circle method):
- If \(N\) is odd: for rounds \(r=0..N-1\), pair \((i-r) \bmod N\) with \((N-i-r)\bmod N\) for \(i=1..(N-1)/2\).
- If \(N\) is even: use a table of size \(N-1\) (players 0..N-2) and keep player \(N-1\) standing. Each round pairs standing player with head \((N-1-r)\bmod(N-1)\), and also pairs symmetric seated players as above on modulo \(N-1\).

Fill an \(N\times N\) matrix with round numbers (1-based), diagonal 0. Complexity \(O(N^2)\).