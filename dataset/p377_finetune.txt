<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

377. The Lesson of Physical Culture
Time limit per test: 0.75 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



In one of the schools in Berland, the teacher of physical culture got cold during the morning excercises. After some discussion the pedagogical assembly has made a decision that the next lesson of physical culture will be driven by the teacher of mathematics Gleb Antonovich, who does not care whom, where and when he should talk about mathematics.

After coming to the gym, Gleb Antonovich noticed that the floor is the N x M grid of unit squares. The first exercise of the lesson was to stand in some cells in such a way that any student is in the center of some cell, there is no more than one student in any cell, and there are no more than two students in any 2x 2 square to prevent discomfort. But because of the limited space, it was required that each square 2x 2 must contain two students.

Gleb Antonovich is now interested, how many different ways of such standing exist if all students are equivalent. Your task is to find the number.

Input
The first line contains two integers N and M (2 ≤ N, M≤ 1000).

Output
Output the number of ways without any leading zeros or spaces. Note that the number of students standing on the floor is not fixed.

Example(s)
sample input
sample output
2 2
6

<|response|>
## 1) Abridged problem statement (concise)

Given an \(N \times M\) grid (\(2 \le N, M \le 1000\)), choose some cells to place indistinguishable students (at most one per cell) such that **every** \(2 \times 2\) sub-square contains **exactly two** students.  
Compute the number of valid placements and print it as an exact integer (can be very large).

---

## 2) Key observations

1. Each cell is binary: occupied (1) or empty (0).  
   The constraint for every \(2\times2\) block
   \[
   \begin{matrix}
   a & b\\
   c & d
   \end{matrix}
   \qquad\Rightarrow\qquad a+b+c+d = 2
   \]
   i.e., **exactly two** ones in every \(2\times2\).

2. Consider two adjacent rows \(i\) and \(i+1\). For each column \(j\), look at the vertical pair:
   \[
   v_j = (x_{i,j}, x_{i+1,j}) \in \{00,01,10,11\}
   \]
   Now take two adjacent columns \(j, j+1\). The \(2\times2\) constraint becomes:
   \[
   \text{(number of ones in } v_j) + \text{(number of ones in } v_{j+1}) = 2
   \]
   So if \(v_j\) has 0 ones, then \(v_{j+1}\) must have 2 ones;  
   if \(v_j\) has 1 one, then \(v_{j+1}\) must also have 1 one;  
   if \(v_j\) has 2 ones, then \(v_{j+1}\) must have 0 ones.

3. This forces the whole grid into one of two global “families”:
   - **Row-stripe family:** every column has exactly one student in each adjacent row-pair, meaning for all \(j\), \(v_j\in\{01,10\}\). Then each row can be chosen independently → \(2^N\) patterns.
   - **Column-stripe family:** every row-pair alternates between \(00\) and \(11\) in columns (and the same happens consistently) → \(2^M\) patterns.

4. The overlap of these two families is exactly the **two chessboard colorings**:
   - all black squares occupied, or
   - all white squares occupied.  
   Hence use inclusion–exclusion:
   \[
   \text{answer} = 2^N + 2^M - 2
   \]

5. The number is huge (up to \(2^{1000}\)), so we need big integers (C++: `boost::multiprecision::cpp_int`, Python: built-in `int`).

---

## 3) Full solution approach

1. Read \(N, M\).
2. Compute big integers:
   - \(A = 2^N\)
   - \(B = 2^M\)
3. Answer is:
   \[
   A + B - 2
   \]
4. Output it in decimal.

**Complexity:** \(O(\max(N,M))\) bit-operations to shift/build powers; easily fits limits.

---

## 4) C++ implementation (detailed comments)

```cpp
#include <bits/stdc++.h>
#include <boost/multiprecision/cpp_int.hpp>

using namespace std;
using boost::multiprecision::cpp_int;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    cin >> N >> M;

    // cpp_int is an arbitrary-precision integer.
    // Compute 2^N and 2^M using left shifts:
    // (cpp_int(1) << k) equals 2^k exactly.
    cpp_int two_pow_N = cpp_int(1) << N;
    cpp_int two_pow_M = cpp_int(1) << M;

    // Inclusion–exclusion:
    // Total = row-family + column-family - overlap
    // overlap is exactly the 2 chessboard patterns.
    cpp_int ans = two_pow_N + two_pow_M - 2;

    cout << ans << "\n";
    return 0;
}
```

---

## 5) Python implementation (detailed comments)

```python
import sys

def main() -> None:
    data = sys.stdin.read().strip().split()
    n = int(data[0])
    m = int(data[1])

    # Python int is arbitrary precision.
    # 1 << k equals 2^k.
    ans = (1 << n) + (1 << m) - 2

    sys.stdout.write(str(ans))

if __name__ == "__main__":
    main()
```

