<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

294. He's Circles
time limit per test: 1.75 sec.
memory limit per test: 65536 KB
input: standard
output: standard



He wrote n letters "X" and "E" in a circle. He thought that there were 2n possibilities to do it, because each letter may be either "X" or "E". But Qc noticed that some different sequences of letters can be transformed one to another with a circular shift (thus representing actually the same circular string).
For example, strings "XXE"-"XEX"-"EXX" are actually the same.
Qc wants to know how many different circular strings of n letters exist. Help him to find that out.


Input
The input file contains a single integer 1 <= n <= 200000.

Output
Output a single integer --- the number circular strings of length n.

Sample test(s)

Input
Test #1
3

Test #2
4

Output
Test #1
4

Test #2
6
Author:	Anton Golubev, Petrazavodsk SU
Resource:	Anton Golubev (Hedgehog)'s Contest #2 from Annual Summer Russian Teams Meeting in Petrozavodsk State University
Date:	August 26, 2005

<|response|>
1) Abridged problem statement
- You place n letters around a circle, each letter is either X or E.
- Two strings are considered the same if one can be rotated to obtain the other (rotations only, no reflections).
- Given 1 ≤ n ≤ 200000, compute the number of distinct circular strings (binary necklaces) of length n.

2) Key observations
- This is counting orbits under the cyclic group of rotations C_n.
- Burnside’s lemma: number of orbits = average number of strings fixed by each rotation.
- A rotation by k positions (0 ≤ k < n) fixes exactly 2^{gcd(n, k)} strings, because positions split into gcd(n, k) cycles, and each cycle must be constant.
- Burnside sum:
  Answer = (1/n) * sum_{k=0}^{n-1} 2^{gcd(n, k)}.
- Grouping terms by gcd with Euler’s totient φ:
  The number of k with gcd(n, k) = d (for d | n) equals φ(n/d).
  Equivalent closed forms:
  Answer = (1/n) * sum_{d | n} φ(n/d) * 2^d = (1/n) * sum_{d | n} φ(d) * 2^{n/d}.
- Big integers are required. In C++ use boost::multiprecision::cpp_int; Python ints are arbitrary precision.

3) Full solution approach
- Use the divisor/totient form to minimize big-integer operations:
  Answer = (1/n) * sum_{d | n} φ(d) * 2^{n/d}.
- Steps:
  1) Factor n by trial division up to sqrt(n) to get its distinct prime divisors.
  2) Enumerate all divisors d of n in O(sqrt(n)).
  3) For each divisor d, compute φ(d) using only the primes of n:
     - φ(d) = d × Π over primes p dividing d of (1 − 1/p).
  4) For each d, compute term = φ(d) × 2^{n/d}. Compute 2^{n/d} as a left bit-shift of 1 to avoid slow exponentiation.
  5) Sum all terms using big integers, divide the sum by n, and output.

- Complexity:
  - Factoring n: O(sqrt(n)).
  - Enumerating divisors: O(sqrt(n)).
  - For each divisor, computing φ(d) checks only the few primes dividing n.
  - Total big-integer additions is about τ(n) (the number of divisors), which is small (< ~1500 here), making it very fast.

4) C++ implementation with detailed comments
```cpp
// Problem: Count binary necklaces of length n (rotations only).
// Formula used: answer = (1/n) * sum_{d | n} phi(d) * 2^(n/d)
//
// We use boost::multiprecision::cpp_int for big integers.

#include <bits/stdc++.h>
#include <boost/multiprecision/cpp_int.hpp>

using namespace std;
using boost::multiprecision::cpp_int;

// Return the distinct prime factors of x by trial division.
static vector<int> distinct_prime_factors(int x) {
    vector<int> primes;
    int n = x;

    if (n % 2 == 0) {
        primes.push_back(2);
        while (n % 2 == 0) n /= 2;
    }
    for (int p = 3; 1LL * p * p <= n; p += 2) {
        if (n % p == 0) {
            primes.push_back(p);
            while (n % p == 0) n /= p;
        }
    }
    if (n > 1) primes.push_back(n);

    return primes;
}

// Enumerate all positive divisors of n.
static vector<int> divisors_of(int n) {
    vector<int> divs;
    for (int i = 1; 1LL * i * i <= n; ++i) {
        if (n % i == 0) {
            divs.push_back(i);
            if (i != n / i) divs.push_back(n / i);
        }
    }
    return divs;
}

// Compute phi(d) for d | n using the known primes of n.
static long long phi_of_divisor(long long d, const vector<int>& primes_of_n) {
    long long phi = d;
    long long m = d;
    for (int p : primes_of_n) {
        if (m % p == 0) {
            phi = phi / p * (p - 1);
            while (m % p == 0) m /= p;
        }
    }
    // m should be 1 since d | n and primes_of_n contains all prime factors of n.
    return phi;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin >> n)) return 0;

    // Factor n and enumerate divisors.
    vector<int> primes = distinct_prime_factors(n);
    vector<int> divs = divisors_of(n);

    cpp_int sum = 0;

    // Sum phi(d) * 2^(n/d) over all divisors d of n.
    for (int d : divs) {
        long long phi_d = phi_of_divisor(d, primes);
        int exponent = n / d;

        // 2^(n/d) as a bit shift on big integer: 1 << exponent
        cpp_int pow2 = cpp_int(1) << exponent;

        sum += cpp_int(phi_d) * pow2;
    }

    cpp_int answer = sum / n;  // Burnside’s averaging
    cout << answer << '\n';
    return 0;
}
```

5) Python implementation with detailed comments
```python
# Problem: Count binary necklaces (rotations only).
# Formula used: answer = (1/n) * sum_{d | n} phi(d) * 2^(n/d)

import sys
from math import isqrt

# On some Python versions printing very large ints may enforce a limit.
if hasattr(sys, "set_int_max_str_digits"):
    try:
        sys.set_int_max_str_digits(10**7)
    except Exception:
        pass

def distinct_prime_factors(x: int) -> list[int]:
    """Return distinct prime divisors of x via trial division."""
    primes = []
    n = x
    if n % 2 == 0:
        primes.append(2)
        while n % 2 == 0:
            n //= 2
    p = 3
    while p * p <= n:
        if n % p == 0:
            primes.append(p)
            while n % p == 0:
                n //= p
        p += 2
    if n > 1:
        primes.append(n)
    return primes

def divisors_of(n: int) -> list[int]:
    """Enumerate all positive divisors of n."""
    divs = []
    r = isqrt(n)
    for i in range(1, r + 1):
        if n % i == 0:
            divs.append(i)
            j = n // i
            if j != i:
                divs.append(j)
    return divs

def phi_of_divisor(d: int, primes_of_n: list[int]) -> int:
    """Compute Euler's totient of d (given that d | n) using primes of n."""
    phi = d
    m = d
    for p in primes_of_n:
        if m % p == 0:
            phi = phi // p * (p - 1)
            while m % p == 0:
                m //= p
    return phi

def solve() -> None:
    data = sys.stdin.read().strip().split()
    if not data:
        return
    n = int(data[0])

    primes = distinct_prime_factors(n)
    divs = divisors_of(n)

    total = 0
    for d in divs:
        phi_d = phi_of_divisor(d, primes)
        exponent = n // d
        # 2^(n/d) efficiently as a left shift
        total += phi_d * (1 << exponent)

    ans = total // n
    print(ans)

if __name__ == "__main__":
    solve()
```

Notes
- Both programs implement the divisor-grouped Burnside formula, minimizing the number of big-integer additions.
- Sample checks:
  - n = 3 → 4
  - n = 4 → 6
- The approach runs comfortably fast for n up to 200000.