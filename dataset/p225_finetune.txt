<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

225. Little Knights
time limit per test: 1 sec.
memory limit per test: 65536 KB
input: standard
output: standard




Oh no, here it comes again
Can't remember when we came so close to love before
Hold on, good things never last
Nothing's in the past, it always seems to come again
Again and again and again

...

Bloodied angels fast descending
Moving on a never-bending light
Phantom figures free forever
Out of shadows, shining ever-bright

Neon Knights!

Black Sabbath, "Neon Knights"


The knight is the piece in the game of chess. The knight moves the following way: first he moves 2 squares in horizontal or vertical direction and then 1 square in the perpendicular direction. Figures on the way of knight do not interfere with its movement. Two knights are in the attacking position if they can move to each other's cells.

Input

The input file contains two integers n (1 ≤ n ≤ 10) and k (0 ≤ k ≤ n2).

Output

Print a line containing the total number of ways one can put k knights on a chessboard of size n × n so that no two of them are in the attacking positions.

Sample test(s)

Input
Test #1

3 2

Test #2

4 4

Output
Test #1

28

Test #2

412
Author:	Andrew Stankevich
Resource:	Little Chess Pieces Series, SPb IFMO 2003-2004 Authumn Training Sessions
Date:	2003-10-11

<|response|>
1. Abridged problem statement  
Given an n×n chessboard (1≤n≤10) and an integer k (0≤k≤n²), count the number of ways to place exactly k knights so that no two knights attack each other. A knight’s attack moves are the usual chess knight moves.

2. Key observations  
- A knight placed at (r,c) can only attack cells in the previous two rows (r−1 or r−2).  
- When we scan the board in row-major order (cell by cell from top-left to bottom-right), at each step we only need to remember which of the last two rows—and the part of the current row to the left—are occupied by knights.  
- We can encode that “window” of cells as a bitmask of width W=2n+1.  Each new cell corresponds to the least significant bit (LSB); at each step we shift the mask left by 1 and drop bits that fall out of the 2n+1 window.  
- Let dp[pos_parity][mask][used] = number of ways after processing pos cells (pos_parity = pos&1), with the current sliding mask = mask, and having placed exactly used knights so far.  
- Transition for the next cell:  
  • shift = (mask<<1)&((1<<W)−1)  
  • Option A: do not place a knight → dp[nxt][shift][used] += dp[now][mask][used]  
  • Option B: if used<k and none of the bits in mask corresponding to attacking offsets is set → place a knight → dp[nxt][shift|1][used+1] += dp[now][mask][used]  
- The bit positions for the four “attacking” moves are precomputed by a helper get_bit_position(r,c,dr,dc).  
- This DP runs in O(n²·2^W·k).  For n up to 7, W≤15 so 2^W≤32768 and it is fast enough.  For n=8,9,10 we precompute the answers offline and hard-code them.

3. Full solution approach  
a. Read n,k.  
b. If n≥8, output from a precomputed array pre[n][k] in O(1).  
c. Otherwise:  
   1. Let W=2n+1, M=1<<W.  
   2. Initialize a 2×M×(k+1) DP array dp, set dp[0][0][0]=1.  
   3. For pos from 0 to n*n−1:  
      - now=pos&1, nxt=now^1, r=pos/n, c=pos%n.  
      - zero out dp[nxt] layer.  
      - For each mask in [0..M−1], each used in [0..k] with ways=dp[now][mask][used]>0:  
         * shifted=(mask<<1)&(M−1)  
         * dp[nxt][shifted][used] += ways  
         * If used<k and for all four knight moves (dr,dc) bit at get_bit_position(r,c,dr,dc) is 0 in mask:  
             dp[nxt][shifted|1][used+1] += ways  
   4. At the end pos=n*n, sum dp[(n*n)&1][mask][k] over all mask to get the answer.  

4. C++ implementation with detailed comments  
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

// Four knight-move offsets that land in previous rows when we scan row-major
static const vector<pair<int,int>> knight_moves = {
    {-2,-1}, {-2,1}, {-1,-2}, {-1,2}
};

// Precomputed answers for n=8,9,10 (indexed by k from 0 to n*n)
static const vector<int64> pre8 = {
    1,64,1848,32084,376560,3184708,20202298,98796304,
    379978716,1167053680,2897726604,5876860140,9825415557,
    13660238780,15932672964,15737653004,13304668385,9742722088,
    6260518246,3574590840,1830733371,844203844,349524138,
    128874944,41833846,11792736,2840224,572432,93840,12004,
    1122,68,2
};
static const vector<int64> pre9 = {
    1,81,3016,68796,1080942,12472084,110018552,
    762775440,4241252429,19206532478,71707869632,
    222946143752,582155146204,1286247689414,2421159140764,
    3908273840366,5446391581062,6599640204257,7010436668992,
    6589213734278,5537849837497,4207779106033,2920161348852,
    1865346129716,1101125592067,600730512987,302041066250,
    139345014744,58692638521,22451454400,7755194754,
    2403337080,663103709,161373907,34237130,6238414,957145,
    120334,11914,872,42,1
};
static const vector<int64> pre10 = {
    1,100,4662,135040,2732909,41199404,481719518,
    4491423916,34075586550,213628255072,1120204619108,
    4961681221524,18715619717199,60541371615660,168976761361446,
    409191804533576,864172675710439,1599730843649564,
    2609262108838924,3770687313420780,4857550050070531,
    5616928666465104,5874943705896600,5604501518609804,
    4917655076255841,3999855946779732,3034690618677388,
    2156485957257040,1437827591264317,899278231344296,
    526753407546620,288274613750624,146990556682887,
    69626509814580,30542906352994,12366448408056,4604442057431,
    1569983914256,487876545370,137395261280,34831261750,
    7884855000,1578162590,275861904,41455966,5246412,
    543534,44244,2652,104,2
};

int n, k;

// Map a knight at (r+dr,c+dc) into a bit index in the sliding mask,
// or return -1 if it's outside the tracked window.
int get_bit_position(int r, int c, int dr, int dc) {
    int rr = r + dr, cc = c + dc;
    if (rr < 0 || cc < 0 || cc >= n) return -1;
    // We keep 2 rows above (dr = -1 or -2) plus current row prefix.
    // Bit index = n*(-dr) + (c - cc) - 1
    return n * (-dr) + (c - cc) - 1;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> k;
    // For large boards use precomputed answers
    if (n == 8)  { cout << pre8[k]  << "\n"; return 0; }
    if (n == 9)  { cout << pre9[k]  << "\n"; return 0; }
    if (n == 10) { cout << pre10[k] << "\n"; return 0; }

    int W = 2*n + 1;
    int M = 1 << W;
    // dp[parity][mask][used_knights]
    vector<vector<vector<int64>>> dp(2,
        vector<vector<int64>>(M, vector<int64>(k+1, 0))
    );
    dp[0][0][0] = 1;  // start with no cells processed, empty mask, 0 knights

    // Process each cell in row-major order
    for(int pos = 0; pos < n*n; pos++){
        int now = pos & 1, nxt = now ^ 1;
        int r = pos / n, c = pos % n;
        // clear next layer
        for(int mask = 0; mask < M; mask++)
            fill(dp[nxt][mask].begin(), dp[nxt][mask].end(), 0);

        for(int mask = 0; mask < M; mask++){
            for(int used = 0; used <= k; used++){
                int64 ways = dp[now][mask][used];
                if (!ways) continue;

                // 1) skip placing a knight here
                int shifted = (mask << 1) & (M - 1);
                dp[nxt][shifted][used] += ways;

                // 2) try placing a knight here
                if (used < k) {
                    bool ok = true;
                    for(auto &mv : knight_moves) {
                        int bp = get_bit_position(r, c, mv.first, mv.second);
                        if (bp >= 0 && (mask & (1 << bp))) {
                            ok = false;
                            break;
                        }
                    }
                    if (ok) {
                        dp[nxt][shifted | 1][used + 1] += ways;
                    }
                }
            }
        }
    }

    // Sum over all masks at the final position with exactly k knights
    int final_par = (n*n) & 1;
    int64 answer = 0;
    for(int mask = 0; mask < M; mask++){
        answer += dp[final_par][mask][k];
    }
    cout << answer << "\n";
    return 0;
}
```

5. Python implementation with detailed comments  
```python
import sys
sys.setrecursionlimit(10**7)

# Four knight-move offsets that reach previous rows in a row-major scan
knight_moves = [(-2,-1),(-2,1),(-1,-2),(-1,2)]

# Precomputed answers for n=8,9,10
pre8 = [1,64,1848,32084,376560,3184708,20202298,98796304,
    379978716,1167053680,2897726604,5876860140,9825415557,
    13660238780,15932672964,15737653004,13304668385,9742722088,
    6260518246,3574590840,1830733371,844203844,349524138,
    128874944,41833846,11792736,2840224,572432,93840,12004,
    1122,68,2]
pre9 = [1,81,3016,68796,1080942,12472084,110018552,
    762775440,4241252429,19206532478,71707869632,
    222946143752,582155146204,1286247689414,2421159140764,
    3908273840366,5446391581062,6599640204257,7010436668992,
    6589213734278,5537849837497,4207779106033,2920161348852,
    1865346129716,1101125592067,600730512987,302041066250,
    139345014744,58692638521,22451454400,7755194754,
    2403337080,663103709,161373907,34237130,6238414,957145,
    120334,11914,872,42,1]
pre10 = [1,100,4662,135040,2732909,41199404,481719518,
    4491423916,34075586550,213628255072,1120204619108,
    4961681221524,18715619717199,60541371615660,168976761361446,
    409191804533576,864172675710439,1599730843649564,
    2609262108838924,3770687313420780,4857550050070531,
    5616928666465104,5874943705896600,5604501518609804,
    4917655076255841,3999855946779732,3034690618677388,
    2156485957257040,1437827591264317,899278231344296,
    526753407546620,288274613750624,146990556682887,
    69626509814580,30542906352994,12366448408056,4604442057431,
    1569983914256,487876545370,137395261280,34831261750,
    7884855000,1578162590,275861904,41455966,5246412,
    543534,44244,2652,104,2]

def get_bit_position(n, r, c, dr, dc):
    """Map a knight at (r+dr,c+dc) into a bit index in the sliding mask,
       or return -1 if outside the window of 2n+1 bits."""
    rr, cc = r+dr, c+dc
    if rr<0 or cc<0 or cc>=n:
        return -1
    return n*(-dr) + (c - cc) - 1

def main():
    data = sys.stdin.read().split()
    n, k = map(int, data)
    # for n>=8 use precomputed
    if n==8:
        print(pre8[k]); return
    if n==9:
        print(pre9[k]); return
    if n==10:
        print(pre10[k]); return

    W = 2*n+1
    M = 1<<W
    # dp[2][M][k+1]
    dp = [
        [ [0]*(k+1) for _ in range(M) ],
        [ [0]*(k+1) for _ in range(M) ]
    ]
    dp[0][0][0] = 1

    # scan each cell
    for pos in range(n*n):
        now = pos & 1
        nxt = now ^ 1
        r, c = divmod(pos, n)
        # clear next layer
        for m in range(M):
            for t in range(k+1):
                dp[nxt][m][t] = 0
        # transitions
        for mask in range(M):
            for used in range(k+1):
                ways = dp[now][mask][used]
                if ways==0:
                    continue
                # skip
                shifted = (mask<<1) & (M-1)
                dp[nxt][shifted][used] += ways
                # place knight?
                if used<k:
                    ok = True
                    for dr,dc in knight_moves:
                        bp = get_bit_position(n, r, c, dr, dc)
                        if bp>=0 and (mask & (1<<bp)):
                            ok = False
                            break
                    if ok:
                        dp[nxt][shifted|1][used+1] += ways

    # sum up
    final = (n*n)&1
    ans = sum(dp[final][m][k] for m in range(M))
    print(ans)

if __name__=='__main__':
    main()
```