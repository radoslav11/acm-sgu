p473.ans1
======================
6

=================
p473.in1
======================
4

=================
p473.py
======================
import sys

sys.set_int_max_str_digits(100000)


def solve(K):
    # Find the smallest positive integer N such that N has exactly K divisors.
    #
    # The key insight is that if N = p1^a1 * p2^a2 * ... * pm^am, then
    # the number of divisors is (a1+1) * (a2+1) * ... * (am+1).
    #
    # So we need to find all factorizations of K = b1 * b2 * ... * bm where
    # each bi >= 2, and then N = p1^(b1-1) * p2^(b2-1) * ... * pm^(bm-1)
    # where p1, p2, ..., pm are the first m primes.
    #
    # We use Python for potentially large integers when K is prime, as the
    # answer would be 2^(K-1) which can be astronomically large.
    #
    # This approach is fast because there aren't that many factorizations
    # of a number <= 10^5. In particular, an easy upper bound is the log(K)-th Bell 
    # number equal to ~1e9 for 16. However, this is only possible for K = 2^c, in 
    # which case the factors are the same and if we don't generate them multiple times
    # we significantly reduce the above figure. For example if K = 2^c a tighter upper
    # bound for the number of unique factorizations is only 2^(c-1) - think of this as 
    # setting the separators between the groups.

    if K == 1:
        return 1

    # Generate enough primes (we won't need more than log2(K) primes)
    # since the smallest factorization would be 2 * 2 * ... * 2
    max_primes_needed = K.bit_length()
    primes = []
    is_prime = [True] * (max_primes_needed * 10)  # Generous upper bound

    for i in range(2, len(is_prime)):
        if is_prime[i]:
            primes.append(i)
            if len(primes) >= max_primes_needed:
                break
            for j in range(i * i, len(is_prime), i):
                is_prime[j] = False

    # Find all ordered factorizations of K using iterative approach
    # Each factorization represents exponents+1 for our prime factorization
    factorizations = []

    # Stack: (remaining_value, current_factorization, min_factor)
    stack = [(K, [], 2)]

    while stack:
        remaining, current, min_factor = stack.pop()

        if remaining == 1:
            factorizations.append(current[::-1])
            continue

        # Try all factors from min_factor to remaining
        # This ensures we generate factorizations in non-increasing order
        for factor in range(min_factor, remaining + 1):
            q, r = divmod(remaining, factor)
            if r == 0:
                new_current = current + [factor]
                stack.append((q, new_current, factor))

    # For each factorization, compute the corresponding N
    min_n = None

    for factors in factorizations:
        # factors = [b1, b2, ..., bm] where K = b1 * b2 * ... * bm
        # N = p1^(b1-1) * p2^(b2-1) * ... * pm^(bm-1)

        assert len(factors) <= len(primes)

        n = 1
        for i, factor in enumerate(factors):
            n *= primes[i] ** (factor - 1)

            # Early termination if n is already too large
            if min_n is not None and n >= min_n:
                break

        if min_n is None or n < min_n:
            min_n = n

    return min_n


def main():
    K = int(input().strip())
    print(solve(K))


if __name__ == "__main__":
    main()

=================
statement.txt
======================
473. Droid formation
Time limit per test: 0.5 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard



A long time ago (but somehow in the future), in a Galaxy Far Far Away...

— Your majesty, Jedi detachment almost finished to mine our new Death Cube! New battle droids are unable to restrain them! What to do!?

— Rest assured! What is the strength of every troop of droids?

— 12 droids, your majesty!

— Fools! I told you that a troop should have 4 variants of evolution but troop of 12 droids has 6! This perverts threads of the Power — and infeeds Jedis! Regroup the army — and Jedis will lose!

— Yes sir!

Number of variants of evolution of a troop of droids is the number of ways to draw it up in rows so that every row has the same number of droids. For example, a troop of 12 droids can be arranged in 1 row of 12 droids, 2 rows of 6 droids, 3 rows of 4 droids, 4 rows of 3 droids, 6 rows of 2 droids and 12 rows consisting of 1 droid each. So, as the Emperor noticed, there are 6 variants of evolution for this troop of droids.

You problem is more general — given the number K of favorable variants of evolution, find the smallest positive size of a troop of droids N which has this very number of variants of evolution.

Input
Input file contains only number K from the problem statement (1 ≤ K ≤ 105).

Output
Write to the output file the required number N. If there is no such number, write to the output file number 0 instead.

Example(s)
sample input
sample output
4
6

=================
