## 1) A concise, abridged problem statement

You have four Pascal-like pointer variables `a, b, c, d`, each initially pointing to its own allocated integer cell containing `0`.  
You are given `N (1..30)` statements (no spaces), each ending with `;`, of one of these forms:

1. `x^:=k` where `k` is a digit `0..9` (store constant into the cell pointed by `x`)
2. `x^:=y^` (copy value from cell pointed by `y` into cell pointed by `x`)
3. `x:=y` (make pointer `x` point to the same cell as `y`)
4. `writeln(x^)` (print the value in the cell pointed by `x`)

Simulate the program and output exactly what all `writeln` statements print, each on its own line.

---

## 2) Detailed editorial (solution idea and reasoning)

### Key observation
There are two distinct “levels” of data:

- **Pointer variables** `a, b, c, d` store *addresses* (which memory cell they point to).
- Each **memory cell** stores an integer value.

Operations either:
- change a **cell value** (`x^ := ...`), or
- change a **pointer’s target** (`x := y`), or
- print a **cell value** (`writeln(x^)`).

So we must simulate both pointer aliasing and cell updates.

### Modeling the memory
At the start, each of `a, b, c, d` points to a different memory cell, each containing `0`.

A clean model:
- Create 4 “cells” (objects) holding integers.
- Store, for each pointer variable (`a`,`b`,`c`,`d`), a reference to one of these cells.

Then:
- `x := y` makes the reference of `x` become the same as `y` (aliasing).
- `x^ := 7` writes into the cell referenced by `x`.
- `x^ := y^` reads from `y`’s referenced cell and writes to `x`’s referenced cell.
- `writeln(x^)` prints the integer in `x`’s referenced cell.

This exactly matches pointer semantics.

### Parsing the input statements
Input lines contain no spaces and always end with `;`, so we can:
1. Remove the trailing `;`.
2. If it starts with `"writeln("`, it’s a print:
   - extract the pointer letter inside: `writeln(a^)` → `a`.
3. Otherwise it is an assignment containing `":="`:
   - Split into `left` and `right`.
   - If `left` ends with `'^'`, it’s a **dereference assignment** (`x^ := ...`):
     - if `right` is a single digit → constant assignment
     - else must be like `y^` → copy value
   - Else it’s **pointer assignment** (`x := y`), both single letters.

### Complexity
`N ≤ 30`, so any direct simulation is trivial:
- Time: `O(N)`
- Memory: `O(1)`

---

## 3) Provided C++ solution with detailed line-by-line comments

```cpp
#include <bits/stdc++.h>              // Includes almost all standard C++ headers
using namespace std;

// Overload operator<< for printing pair (not used in this solution, but harmless utility)
template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

// Overload operator>> for reading pair (not used here)
template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

// Overload operator>> for reading a whole vector by reading each element (used for lines)
template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for (auto& x : a) {              // For every element in vector
        in >> x;                     // Read it with operator>> (strings read as tokens)
    }
    return in;
};

// Overload operator<< for printing vector (not used here)
template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for (auto x : a) {
        out << x << ' ';
    }
    return out;
};

int n;                                // Number of lines/statements
vector<string> lines;                 // The program lines, each is a statement without spaces

void read() {
    cin >> n;                         // Read N
    lines.resize(n);                  // Allocate N strings
    cin >> lines;                     // Read N tokens (each line has no spaces, so token read works)
}

void solve() {
    // We simulate Pascal pointers using real C++ pointers to dynamically allocated integers.
    // Each of a,b,c,d is initially a distinct memory cell containing 0.
    int* pa = new int(0);
    int* pb = new int(0);
    int* pc = new int(0);
    int* pd = new int(0);

    for (int i = 0; i < n; i++) {
        string line = lines[i];       // Current statement

        // Remove trailing ';' if present
        if (!line.empty() && line.back() == ';') {
            line.pop_back();
        }

        // Case 1: writeln(pointer^)
        if (line.substr(0, 8) == "writeln(") {
            // Extract contents inside writeln(...)
            string inside = line.substr(8, line.size() - 8);

            // Remove trailing ')' if present
            if (!inside.empty() && inside.back() == ')') {
                inside.pop_back();
            }

            // Expect exactly like "a^" (2 characters)
            if (inside.size() != 2 || inside[1] != '^') {
                continue;             // If malformed, skip (problem guarantees well-formed though)
            }

            char p = inside[0];       // Pointer variable name: a/b/c/d
            int val;

            // Read value from the cell pointed by the chosen pointer
            if (p == 'a') {
                val = *pa;
            } else if (p == 'b') {
                val = *pb;
            } else if (p == 'c') {
                val = *pc;
            } else if (p == 'd') {
                val = *pd;
            } else {
                continue;
            }

            cout << val << endl;      // Output the value
        } else {
            // Otherwise, it must be an assignment containing ":="
            size_t pos = line.find(":=");
            if (pos == string::npos) {
                continue;             // Malformed safety
            }

            string left = line.substr(0, pos);       // Left-hand side
            string right = line.substr(pos + 2);     // Right-hand side

            // If left ends with '^', it's a dereference assignment: x^ := ...
            if (left.back() == '^') {
                // Validate left is exactly like "a^"
                if (left.size() != 2 || left[1] != '^') {
                    continue;
                }

                char p1 = left[0];    // Target pointer variable name
                int* ptr1;

                // Map 'a','b','c','d' to the corresponding C++ pointer variable pa,pb,pc,pd
                if (p1 == 'a') {
                    ptr1 = pa;
                } else if (p1 == 'b') {
                    ptr1 = pb;
                } else if (p1 == 'c') {
                    ptr1 = pc;
                } else if (p1 == 'd') {
                    ptr1 = pd;
                } else {
                    continue;
                }

                // If right side is a single digit, assign constant to *ptr1
                if (isdigit(right[0]) && right.size() == 1) {
                    int val = right[0] - '0';
                    *ptr1 = val;      // Store constant into the pointed cell
                } else {
                    // Otherwise expect right side like "b^"
                    if (right.size() != 2 || right[1] != '^') {
                        continue;
                    }

                    char p2 = right[0]; // Source pointer variable name
                    int val;

                    // Read value from source pointed cell
                    if (p2 == 'a') {
                        val = *pa;
                    } else if (p2 == 'b') {
                        val = *pb;
                    } else if (p2 == 'c') {
                        val = *pc;
                    } else if (p2 == 'd') {
                        val = *pd;
                    } else {
                        continue;
                    }

                    *ptr1 = val;      // Write it into destination pointed cell
                }
            } else {
                // Else it's pointer assignment: x := y
                if (left.size() != 1) {
                    continue;
                }
                char p1 = left[0];    // Destination pointer variable
                if (right.size() != 1) {
                    continue;
                }
                char p2 = right[0];   // Source pointer variable

                int* newptr;

                // Determine the address that p2 currently holds (i.e., which cell it points to)
                if (p2 == 'a') {
                    newptr = pa;
                } else if (p2 == 'b') {
                    newptr = pb;
                } else if (p2 == 'c') {
                    newptr = pc;
                } else if (p2 == 'd') {
                    newptr = pd;
                } else {
                    continue;
                }

                // Make p1 point to the same cell as p2 (aliasing)
                if (p1 == 'a') {
                    pa = newptr;
                } else if (p1 == 'b') {
                    pb = newptr;
                } else if (p1 == 'c') {
                    pc = newptr;
                } else if (p1 == 'd') {
                    pd = newptr;
                }
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false); // Faster I/O
    cin.tie(nullptr);                 // Untie cin/cout for speed

    int T = 1;                        // Only one test case in this problem
    // cin >> T;
    for (int test = 1; test <= T; test++) {
        read();                       // Read input program
        // cout << "Case #" << test << ": ";
        solve();                      // Simulate and print outputs
    }

    return 0;
}
```

---

## 4) Python solution (same logic) with detailed comments

```python
import sys

def solve() -> None:
    data = sys.stdin.read().strip().split()
    n = int(data[0])
    lines = data[1:1+n]

    # Each "cell" is modeled as a one-element list [value],
    # because lists are mutable and can be shared (aliasing) easily.
    cell_a = [0]
    cell_b = [0]
    cell_c = [0]
    cell_d = [0]

    # Pointer variables map to the cell object they currently point to.
    ptr = {
        'a': cell_a,
        'b': cell_b,
        'c': cell_c,
        'd': cell_d,
    }

    out = []

    for line in lines:
        # Remove trailing semicolon
        if line.endswith(';'):
            line = line[:-1]

        # Handle print statement: writeln(x^)
        if line.startswith("writeln("):
            inside = line[len("writeln("):]
            # remove trailing ')'
            if inside.endswith(')'):
                inside = inside[:-1]

            # inside should be like "a^"
            x = inside[0]            # pointer name
            # dereference: the integer value is in ptr[x][0]
            out.append(str(ptr[x][0]))
            continue

        # Otherwise assignment, split by ':='
        left, right = line.split(":=")

        # If left is like "a^", we assign to the pointed value
        if left.endswith('^'):
            x = left[0]              # destination pointer variable

            # Case: constant digit
            if len(right) == 1 and right.isdigit():
                ptr[x][0] = int(right)
            else:
                # Case: y^ (copy value)
                y = right[0]
                ptr[x][0] = ptr[y][0]

        else:
            # Pointer assignment: x := y  (alias pointers)
            x = left[0]
            y = right[0]
            ptr[x] = ptr[y]

    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    solve()
```

---

## 5) Compressed editorial

Maintain four pointer variables mapping to shared “cells” (mutable objects) holding integers.  
Initially each pointer maps to its own cell with value `0`.  
Process each statement:

- `x:=y` → set pointer `x` to reference the same cell as `y`.
- `x^:=k` → write constant `k` into `x`’s referenced cell.
- `x^:=y^` → copy value from `y`’s cell into `x`’s cell.
- `writeln(x^)` → output value in `x`’s cell.

This direct simulation is `O(N)` with constant memory.