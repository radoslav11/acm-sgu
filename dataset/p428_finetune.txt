<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

428. Rebus
Time limit per test: 0.5 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard



An addition rebus is a puzzle where you get an addition equation, like ABC+CBA=BDB, and you're asked to replace each letter with a digit (from 0 through 9) in such a way that:
Equal letters are replaced with equal digits.
Different letters are replaced with different digits.
None of the resulting numbers starts with 0, unless the entire number is just 0.
The resulting equation holds.


A proper addition rebus is an addition rebus with exactly one solution. An aligned addition rebus is an addition rebus where all three involved numbers have the same length (number of digits). The above addition rebus is aligned, but isn't proper: 143+341=484 and 341+143=484 are its two possible different solutions (and there are more).

Find 1000 different proper aligned addition rebuses. Two rebuses are different if there is no one-to-one mapping from the set of 26 English letters on itself that transfers one of those rebuses into another. For example, ABC+CBA=BDB and XAY+YAX=AZA are not different, while ABC+CBA=BDB and ABC+DEF=GHI are different.

Input
The input file will be empty.

Output
Output any 1000 different proper aligned addition rebuses, one per line. Each rebus may only use capital English letters, symbols '+' and '='. Each rebus must be at most 100 characters long.

Example(s)
Note that this example output doesn't contain the required 1000 rebuses, it contains just two.

sample input
sample output
 
AABC+AABB=DBCB
RRR+TTR=EDT

<|response|>
1) Abridged problem statement
- Print any 1000 different aligned addition rebuses (strings of the form L+R=S with L, R, S having equal length), each having exactly one solution when letters are replaced by distinct digits 0–9, with no leading zeros unless the number is zero.
- Two rebuses are considered the same if one can be transformed into the other by a bijection relabeling the letters.
- Each line must be at most 100 characters.
- The input is empty; just output the 1000 lines.

2) Key observations
- If we can force the unique digit assignment A=1, B=2, …, I=9, then the rebus has exactly one solution and no carries occur anywhere (all column sums ≤ 9).
- We can enforce that with columns of two kinds:
  - Buffer columns: A + A = B. The leftmost such column has no incoming carry, so 2·A < 10 ⇒ A ≤ 4 and B = 2·A.
  - Constraint columns: A + X = X+1 for X ∈ {A,…,H}.
- Many repeated buffer columns imply no carries can flow:
  - The leftmost buffer has no incoming carry ⇒ B = 2·A.
  - If any constraint column produced a carry-out, the adjacent buffer to its left would receive an incoming carry and force B = 2·A + 1 there, contradicting B = 2·A. Hence no constraint produces a carry, and therefore no buffer receives a carry. Thus there are no carries anywhere.
- With no carries, each constraint A + X = X+1 gives val(X+1) = val(A) + val(X), so val(B)=2·val(A), val(C)=3·val(A), …, val(I)=9·val(A). Distinct digits and the ≤ 9 bound force val(A)=1 and then B=2,…,I=9. This shows uniqueness (properness).
- To produce 1000 pairwise different (non-isomorphic) rebuses, permute the order of the eight constraints A+X=X+1 over X ∈ {A,…,H}. Different permutations yield strings not relatable by any letter bijection:
  - The pattern fixes A (it occupies all positions in the left addend) and then B (it’s the result of A+A across all buffer columns).
  - The successor relations force any relabeling to preserve X → X+1 on A..I; with A and B fixed, that makes the relabeling identity on A..I. Therefore the order of constraints (the permutation) cannot be changed by relabeling, so all generated lines are pairwise different.
- Each number has 16 digits; a line is 16+1+16+1+16 = 50 characters ≤ 100.

3) Full solution approach
- Fix a permutation perm of the 8 letters A..H (there are 8! > 1000 choices). Iterate over 1000 different permutations.
- For each permutation, build three 16-letter strings L, R, S by concatenating 8 pairs of columns:
  - Buffer column: append A to L and R, append B to S (encodes A + A = B).
  - Constraint column: append A to L, perm[i] to R, and next(perm[i]) to S (encodes A + X = X+1).
- Output L + "+" + R + "=" + S for each permutation.
- Correctness:
  - The construction is aligned by design (all have length 16).
  - Leftmost buffer gives B=2·A and ensures A≤4. Repeated buffers prevent any incoming carry anywhere ⇒ no carries at all.
  - Then constraints enforce val(X)=k·val(A) for k=1..9, forcing A=1 and uniquely fixing B..I.
  - No number starts with 0 (leftmost digits are A, A, B, i.e., 1, 1, 2).
  - Different permutations yield pairwise non-isomorphic rebuses.
- Complexity: O(1000) generation and printing; trivial within limits.

4) C++ implementation with detailed comments
#include <bits/stdc++.h>
using namespace std;

// Emit 1000 different proper aligned rebuses.
// Construction:
// - Use only letters A..I.
// - For i=0..7, append two columns:
//   1) buffer:    A + A = B
//   2) constraint: A + X = X+1, where X = perm[i] (perm is a permutation of A..H)
//
// Proof sketch:
// - Leftmost buffer has no incoming carry, so B=2*A and A<=4.
// - If any constraint produced a carry, the buffer to its left would read A+A+1=B,
//   forcing B=2*A+1, contradicting the leftmost buffer which fixes B=2*A.
//   Hence no carries occur anywhere.
// - With no carries: A+X=X+1 ⇒ values follow an arithmetic progression,
//   so A=1, B=2, ..., I=9 uniquely. Proper and aligned.
// - Different permutations are non-isomorphic because A (fixed) appears in all
//   positions of L, B is fixed by A+A=B across all buffers, and the successor
//   relation fixes the mapping on A..I. The column order (the permutation) cannot
//   be changed by relabeling.

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string perm = "ABCDEFGH"; // X in {A..H}
    for (int t = 0; t < 1000; ++t) {
        // Advance permutation so each line differs.
        // 8! = 40320 > 1000, so we won't run out.
        next_permutation(perm.begin(), perm.end());

        string L, R, S;
        L.reserve(16); R.reserve(16); S.reserve(16);

        for (int i = 0; i < 8; ++i) {
            // Buffer column: A + A = B
            L.push_back('A');
            R.push_back('A');
            S.push_back('B');

            // Constraint column: A + X = X+1
            L.push_back('A');
            R.push_back(perm[i]);
            S.push_back(char(perm[i] + 1)); // next(letter)
        }

        // Line length: 16 + 1 + 16 + 1 + 16 = 50 <= 100
        cout << L << "+" << R << "=" << S << "\n";
    }
    return 0;
}

5) Python implementation with detailed comments
import sys

# In-place next lexicographic permutation of a list; returns True if advanced, False otherwise.
def next_permutation(a):
    i = len(a) - 2
    while i >= 0 and a[i] >= a[i+1]:
        i -= 1
    if i < 0:
        a.reverse()
        return False
    j = len(a) - 1
    while a[j] <= a[i]:
        j -= 1
    a[i], a[j] = a[j], a[i]
    a[i+1:] = reversed(a[i+1:])
    return True

def solve():
    perm = list("ABCDEFGH")  # X in {A..H}
    out_lines = []

    for _ in range(1000):
        # Advance permutation so each output differs
        next_permutation(perm)

        L = []
        R = []
        S = []

        for i in range(8):
            # Buffer: A + A = B
            L.append('A')
            R.append('A')
            S.append('B')

            # Constraint: A + X = X+1
            X = perm[i]
            L.append('A')
            R.append(X)
            S.append(chr(ord(X) + 1))  # next letter

        Ls = "".join(L)
        Rs = "".join(R)
        Ss = "".join(S)
        out_lines.append(f"{Ls}+{Rs}={Ss}")

    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    solve()