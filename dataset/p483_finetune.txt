<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

483. Jealous Cucumber
Time limit per test: 0.25 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard

Mr. Cucumber was annoyed by pumpkins' dominance in Vegetable Land every Halloween and today he decided to restore justice. He took N peaceful pumpkins hostages and brought them to the hatch of his hutch. Then he numbered the hostages from 1 to N and started throwing them into the hatch one by one (from the 1-st to the N-th), waiting every time until previous hostage falls down. Cucumber's hutch is both-side infinite horizontally, and it has height N. The hutch was empty when Cucumber came. When a pumpkin is thrown into the hatch it has coordinates (0,N). Then it falls by the following rules:

let (x,y) denote current pumpkin's coordinates.
if position (x,y-1) is empty, pumpkin moves there,
else if position (x-1,y) is empty and position (x-1,y-1) is empty too, pumpkin moves to position (x-1,y-1),
else if position (x+1,y) is empty and position (x+1,y-1) is empty too, pumpkin moves to position (x+1,y-1)

Pumpkin moves until it reaches the bottom of the hutch (i.e. its y-coordinate equals to 0) or it can't move anymore.

After that crafty villain demanded Vegetable Land's government to appoint him symbol of Halloween in an hour, otherwise he was going to shoot pumpkins in the hutch in such a way that every pumpkin which y-coordinate equals to H dies.

Some of the hostages taken by Mr. Cucumber are Very Important Pumpkins (VIP), so the government wants to know the exact numbers of pumpkins who are going to be killed to make its decision.

Input
Input contains two integers separated by a single space: N and H (1 ≤ N ≤ 109), (0 ≤ H ≤ 109) — the number of Mr. Cucumber's hostages and y-position of endangered pumpkins.

Output
Print numbers of pumpkins who are going to be killed from the leftmost to the rightmost one, separating them by spaces. It is guaranteed that output will contain at least one number.

Example(s)
sample input
sample output
5 0
5 2 1 3

sample input
sample output
6 1
6 4

<|response|>
## 1) Abridged problem statement (concise)

We drop pumpkins numbered `1..N` into an initially empty infinite 2D grid of height `N`.  
Each pumpkin starts at `(0, N)` and repeatedly moves using these rules in order:

1. If `(x, y-1)` is empty → go down.
2. Else if `(x-1, y)` and `(x-1, y-1)` are empty → go down-left.
3. Else if `(x+1, y)` and `(x+1, y-1)` are empty → go down-right.
4. Else stop.

It stops when `y=0` or it can’t move.

Given `N` and height `H`, output (from leftmost to rightmost) the indices of pumpkins whose final resting `y` equals `H`. At least one such pumpkin exists.

Constraints: `N ≤ 1e9`.

---

## 2) Key observations

1. **The final pile is highly regular and symmetric** around `x=0`. The motion rules create a deterministic “sandpile-like” structure.
2. For any fixed height `H` that actually appears in the final configuration, the pumpkins resting at `y = H` form **one contiguous horizontal row**.
3. The **first (central) pumpkin index** that ends up on height `H` is:
   \[
   (H+1)^2
   \]
   This comes from the odd-sum identity:
   \[
   1 + 3 + 5 + \dots + (2H+1) = (H+1)^2
   \]
4. After that central pumpkin, further pumpkins on the same row appear symmetrically outward. The **gaps between consecutive indices** grow like:
   - `H+1, H+1, H+2, H+2, H+3, H+3, ...`
   i.e., each step length is used twice (left side and right side), then increases by 1.
5. The number of answers is only **O(√N)**, which is fast and also unavoidable because we must print them.

---

## 3) Full solution approach

We generate exactly the indices that land on `y=H` in left-to-right order.

### Step A: starting index (“center” of the row)
Let:
- `pos = (H+1)^2`  (this pumpkin will be on height `H`)
- `step = H+1`

The statement guarantees at least one answer, which implies `pos ≤ N` in valid tests.

### Step B: expand outward on both sides
We maintain two lists:
- `front`: indices that will appear on the **left side** (we will reverse it later)
- `back`: indices from the **center and right side** (already in correct order)

Initialize:
- `back = [pos]`

Then while we can still generate more indices ≤ `N`:
1. `pos += step` → goes to `front`
2. `pos += step` → goes to `back`
3. `step += 1`

Stop once `pos + step > N` (no more indices possible).

### Step C: output leftmost to rightmost
- Reverse `front` (because we collected from center outwards).
- Answer is `front + back`.

Time complexity: `O(k)` where `k` is number of printed indices (≈ `O(√N)`).  
Memory: `O(k)`.

---

## 4) C++ implementation (detailed comments)

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
We need to print the indices of pumpkins whose final y-coordinate is exactly H,
from leftmost to rightmost.

Key fact:
- The first (central) index on row y=H is (H+1)^2.
- Then indices on that row can be generated by moving outward with step sizes:
  (H+1), (H+1), (H+2), (H+2), (H+3), (H+3), ...

We store one side in 'front' (later reversed) and center+other side in 'back'.
*/

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    long long N, H;
    cin >> N >> H;

    // Central pumpkin index on height H:
    // 1 + 3 + ... + (2H+1) = (H+1)^2
    long long pos = (H + 1) * (H + 1);

    long long step = H + 1;

    vector<long long> front; // one side (will reverse for left-to-right)
    vector<long long> back;  // center and the other side (already in output order)

    back.push_back(pos);

    // Generate further indices as long as we can still add at least one more
    // with the current step without exceeding N.
    while (pos + step <= N) {
        // First addition with current step -> goes to 'front'
        pos += step;
        if (pos <= N) front.push_back(pos);

        // Second addition with the same step -> goes to 'back'
        pos += step;
        if (pos <= N) back.push_back(pos);

        // After placing on both sides, step grows.
        step++;
    }

    // 'front' currently has near-center to farther elements,
    // reverse it so it becomes leftmost ... toward center.
    reverse(front.begin(), front.end());

    // Output front then back: leftmost -> rightmost
    bool first = true;
    for (long long x : front) {
        if (!first) cout << ' ';
        cout << x;
        first = false;
    }
    for (long long x : back) {
        if (!first) cout << ' ';
        cout << x;
        first = false;
    }
    cout << "\n";

    return 0;
}
```

---

## 5) Python implementation (detailed comments)

```python
import sys

def solve() -> None:
    data = sys.stdin.read().strip().split()
    n = int(data[0])
    h = int(data[1])

    # Center index on row y = h:
    # 1 + 3 + ... + (2h+1) = (h+1)^2
    pos = (h + 1) * (h + 1)

    step = h + 1

    front = []       # one side, will reverse
    back = [pos]     # center + other side, already in correct order

    # Generate indices while we can still extend within 1..n
    while pos + step <= n:
        # First position at this radius
        pos += step
        if pos <= n:
            front.append(pos)

        # Second symmetric position at same radius
        pos += step
        if pos <= n:
            back.append(pos)

        # Next radius uses a bigger gap
        step += 1

    front.reverse()
    ans = front + back
    sys.stdout.write(" ".join(map(str, ans)) + "\n")

if __name__ == "__main__":
    solve()
```

These implementations follow the core structure implied by the pile’s geometry, avoid any grid simulation, and run in time proportional to the required output size.