<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

330. Numbers
Time limit per test: 0.25 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



Young Andrew is playing yet another numbers game. Initially, he writes down an integer A. Then, he chooses some divisor d1 of A, 1 < d1 < A, erases A and writes A1=A+d1 instead. Then, he chooses some divisor d2 of A1, 1 < d2 < A1, erases A1 and writes A2=A1+d2 instead.

I.e., at any step he chooses some positive integer divisor of the current number, but not 1 and not the whole number, and increases the current number by it.

Is it possible for him to write number B if he started with number A?

Input
The only line of input contains two integers A and B, 2 ≤ A < B ≤ 1012.

Output
If there's no solution, output "Impossible" (without quotes) to the only line of output. If there's one, output the sequence of numbers written starting with A and ending with B, one per line. You're not asked to find the shortest possible sequence, however, you should find a sequence with no more than 500 numbers. It is guaranteed that if there exists some sequence for the given A and B, then there exists a sequence with no more than 500 numbers in it.

Example(s)
sample input
sample output
12 57
12
16
24
27
30
40
50
52
54
57

sample input
sample output
3 6
Impossible

<|response|>
1. Abridged problem statement
-----------------------------

You are given two integers `A` and `B` with `2 ≤ A < B ≤ 10^12`.

You start from the number `A`. In one move, if the current number is `x`, you must:

- choose a divisor `d` of `x` such that `1 < d < x`, and
- replace `x` with `x + d`.

You may repeat this operation any number of times.

Task:

- Output `"Impossible"` if you cannot reach exactly `B` from `A`.
- Otherwise, output **one valid sequence** of numbers starting at `A` and ending at `B` (inclusive), each consecutive pair following the rule above.
- The sequence length must be at most 500 numbers (including `A` and `B`).

You do not need the shortest path; any correct one with ≤ 500 numbers is fine.

---

2. Key observations
-------------------

1. **Prime numbers are dead ends**  
   If `x` is prime, its only divisors are `1` and `x` itself, both forbidden.  
   So from a prime `x`, **no move is possible**.

2. **Parity behavior (odd/even transitions)**  
   - All divisors of an odd number are odd.  
     So from an odd `x`, any allowed `d` is odd → `x + d` is even.  
   - All divisors of an even number are even (since `2 | x` and any divisor shares this factor).  
     So from an even `x`, any allowed `d` is even → `x + d` is even.

   Therefore:
   - After at most one move, you get to an even number.
   - Once you are at an even number, you will stay even forever.

   Consequences:
   - The sequence can be:  
     `odd (maybe) → even → even → ... → even`  
   - If `B` is odd and is reachable, the **last** move must land on `B` from some even number.

3. **Handling odd endpoints with smallest divisor**
   Define:

   - `min_divisor(x)` = smallest divisor `d` with `1 < d < x`, or `-1` if `x` is prime.

   Then:
   - If `A` is odd and composite (so `min_divisor(A) ≠ -1`), we can first move:  
     `A → A + min_divisor(A)` (this is even).
   - If `B` is odd and composite, any valid last move into `B` must be of the form:  
     `X → B`, where `X + d = B` and `d` is a proper divisor of `B`.  
     One natural choice: use `d = min_divisor(B)`. Then `X = B - d`.

   So we define:
   - `adjusted_A = A` if A is even, else `A + min_divisor(A)` (first move).
   - `adjusted_B = B` if B is even, else `B - min_divisor(B)` (last-but-one).

   Between `adjusted_A` and `adjusted_B` we want an **even → even** sequence.

4. **When is it impossible?**
   - If `A` is odd prime: `min_divisor(A) == -1`. Cannot make the first move.
   - If `B` is odd prime: `min_divisor(B) == -1`. Cannot have a last move to `B`.
   - If after adjusting: `adjusted_A > adjusted_B`, then we can’t “walk” upward from `adjusted_A` to `adjusted_B`.

   In any of these situations, the answer is `"Impossible"`.

5. **Core problem: even A to even B**
   Now assume:
   - `adjusted_A` and `adjusted_B` are both even,
   - `adjusted_A ≤ adjusted_B`.

   We must transform one even number into another using steps `+d` where `d` is a proper divisor.

   Strategy: **only use powers of two** as divisors: `d = 2^K`.

   For a move from current `x`:
   - `2^K` must divide `x`, i.e., `x % 2^K == 0`.
   - `2^K` must be proper: `1 < 2^K < x` → `K ≥ 1` and `2^K < x`.
   - `x + 2^K ≤ B` to not overshoot.

   If we can always pick such a power of two, we can progress until we reach `B`.

6. **Why powers of two suffice and keep steps ≤ 500**
   For even `A < B`:

   - There always exists some `K ≥ 1` such that `2^K | A`, `2^K < A`, and `A + 2^K ≤ B` (if not, we’d already be at or beyond B).
   - Among all valid `K`, choose the **largest**. Then perform `A ← A + 2^K`.
   - Two types of steps:
     1. **Divisibility-limited**: we can’t increase `K` further because `2^{K+1}` does not divide `A`.
        - After adding `2^K`, the new value becomes divisible by `2^{K+1}`.
        - So next time we may use a strictly larger power of two.
        - This can happen at most `O(log A)` times because `K` strictly increases.
     2. **Distance-limited**: we can’t increase `K` because `A + 2^{K+1} > B`.
        - Then the remaining distance `D = B - A` is even.
        - We keep subtracting the largest allowable power-of-two divisors that fit in `D`.
        - This is akin to peeling off bits from the binary representation of `D`, and uses at most `O(log B)` moves.

   Total moves in both phases: `< 2 log₂ B < 500` for `B ≤ 10^12`.

---

3. Full solution approach
-------------------------

1. **Compute smallest non-trivial divisors:**
   - Implement `min_divisor(x)` via trial division up to `sqrt(x)`. Complexity per call is `O(√x)` which is fine for `x ≤ 10^12` (two calls only).

2. **Adjust endpoints for parity:**
   - Read `A`, `B`.
   - Compute `d1 = min_divisor(A)`, `dk = min_divisor(B)`.
   - If `A` is odd:
     - If `d1 == -1` → A is odd prime → `"Impossible"`.
     - Else set `adjusted_A = A + d1`.
   - Otherwise set `adjusted_A = A`.
   - If `B` is odd:
     - If `dk == -1` → B is odd prime → `"Impossible"`.
     - Else set `adjusted_B = B - dk`.
   - Otherwise set `adjusted_B = B`.

3. **Check consistency:**
   - If `adjusted_A > adjusted_B` → output `"Impossible"`.

4. **Solve the even-to-even core:**
   - Now `adjusted_A` and `adjusted_B` are even and `adjusted_A ≤ adjusted_B`.
   - Construct a sequence from `adjusted_A` to `adjusted_B`:

     - Initialize `pw2 = 2`.
     - While `A < B`:
       - While:
         - `A + 2 * pw2 <= B`, and
         - `2 * pw2 < A`, and
         - `A % (2 * pw2) == 0`,  
         increase `pw2 *= 2`.  
         (This tries to use the largest power of two that both divides `A` and fits under `B`.)
       - While `A + pw2 > B`, shrink `pw2 //= 2` to avoid overshooting.
       - Record current `A` in sequence.
       - Set `A += pw2`.
     - Finally append `B`.

   - This yields an all-even sequence satisfying the step rule.

5. **Rebuild the full path A → B:**
   - Initialize an output list.
   - If `adjusted_A != A` (meaning A was odd and we added one step), then:
     - First output original `A`.
   - Output all numbers from the even sequence (from `adjusted_A` to `adjusted_B`).
   - If `adjusted_B != B` (meaning B was odd and we reserved a last step), then:
     - Output final `B`.

6. **Guarantees:**
   - All consecutive pairs satisfy `next = current + d` where `d` is a valid proper divisor.
   - If a solution exists, this construction finds one with fewer than 500 terms.
   - Otherwise, we correctly print `"Impossible"`.

---

4. C++ implementation with detailed comments
--------------------------------------------

```cpp
#include <bits/stdc++.h>
using namespace std;

long long A, B;

// Return smallest non-trivial divisor of x (2 <= d < x), or -1 if x is prime.
long long min_divisor(long long x) {
    for (long long d = 2; d * d <= x; ++d) {
        if (x % d == 0) return d;
    }
    return -1; // x is prime
}

// Construct a valid sequence of moves from even A to even B (A <= B).
// Only uses powers of two as added divisors.
// Returns the full list including both endpoints.
vector<long long> solve_even(long long A, long long B) {
    assert(A % 2 == 0 && B % 2 == 0);
    vector<long long> seq;

    long long pw2 = 2; // current power of two we attempt to add

    while (A < B) {
        // Try to grow pw2 as much as possible while:
        //  1) A + 2*pw2 <= B      (won't overshoot B)
        //  2) 2*pw2 < A           (still a proper divisor)
        //  3) A % (2*pw2) == 0    (2*pw2 divides A)
        while (A + 2 * pw2 <= B && 2 * pw2 < A && A % (2 * pw2) == 0) {
            pw2 *= 2;
        }

        // If pw2 is now too big to add without overshooting, shrink it.
        while (A + pw2 > B) {
            pw2 /= 2;
        }

        // Record current A in the sequence.
        seq.push_back(A);

        // Perform the move A -> A + pw2.
        A += pw2;
    }

    // Finally, append B (A == B at this point).
    seq.push_back(B);
    return seq;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    if (!(cin >> A >> B)) return 0;

    long long d1 = min_divisor(A);
    long long dk = min_divisor(B);

    long long adjusted_A = A;
    long long adjusted_B = B;

    // If A is odd, we plan to do one initial step: A -> A + d1.
    if (A % 2 == 1) {
        if (d1 == -1) { // A is odd prime: no valid first move
            cout << "Impossible\n";
            return 0;
        }
        adjusted_A = A + d1; // this is even
    }

    // If B is odd, we plan the last step as: adjusted_B -> adjusted_B + dk = B.
    if (B % 2 == 1) {
        if (dk == -1) { // B is odd prime: cannot be the endpoint of a valid last move
            cout << "Impossible\n";
            return 0;
        }
        adjusted_B = B - dk; // this is even
    }

    // Now both adjusted_A and adjusted_B should be even.
    // Check if the interval is valid.
    if (adjusted_A > adjusted_B) {
        cout << "Impossible\n";
        return 0;
    }

    // Solve the even-to-even part.
    vector<long long> mid = solve_even(adjusted_A, adjusted_B);

    // Build and print the full sequence.
    // 1) If we modified A, original A must come first.
    if (adjusted_A != A) {
        cout << A << '\n';
    }

    // 2) Print the even sequence from adjusted_A to adjusted_B.
    for (long long x : mid) {
        cout << x << '\n';
    }

    // 3) If we modified B, print final odd B.
    if (adjusted_B != B) {
        cout << B << '\n';
    }

    return 0;
}
```

---

5. Python implementation with detailed comments
-----------------------------------------------

```python
import sys
from math import isqrt

def min_divisor(x: int) -> int:
    """
    Return the smallest non-trivial divisor of x (2 <= d < x),
    or -1 if x is prime.
    """
    # Trial division up to sqrt(x)
    limit = isqrt(x)
    for d in range(2, limit + 1):
        if x % d == 0:
            return d
    return -1  # x is prime

def solve_even(A: int, B: int):
    """
    Solve the problem for even A and even B (A <= B).
    We only use moves that add a power-of-two divisor.
    Returns a list of numbers from A to B, inclusive.
    """
    assert A % 2 == 0 and B % 2 == 0
    seq = []
    pw2 = 2  # current power of two we may add

    while A < B:
        # Try to double pw2 while:
        #  1) A + 2*pw2 <= B     (won't overshoot)
        #  2) 2*pw2 < A          (still a proper divisor)
        #  3) A % (2*pw2) == 0   (2*pw2 divides A)
        while A + 2 * pw2 <= B and 2 * pw2 < A and A % (2 * pw2) == 0:
            pw2 *= 2

        # If pw2 is too big to add, shrink it until it fits.
        while A + pw2 > B:
            pw2 //= 2

        # Record current value.
        seq.append(A)
        # Perform the move.
        A += pw2

    # Finally append B.
    seq.append(B)
    return seq

def main():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    A = int(data[0])
    B = int(data[1])

    d1 = min_divisor(A)
    dk = min_divisor(B)

    adjusted_A = A
    adjusted_B = B

    # Handle odd A: first step A -> A + d1
    if A % 2 == 1:
        if d1 == -1:  # A is odd prime
            print("Impossible")
            return
        adjusted_A = A + d1

    # Handle odd B: last step adjusted_B -> adjusted_B + dk = B
    if B % 2 == 1:
        if dk == -1:  # B is odd prime
            print("Impossible")
            return
        adjusted_B = B - dk

    # Interval must be non-empty
    if adjusted_A > adjusted_B:
        print("Impossible")
        return

    # Now both adjusted_A and adjusted_B are even.
    seq_even = solve_even(adjusted_A, adjusted_B)

    out = []

    # If we changed A, print original A first.
    if adjusted_A != A:
        out.append(str(A))

    # Print the even sequence.
    for x in seq_even:
        out.append(str(x))

    # If we changed B, print final B last.
    if adjusted_B != B:
        out.append(str(B))

    sys.stdout.write("\n".join(out) + "\n")

if __name__ == "__main__":
    main()
```

This Python code mirrors the C++ logic, clearly separating:

- parity / primality preprocessing (`min_divisor`, `adjusted_A`, `adjusted_B`),
- the core even-to-even path construction (`solve_even`),
- and final assembly of the sequence.