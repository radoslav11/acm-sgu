p363.in1
======================
5 2
1 2
3 4
4 1
5 2
6 1

=================
statement.txt
======================
363. Baggage Room
Time limit per test: 0.25 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



Schoolboys Vasya and Pete travel a lot. They use baggage rooms really often. Baggage room has M windows, numbered 1 through M. When a lot of people come, there are big queues in front of windows. Newly come person stands in the queue with the least number of people. If there are several such queues than he or she chooses queue to the window with lowest number. When the queue is chosen, the decision will not further change. When next person comes to the window, he or she spends some time near the window to take or get his stuff, pay money, etc. (let's call it servicing time). This time is specific to each person and doesn't depend on the window. During this time the person is counted as standing in the queue. If new person come in the moment when one or several peoplehave just proceeded to their windows, he or she waits first until these people will leave their queues and then he or she chooses the queue to stand in. Vasya and Pet e wonder when each particular person will leave the queue. Please help them.

Input
The first line of the input file contains two integer numbers N, M (1 ≤ N ≤ 100; 1 ≤ M ≤ 100), where N - number of people, M - number of windows in the baggage room. Next N lines contain pairs of integer numbers ki, ti (1 ≤ ki ≤ 1000; 1 ≤ ti ≤ 100), where ki - time moment, when ith person came, ti - servicing time of ith person. Persons are listed in order of increase of ki.

Output
Print N lines. Print in the ith line two numbers - number of the queue, that would be chosen by ith person and moment of the time, when he or she will leave the queue.

Example(s)
sample input
sample output
5 2
1 2
3 4
4 1
5 2
6 1
1 3
1 7
2 5
2 7
1 8

=================
p363.ans1
======================
1 3
1 7
2 5
2 7
1 8

=================
p363.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

int n, m;
vector<int> arrival, service;

void read() {
    cin >> n >> m;
    arrival.resize(n);
    service.resize(n);
    for(int i = 0; i < n; i++) {
        cin >> arrival[i] >> service[i];
    }
}

void solve() {
    // We can directly implement this problem by simulation the queue process -
    // we just need to keep when everyone entered and then go in increasing
    // order of time. We don't actually need this, but we could use a priority
    // queue of "events" to make this more efficient.

    vector<vector<int>> finish_times(m);

    for(int i = 0; i < n; i++) {
        int k = arrival[i];
        int t = service[i];

        vector<int> queue_count(m, 0);
        for(int w = 0; w < m; w++) {
            for(int finish: finish_times[w]) {
                if(finish > k) {
                    queue_count[w]++;
                }
            }
        }

        int best_window = 0;
        for(int w = 1; w < m; w++) {
            if(queue_count[w] < queue_count[best_window]) {
                best_window = w;
            }
        }

        int start_time = k;
        if(!finish_times[best_window].empty()) {
            start_time = max(start_time, finish_times[best_window].back());
        }
        int end_time = start_time + t;

        finish_times[best_window].push_back(end_time);

        cout << (best_window + 1) << ' ' << end_time << '\n';
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
