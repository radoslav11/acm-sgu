## 1) Abridged problem statement

Given `n` integers `a1..an` (may be negative), consider all products of choosing exactly `m` distinct elements (all `m`-subsets), producing `C(n,m)` products. Sort these products in **non-increasing** order (largest to smallest, keeping duplicates). Output the **k-th** product in this order.

Constraints: `n ≤ 10000`, `m ≤ 13`, `k ≤ 10000`, values `|ai| ≤ 1e6`. The product can be extremely large, so big integers are needed.

---

## 2) Detailed editorial (explaining the provided solution idea)

### Key observations

1. **`m` is tiny (≤ 13), `k` is also small (≤ 10000), but `n` is huge (≤ 10000).**  
   We cannot enumerate all `C(n,m)` subsets.

2. We need the **k-th largest product**, with possible **negative products** and **duplicates**.

3. The product magnitude can be enormous (`(1e6)^13` is already huge), so we need **big integer arithmetic** for exact comparison/output.

---

### Step A: Sort and split negatives/positives

Sort the array `a` ascending.

Let `split` be the first index with `a[split] >= 0`. Then:
- indices `[0 .. split-1]` are negative
- indices `[split .. n-1]` are non-negative

Let:
- `total_neg = split`
- `total_pos = n - split`

---

### Step B: Fix the number of negatives in the chosen subset

If we choose exactly `num_negs` negative numbers, then we must choose `num_pos = m - num_negs` non-negative numbers.

This is valid only if:
- `num_negs ≤ total_neg`
- `num_pos ≤ total_pos`

For each feasible `num_negs`, we will create an **initial “best” subset** for that sign-pattern, and then explore “nearby” subsets in decreasing product order using a priority queue.

The trick: for each fixed `(num_negs, num_pos)`, there is a natural “extreme” subset:
- If `num_negs` is **even**, the product is **non-negative**. To maximize the product, you generally want large positives and “very negative” (large absolute value) negatives paired up.  
- If `num_negs` is **odd**, the product is **negative**. To maximize (i.e., be as large as possible), you want it to be **closest to zero** (least negative), i.e., smaller absolute value choices.

The code encodes these choices via a function `create_initial_state(num_negs, split)`:
- It chooses a particular ordered selection of indices from the negative zone and the non-negative zone, depending on parity of `num_negs`.
- It also stores bounds (`lo/hi`) describing the allowed index ranges.

This gives **one starting subset per feasible `num_negs`**.

---

### Step C: Represent a subset as a “state” and define neighbors

A `State` contains:
- `pos_indices`: the selected indices among non-negatives (size `num_pos`)
- `neg_indices`: the selected indices among negatives (size `num_negs`)
- plus some boundary metadata
- plus a cached `bigint` product

The product for a state is simply:
\[
\prod_{i \in pos\_indices} a[i] \cdot \prod_{j \in neg\_indices} a[j]
\]
computed with big integers.

**Neighbors**: generate new subsets by “moving” exactly one chosen index by 1 step (increment or decrement), ensuring:
- indices remain within their segment bounds
- indices remain strictly ordered (no duplicates, still a subset)

This is basically the classic “k best combinations from sorted lists” neighbor-generation pattern: each subset has only `O(m)` neighbors.

---

### Step D: Best-first search with a priority queue (max-heap)

We push all initial states (for all feasible `num_negs`) into a priority queue ordered by product.

Then we repeatedly:
1. Pop the current maximum-product state.
2. If this is the `k`-th popped state, output its product.
3. Otherwise, generate its neighbors and push unseen ones.

To avoid revisiting the same subset, we keep a `set<State> visited` keyed by the pair of index-vectors.

Because:
- each pop generates at most `m` neighbors,
- we pop exactly `k` times,
this explores about `O(k*m)` states. With `k ≤ 10000` and `m ≤ 13`, this is manageable.

The main heavy part is:
- big integer multiplication/comparison when ordering states in the heap.

The given `bigint` implementation uses base `1e9` digits and Karatsuba multiplication to stay fast.

---

### Correctness sketch

- The initial states cover all possible parities / counts of negatives (all feasible `num_negs`).
- Neighbor steps enumerate subsets in a structured lattice, where from an extreme subset you can reach any valid subset by successive single-index moves.
- The algorithm is a standard “best-first enumeration” (Dijkstra-like but with a max-heap on values) over an implicit graph of subsets.  
  Since we always pop the largest remaining product among discovered states, the pop order is non-increasing among discovered candidates. With the visited set and the fact that every state is eventually discoverable from its group’s initial state, the k-th pop is the k-th largest overall.

---

### Complexity

Let `S ≈ O(k*m)` be number of states processed/inserted.
- Neighbor generation: `O(S*m)` simple operations.
- Visited set operations: `O(log S)` comparisons of small vectors (length ≤ 13).
- Bigint product computation per state is `O(m * cost_mul)` but cached inside the state after first computation.

In practice, this passes due to small `m`, small `k`, and caching.

---

## 3) Provided C++ solution with detailed line-by-line comments

```cpp
#include <bits/stdc++.h>
using namespace std;

// Pretty-print a pair as "first second"
template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

// Read a pair from input
template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

// Read a vector by reading each element
template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for (auto& x: a) in >> x;
    return in;
}

// Print a vector with spaces after each element
template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for (auto x: a) out << x << ' ';
    return out;
};

// Big integer implementation details:
// base = 1e9 per "digit", so each element of z stores 9 decimal digits.
const int base = 1000000000;
const int base_digits = 9;

struct bigint {
    vector<int> z; // little-endian digits in base 1e9 (z[0] is least significant)
    int sign;      // +1 or -1

    bigint() : sign(1) {}
    bigint(long long v) { *this = v; }
    bigint(const string& s) { read(s); }

    // Copy assignment
    void operator=(const bigint& v) {
        sign = v.sign;
        z = v.z;
    }

    // Assign from 64-bit integer
    void operator=(long long v) {
        sign = 1;
        if (v < 0) sign = -1, v = -v;
        z.clear();
        for (; v > 0; v /= base) z.push_back(v % base);
    }

    // Addition
    bigint operator+(const bigint& v) const {
        if (sign == v.sign) {
            // Same sign: add magnitudes
            bigint res = v;
            for (int i = 0, carry = 0;
                 i < (int)max(z.size(), v.z.size()) || carry; ++i) {
                if (i == (int)res.z.size()) res.z.push_back(0);
                res.z[i] += carry + (i < (int)z.size() ? z[i] : 0);
                carry = res.z[i] >= base;
                if (carry) res.z[i] -= base;
            }
            return res;
        }
        // Different signs: a + b == a - (-b)
        return *this - (-v);
    }

    // Subtraction
    bigint operator-(const bigint& v) const {
        if (sign == v.sign) {
            // Same sign: subtract magnitudes
            if (abs() >= v.abs()) {
                bigint res = *this;
                for (int i = 0, carry = 0; i < (int)v.z.size() || carry; ++i) {
                    res.z[i] -= carry + (i < (int)v.z.size() ? v.z[i] : 0);
                    carry = res.z[i] < 0;
                    if (carry) res.z[i] += base;
                }
                res.trim();
                return res;
            }
            // If |this| < |v|, result is negative of (v - this)
            return -(v - *this);
        }
        // Different signs: a - b == a + (-b)
        return *this + (-v);
    }

    // Multiply by small int
    void operator*=(int v) {
        if (v < 0) sign = -sign, v = -v;
        for (int i = 0, carry = 0; i < (int)z.size() || carry; ++i) {
            if (i == (int)z.size()) z.push_back(0);
            long long cur = z[i] * (long long)v + carry;
            carry = (int)(cur / base);
            z[i] = (int)(cur % base);
        }
        trim();
    }

    // Multiply by small int (return new bigint)
    bigint operator*(int v) const {
        bigint res = *this;
        res *= v;
        return res;
    }

    // Division with remainder (long division), returns (quotient, remainder)
    friend pair<bigint, bigint> divmod(const bigint& a1, const bigint& b1) {
        int norm = base / (b1.z.back() + 1);   // normalization factor
        bigint a = a1.abs() * norm;            // scale up to make division stable
        bigint b = b1.abs() * norm;
        bigint q, r;
        q.z.resize(a.z.size());

        // process digits from most significant to least
        for (int i = (int)a.z.size() - 1; i >= 0; i--) {
            r *= base;
            r += a.z[i];

            int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;
            int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;

            // estimate digit
            int d = ((long long)s1 * base + s2) / b.z.back();
            r -= b * d;

            // fix if we overestimated
            while (r < 0) r += b, --d;

            q.z[i] = d;
        }

        q.sign = a1.sign * b1.sign;
        r.sign = a1.sign;
        q.trim();
        r.trim();
        return make_pair(q, r / norm); // unnormalize remainder
    }

    // Integer square root (not used in this task, but part of bigint lib)
    friend bigint sqrt(const bigint& a1) {
        bigint a = a1;
        while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0);

        int n = (int)a.z.size();

        int firstDigit = (int)std::sqrt((double)a.z[n - 1] * base + a.z[n - 2]);
        int norm = base / (firstDigit + 1);
        a *= norm;
        a *= norm;
        while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0);

        bigint r = (long long)a.z[n - 1] * base + a.z[n - 2];
        firstDigit = (int)std::sqrt((double)a.z[n - 1] * base + a.z[n - 2]);
        int q = firstDigit;
        bigint res;

        for (int j = n / 2 - 1; j >= 0; j--) {
            for (;; --q) {
                bigint r1 =
                    (r - (res * 2 * base + q) * q) * base * base +
                    (j > 0 ? (long long)a.z[2 * j - 1] * base + a.z[2 * j - 2]
                           : 0);
                if (r1 >= 0) {
                    r = r1;
                    break;
                }
            }
            res *= base;
            res += q;

            if (j > 0) {
                int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;
                int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;
                int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;
                q = ((long long)d1 * base * base + (long long)d2 * base + d3) /
                    (firstDigit * 2);
            }
        }

        res.trim();
        return res / norm;
    }

    // Bigint division / remainder
    bigint operator/(const bigint& v) const { return divmod(*this, v).first; }
    bigint operator%(const bigint& v) const { return divmod(*this, v).second; }

    // Divide by small int
    void operator/=(int v) {
        if (v < 0) sign = -sign, v = -v;
        for (int i = (int)z.size() - 1, rem = 0; i >= 0; --i) {
            long long cur = z[i] + rem * (long long)base;
            z[i] = (int)(cur / v);
            rem = (int)(cur % v);
        }
        trim();
    }

    bigint operator/(int v) const {
        bigint res = *this;
        res /= v;
        return res;
    }

    // Mod by small int
    int operator%(int v) const {
        if (v < 0) v = -v;
        int m = 0;
        for (int i = (int)z.size() - 1; i >= 0; --i) {
            m = (z[i] + m * (long long)base) % v;
        }
        return m * sign;
    }

    // Compound ops
    void operator+=(const bigint& v) { *this = *this + v; }
    void operator-=(const bigint& v) { *this = *this - v; }
    void operator*=(const bigint& v) { *this = *this * v; }
    void operator/=(const bigint& v) { *this = *this / v; }

    // Comparisons
    bool operator<(const bigint& v) const {
        if (sign != v.sign) return sign < v.sign;
        if (z.size() != v.z.size()) return z.size() * sign < v.z.size() * v.sign;
        for (int i = (int)z.size() - 1; i >= 0; i--) {
            if (z[i] != v.z[i]) return z[i] * sign < v.z[i] * sign;
        }
        return false;
    }
    bool operator>(const bigint& v) const { return v < *this; }
    bool operator<=(const bigint& v) const { return !(v < *this); }
    bool operator>=(const bigint& v) const { return !(*this < v); }
    bool operator==(const bigint& v) const { return !(*this < v) && !(v < *this); }
    bool operator!=(const bigint& v) const { return *this < v || v < *this; }

    // Remove leading zeros and fix sign for zero
    void trim() {
        while (!z.empty() && z.back() == 0) z.pop_back();
        if (z.empty()) sign = 1;
    }

    bool isZero() const { return z.empty() || (z.size() == 1 && !z[0]); }

    // Unary minus
    bigint operator-() const {
        bigint res = *this;
        res.sign = -sign;
        return res;
    }

    // Absolute value
    bigint abs() const {
        bigint res = *this;
        res.sign *= res.sign; // makes sign positive
        return res;
    }

    // Convert to long long (unsafe if too large; used only in helpers)
    long long longValue() const {
        long long res = 0;
        for (int i = (int)z.size() - 1; i >= 0; i--) res = res * base + z[i];
        return res * sign;
    }

    friend bigint gcd(const bigint& a, const bigint& b) {
        return b.isZero() ? a : gcd(b, a % b);
    }
    friend bigint lcm(const bigint& a, const bigint& b) {
        return a / gcd(a, b) * b;
    }

    // Read from decimal string
    void read(const string& s) {
        sign = 1;
        z.clear();
        int pos = 0;
        while (pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')) {
            if (s[pos] == '-') sign = -sign;
            ++pos;
        }
        for (int i = (int)s.size() - 1; i >= pos; i -= base_digits) {
            int x = 0;
            for (int j = max(pos, i - base_digits + 1); j <= i; j++)
                x = x * 10 + s[j] - '0';
            z.push_back(x);
        }
        trim();
    }

    friend istream& operator>>(istream& stream, bigint& v) {
        string s;
        stream >> s;
        v.read(s);
        return stream;
    }

    friend ostream& operator<<(ostream& stream, const bigint& v) {
        if (v.sign == -1) stream << '-';
        stream << (v.z.empty() ? 0 : v.z.back());
        for (int i = (int)v.z.size() - 2; i >= 0; --i)
            stream << setw(base_digits) << setfill('0') << v.z[i];
        return stream;
    }

    // Convert digits between different decimal chunk sizes (helper for Karatsuba)
    static vector<int> convert_base(const vector<int>& a, int old_digits, int new_digits) {
        vector<long long> p(max(old_digits, new_digits) + 1);
        p[0] = 1;
        for (int i = 1; i < (int)p.size(); i++) p[i] = p[i - 1] * 10;
        vector<int> res;
        long long cur = 0;
        int cur_digits = 0;
        for (int i = 0; i < (int)a.size(); i++) {
            cur += a[i] * p[cur_digits];
            cur_digits += old_digits;
            while (cur_digits >= new_digits) {
                res.push_back(int(cur % p[new_digits]));
                cur /= p[new_digits];
                cur_digits -= new_digits;
            }
        }
        res.push_back((int)cur);
        while (!res.empty() && res.back() == 0) res.pop_back();
        return res;
    }

    typedef vector<long long> vll;

    // Karatsuba multiplication on equal-size vectors of base 1e6 digits
    static vll karatsubaMultiply(const vll& a, const vll& b) {
        int n = (int)a.size();
        vll res(n + n);
        if (n <= 32) {
            // schoolbook for small n
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    res[i + j] += a[i] * b[j];
            return res;
        }

        int k = n >> 1;
        vll a1(a.begin(), a.begin() + k);
        vll a2(a.begin() + k, a.end());
        vll b1(b.begin(), b.begin() + k);
        vll b2(b.begin() + k, b.end());

        vll a1b1 = karatsubaMultiply(a1, b1);
        vll a2b2 = karatsubaMultiply(a2, b2);

        // (a1+a2)*(b1+b2)
        for (int i = 0; i < k; i++) a2[i] += a1[i];
        for (int i = 0; i < k; i++) b2[i] += b1[i];

        vll r = karatsubaMultiply(a2, b2);
        // subtract a1b1 and a2b2 to get cross terms
        for (int i = 0; i < (int)a1b1.size(); i++) r[i] -= a1b1[i];
        for (int i = 0; i < (int)a2b2.size(); i++) r[i] -= a2b2[i];

        // assemble final result
        for (int i = 0; i < (int)r.size(); i++) res[i + k] += r[i];
        for (int i = 0; i < (int)a1b1.size(); i++) res[i] += a1b1[i];
        for (int i = 0; i < (int)a2b2.size(); i++) res[i + n] += a2b2[i];
        return res;
    }

    // Full bigint * bigint using Karatsuba via base conversion to 1e6
    bigint operator*(const bigint& v) const {
        vector<int> a6 = convert_base(this->z, base_digits, 6);
        vector<int> b6 = convert_base(v.z, base_digits, 6);
        vll a(a6.begin(), a6.end());
        vll b(b6.begin(), b6.end());

        // pad to equal size
        while (a.size() < b.size()) a.push_back(0);
        while (b.size() < a.size()) b.push_back(0);

        // pad to power of two for Karatsuba
        while (a.size() & (a.size() - 1)) a.push_back(0), b.push_back(0);

        vll c = karatsubaMultiply(a, b);

        bigint res;
        res.sign = sign * v.sign;

        // carry normalize in base 1e6
        for (int i = 0, carry = 0; i < (int)c.size(); i++) {
            long long cur = c[i] + carry;
            res.z.push_back((int)(cur % 1000000));
            carry = (int)(cur / 1000000);
        }

        // convert back to base 1e9
        res.z = convert_base(res.z, 6, base_digits);
        res.trim();
        return res;
    }
};

// Problem inputs
int n, m, k;
vector<int> a;

void read() {
    cin >> n >> m >> k;
    a.resize(n);
    cin >> a;
}

// A state encodes one chosen subset as two ordered index lists: negatives and non-negatives.
struct State {
    vector<int> pos_indices; // indices chosen from non-negative part
    vector<int> neg_indices; // indices chosen from negative part

    // boundaries used to validate neighbor moves
    int pos_lo, pos_hi;
    int neg_lo, neg_hi;

    // cached product for heap comparisons (mutable for lazy caching)
    mutable bigint cached_product;
    mutable bool has_cache;

    State(vector<int> pos, vector<int> neg, int pl, int ph, int nl, int nh)
        : pos_indices(pos),
          neg_indices(neg),
          pos_lo(pl), pos_hi(ph),
          neg_lo(nl), neg_hi(nh),
          has_cache(false) {}

    // Compute product of chosen elements (bigint), with caching.
    bigint compute_product() const {
        if (!has_cache) {
            cached_product = 1;
            for (int idx: neg_indices) cached_product *= a[idx];
            for (int idx: pos_indices) cached_product *= a[idx];
            has_cache = true;
        }
        return cached_product;
    }

    // Ordering for set<State>: compare vectors lexicographically to uniquely identify subset.
    bool operator<(const State& other) const {
        if (neg_indices != other.neg_indices) return neg_indices < other.neg_indices;
        return pos_indices < other.pos_indices;
    }
};

// Comparator for priority_queue: max-heap by product
struct StateComparator {
    bool operator()(const State& a, const State& b) const {
        // priority_queue puts "largest" on top, so we define "a has lower priority than b"
        return a.compute_product() < b.compute_product();
    }
};

// Create an initial extreme state for a fixed number of negatives.
State create_initial_state(int num_negs, int split) {
    bool minimize_abs = (num_negs % 2 == 0);

    int num_pos = m - num_negs;
    vector<int> pos_indices(num_pos);
    vector<int> neg_indices(num_negs);

    int pos_lo, pos_hi, neg_lo, neg_hi;

    if (minimize_abs) {
        // Even number of negatives => product tends to be non-negative.
        // Code chooses:
        // - positives: the largest ones (from end of array)
        for (int i = 0; i < num_pos; i++) pos_indices[i] = n - 1 - i;
        pos_lo = split; pos_hi = n;

        // - negatives: the "closest to zero" negatives (from start of array, since sorted ascending)
        for (int i = 0; i < num_negs; i++) neg_indices[i] = i;
        neg_lo = 0; neg_hi = split;
    } else {
        // Odd number of negatives => product negative.
        // Code chooses:
        // - positives: the smallest non-negative ones (closest to zero)
        for (int i = 0; i < num_pos; i++) pos_indices[i] = split + i;
        pos_lo = split; pos_hi = n;

        // - negatives: the most negative ones (largest magnitude, near split-1)
        for (int i = 0; i < num_negs; i++) neg_indices[i] = split - 1 - i;
        neg_lo = 0; neg_hi = split;
    }

    return State(pos_indices, neg_indices, pos_lo, pos_hi, neg_lo, neg_hi);
}

void solve() {
    // Sort values to make subset neighbor moves meaningful/monotone-ish.
    sort(a.begin(), a.end());

    // Find split point between negatives and non-negatives
    int split = 0;
    while (split < n && a[split] < 0) split++;

    int total_pos = n - split;
    int total_neg = split;

    // visited stores already enqueued/popped subsets to avoid duplicates.
    set<State> visited;

    // max-heap by product
    priority_queue<State, vector<State>, StateComparator> pq;

    // Initialize one starting state for each feasible number of negatives
    for (int num_negs = 0; num_negs <= m; num_negs++) {
        int num_pos = m - num_negs;
        if (num_negs > total_neg || num_pos > total_pos) continue;

        State initial = create_initial_state(num_negs, split);
        if (visited.find(initial) == visited.end()) {
            visited.insert(initial);
            pq.push(initial);
        }
    }

    // Pop states in descending product order; the k-th popped is the answer.
    for (int step = 0; step < k && !pq.empty(); step++) {
        State current = pq.top();
        pq.pop();

        // If this is the k-th (1-indexed) state, output its product.
        if (step == k - 1) {
            cout << current.compute_product() << '\n';
            return;
        }

        // Generate neighbors by moving one chosen positive index by ±1 (depending on ordering).
        for (int i = 0; i < (int)current.pos_indices.size(); ++i) {
            // Determine direction: if vector is increasing, move up (+1), else down (-1).
            bool moving_up = (current.pos_indices[0] < current.pos_indices.back());

            int cur_val = current.pos_indices[i];
            int new_val = moving_up ? cur_val + 1 : cur_val - 1;

            // Next index in the list is an upper (or lower) limit to keep strict order
            int limit = (i + 1 < (int)current.pos_indices.size())
                            ? current.pos_indices[i + 1]
                            : (moving_up ? current.pos_hi : current.pos_lo - 1);

            // Check that new_val does not cross next index (or boundary)
            bool valid = moving_up ? (new_val < limit) : (new_val > limit);

            if (valid) {
                State neighbor = current;          // copy current state
                neighbor.pos_indices[i] = new_val; // apply move
                neighbor.has_cache = false;        // invalidate cached product
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    pq.push(neighbor);
                }
            }
        }

        // Generate neighbors by moving one chosen negative index similarly.
        for (int i = 0; i < (int)current.neg_indices.size(); ++i) {
            // If empty it's irrelevant; else decide direction by ordering
            bool moving_up =
                current.neg_indices.empty() ||
                (current.neg_indices[0] < current.neg_indices.back());

            int cur_val = current.neg_indices[i];
            int new_val = moving_up ? cur_val + 1 : cur_val - 1;

            int limit = (i + 1 < (int)current.neg_indices.size())
                            ? current.neg_indices[i + 1]
                            : (moving_up ? current.neg_hi : current.neg_lo - 1);

            bool valid = moving_up ? (new_val < limit) : (new_val > limit);

            if (valid) {
                State neighbor = current;
                neighbor.neg_indices[i] = new_val;
                neighbor.has_cache = false;
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    pq.push(neighbor);
                }
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    for (int test = 1; test <= T; test++) {
        read();
        solve();
    }
    return 0;
}
```

---

## 4) Python solution (same approach, with detailed comments)

Python has built-in big integers, so we don’t need a custom `bigint`. We will implement the same state expansion with a heap and a visited set.

```python
import sys
import heapq
from dataclasses import dataclass

# We will store products as Python int (unbounded precision).


@dataclass(frozen=True)
class Key:
    """Immutable key used for visited-set membership."""
    neg: tuple
    pos: tuple


class State:
    """
    Mutable state stored in heap:
    - neg_indices, pos_indices are lists of chosen indices
    - boundaries define valid ranges for index moves
    - product is computed once and stored
    """
    __slots__ = ("neg_indices", "pos_indices",
                 "neg_lo", "neg_hi", "pos_lo", "pos_hi",
                 "prod")

    def __init__(self, neg_indices, pos_indices, neg_lo, neg_hi, pos_lo, pos_hi, prod):
        self.neg_indices = neg_indices
        self.pos_indices = pos_indices
        self.neg_lo = neg_lo
        self.neg_hi = neg_hi
        self.pos_lo = pos_lo
        self.pos_hi = pos_hi
        self.prod = prod  # cached product (Python int)

    def key(self):
        return Key(tuple(self.neg_indices), tuple(self.pos_indices))


def create_initial_state(a, n, m, split, num_negs):
    """
    Mirrors the C++ create_initial_state logic.
    """
    minimize_abs = (num_negs % 2 == 0)
    num_pos = m - num_negs

    if minimize_abs:
        # positives: largest values at end
        pos_indices = [n - 1 - i for i in range(num_pos)]
        # negatives: from start
        neg_indices = [i for i in range(num_negs)]
    else:
        # positives: smallest non-negatives
        pos_indices = [split + i for i in range(num_pos)]
        # negatives: near split-1 backward
        neg_indices = [split - 1 - i for i in range(num_negs)]

    neg_lo, neg_hi = 0, split
    pos_lo, pos_hi = split, n

    # compute product
    prod = 1
    for idx in neg_indices:
        prod *= a[idx]
    for idx in pos_indices:
        prod *= a[idx]

    return State(neg_indices, pos_indices, neg_lo, neg_hi, pos_lo, pos_hi, prod)


def solve():
    it = iter(sys.stdin.read().strip().split())
    n = int(next(it)); m = int(next(it)); k = int(next(it))
    a = [int(next(it)) for _ in range(n)]

    a.sort()

    # split point: first non-negative
    split = 0
    while split < n and a[split] < 0:
        split += 1

    total_neg = split
    total_pos = n - split

    # Python heapq is a min-heap, so to simulate max-heap we push (-prod, counter, state).
    heap = []
    visited = set()
    counter = 0  # ensures tie-breaking without comparing State objects

    # Push initial states for all feasible numbers of negatives
    for num_negs in range(m + 1):
        num_pos = m - num_negs
        if num_negs > total_neg or num_pos > total_pos:
            continue
        st = create_initial_state(a, n, m, split, num_negs)
        key = st.key()
        if key not in visited:
            visited.add(key)
            heapq.heappush(heap, (-st.prod, counter, st))
            counter += 1

    # Pop k times
    for step in range(k):
        if not heap:
            break
        negprod, _, cur = heapq.heappop(heap)
        if step == k - 1:
            print(cur.prod)
            return

        # Generate neighbors by moving one pos index by ±1, maintaining strict order
        if cur.pos_indices:
            moving_up = cur.pos_indices[0] < cur.pos_indices[-1]
            for i in range(len(cur.pos_indices)):
                cur_val = cur.pos_indices[i]
                new_val = cur_val + 1 if moving_up else cur_val - 1

                if i + 1 < len(cur.pos_indices):
                    limit = cur.pos_indices[i + 1]
                else:
                    limit = cur.pos_hi if moving_up else cur.pos_lo - 1

                valid = (new_val < limit) if moving_up else (new_val > limit)
                if not valid:
                    continue

                # Build neighbor state (copy lists)
                pos2 = cur.pos_indices[:]
                pos2[i] = new_val

                # recompute product cheaply by dividing/multiplying (exact division holds)
                prod2 = cur.prod // a[cur_val] * a[new_val]

                nb = State(cur.neg_indices[:], pos2,
                           cur.neg_lo, cur.neg_hi, cur.pos_lo, cur.pos_hi,
                           prod2)
                key = nb.key()
                if key not in visited:
                    visited.add(key)
                    heapq.heappush(heap, (-nb.prod, counter, nb))
                    counter += 1

        # Generate neighbors by moving one neg index similarly
        if cur.neg_indices:
            moving_up = cur.neg_indices[0] < cur.neg_indices[-1]
            for i in range(len(cur.neg_indices)):
                cur_val = cur.neg_indices[i]
                new_val = cur_val + 1 if moving_up else cur_val - 1

                if i + 1 < len(cur.neg_indices):
                    limit = cur.neg_indices[i + 1]
                else:
                    limit = cur.neg_hi if moving_up else cur.neg_lo - 1

                valid = (new_val < limit) if moving_up else (new_val > limit)
                if not valid:
                    continue

                neg2 = cur.neg_indices[:]
                neg2[i] = new_val

                prod2 = cur.prod // a[cur_val] * a[new_val]

                nb = State(neg2, cur.pos_indices[:],
                           cur.neg_lo, cur.neg_hi, cur.pos_lo, cur.pos_hi,
                           prod2)
                key = nb.key()
                if key not in visited:
                    visited.add(key)
                    heapq.heappush(heap, (-nb.prod, counter, nb))
                    counter += 1


if __name__ == "__main__":
    solve()
```

Notes:
- Python’s `int` handles huge products directly.
- We update product incrementally (`prod2 = prod // old * new`) to avoid recomputing `m` multiplications each time.
- This assumes `a[cur_val]` divides `prod` exactly, which is true because it’s a factor of the product.

---

## 5) Compressed editorial

- Sort array, split into negatives and non-negatives.
- For each feasible count `x` of negatives (`0..m`), create an “extreme” initial subset of `x` negatives and `m-x` non-negatives (choice depends on parity of `x`).
- Treat each subset as a state holding chosen indices; product is computed (bigint) and cached.
- Use a max-heap keyed by product; pop the current best subset, and push its `O(m)` neighbors obtained by shifting one chosen index by ±1 while keeping indices distinct and within bounds.
- Use a visited set keyed by `(neg_indices, pos_indices)` to avoid duplicates.
- After popping `k` states, the last popped product is the k-th largest.