p340.ans1
======================
<i>a</i>
<i>a</i>&nbsp;-&nbsp;(<i>v</i>&nbsp;-&nbsp;<i>b</i>)
<i>a</i><sub><i>i</i></sub>&nbsp;+&nbsp;<i>b</i><sub>2</sub>
<i>B</i><sup><i>k</i><sub><i>i</i></sub></sup>

=================
p340.in1
======================
$a$
$a - (v - b)$
$a_i + b_2$
$B^{k_i}$ 

=================
p340.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

string line;

bool readline(istream& in, string& s) { return (bool)getline(in, s); }

void read() {
    if(!readline(cin, line)) {
        exit(0);
    }
}

void parse(const string& s, string& out) {
    vector<pair<const char*, bool>> close_stack;
    int n = s.size();
    for(int i = 0; i < n; i++) {
        char c = s[i];
        if(c == '{') {
            if(!close_stack.empty()) {
                close_stack.back().second = false;
            }
            continue;
        }
        if(c == '}') {
            if(!close_stack.empty()) {
                out += close_stack.back().first;
                close_stack.pop_back();
            }
            continue;
        }

        bool is_sup_sub = (c == '^' || c == '_');
        if(is_sup_sub) {
            out += (c == '^') ? "<sup>" : "<sub>";
            close_stack.push_back({(c == '^') ? "</sup>" : "</sub>", true});
            continue;
        }

        if(isalpha(c)) {
            out += "<i>";
            while(i < n && isalpha(s[i])) {
                out += s[i++];
            }
            out += "</i>";
            i--;
        } else if(c == '+' || c == '-' || c == '*' || c == '/') {
            out += "&nbsp;";
            out += c;
            out += "&nbsp;";
        } else {
            out += c;
        }

        while(!close_stack.empty() && close_stack.back().second) {
            out += close_stack.back().first;
            close_stack.pop_back();
        }
    }
}

void solve() {
    // This is mostly a parsing exercise.

    string s;
    for(char c: line) {
        if(isalnum(c) || c == '+' || c == '-' || c == '*' || c == '/' ||
           c == '^' || c == '_' || c == '{' || c == '}' || c == '(' ||
           c == ')') {
            s += c;
        }
    }
    string out;
    out.reserve(s.size() * 8);
    parse(s, out);
    cout << out << "\n";
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    while(true) {
        read();
        solve();
    }

    return 0;
}

=================
statement.txt
======================
340. TeX2HTML
Time limit per test: 0.5 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



Andrew just finished writing his thesis. That was a big work and now Andrew wants some remarks from his friends. He thinks the best way to share the paper is to post it to his blog. Andrew wrote his thesis in the TeX format and now he needs to convert them to HTML. Please help Andrew to implement the most essential part of the converter—the mathematical formulas converter.

Andrew's formulas are always enclosed in the dollar signs. They contain Latin letters, digits, parentheses, white spaces, binary operators "+-*/", superscripts and subscripts. You should ignore all white spaces.

Superscripts are written using the cap character "^" and braces "{}". The part of the formula inside the braces is the superscript itself. You may assume that only non-whitespace character will follow the cap character. If the superscript contains only one character, the braces can be omitted. The superscript will not be followed by another superscript or subscript. E.g. "a^2" means a2; "2^{2 + 2}" means 22 + 2.

Subscripts are written using the underline character "_" and braces "{}". The part of the formula inside the braces is the subscript itself. You may assume that only non-whitespace character will follow the underline character. If the subscript contains only one character, the braces can be omitted. The subscript will not be followed by another subscript or superscript. E.g. "x_i" means xi and "P_{n+1-i}" means Pn+1-i.

Your program should produce HTML-like output using the following rules. Each letter should be italicized using "<i>" open tag and "</i>" close tag. These tags should enclose each maximal sequence of letters (don't forget to ignore white spaces). Each binary operator should be surrounded by the non-breaking spaces "&nbsp;". Superscripts should be enclosed in "<sup>" and "</sup>" tags. Subscripts should be enclosed in "</sub>" and "</sub>" tags.

You may assume that input will contain correct mathematical formula with only binary operators.

Input
The input file will contain several test cases. Each test case is a line with two dollar signs with the formula between them. No extra characters will appear on the line.

The input file size is less than 128 KB.

Output
Print the HTML version of each formula on a separate line.

Example(s)
sample input
sample output
a

a - (v - b)

ai + b2

Bki 
<i>a</i>

<i>a</i>&nbsp;-&nbsp;(<i>v</i>&nbsp;-&nbsp;<i>b</i>)

<i>a</i><sub><i>i</i></sub>&nbsp;+&nbsp;<i>b</i><sub>2</sub>

<i>B</i><sup><i>k</i><sub><i>i</i></sub></sup> 


=================
