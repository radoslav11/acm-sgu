p240.in1
======================
4 4 10 4 1
1 2 1 0 1
1 3 2 1 0
1 4 3 0 1
2 3 4 2 2
3

=================
p240.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

const int64_t inf = 1e18;

int n, m, h, s, e;
vector<int> exits;

struct Edge {
    int to, t, r, p;
};

vector<vector<Edge>> adj;

void read() {
    cin >> n >> m >> h >> s >> e;
    adj.resize(n + 1);
    for(int i = 0; i < m; i++) {
        int a, b, t, r, p;
        cin >> a >> b >> t >> r >> p;
        adj[a].push_back({b, t, r, p});
        adj[b].push_back({a, t, r, p});
    }
    exits.resize(e);
    cin >> exits;
}

pair<bool, vector<int>> check(int64_t x) {
    vector<int64_t> dist(n + 1, inf);
    vector<int> parent(n + 1, -1);
    vector<bool> visited(n + 1, false);

    dist[s] = 0;

    for(int i = 0; i < n; i++) {
        int u = -1;
        for(int v = 1; v <= n; v++) {
            if(!visited[v] && (u == -1 || dist[v] < dist[u])) {
                u = v;
            }
        }

        if(u == -1 || dist[u] == inf) {
            break;
        }
        visited[u] = true;

        for(auto& [to, t, r, p]: adj[u]) {
            int64_t heat = r + (dist[u] + t) * (int64_t)p;
            if(heat <= x) {
                int64_t new_dist = dist[u] + t;
                if(new_dist < dist[to]) {
                    dist[to] = new_dist;
                    parent[to] = u;
                }
            }
        }
    }

    int best_exit = -1;
    for(int ex: exits) {
        if(dist[ex] < inf) {
            best_exit = ex;
            break;
        }
    }

    if(best_exit == -1) {
        return {false, {}};
    }

    vector<int> path;
    int cur = best_exit;
    while(cur != -1) {
        path.push_back(cur);
        cur = parent[cur];
    }
    reverse(path.begin(), path.end());

    return {true, path};
}

void solve() {
    // Let's binary search for the answer X. This means that we can now only
    // pass through a road (u, v) at time t, if r(u, v) + (t + time(u, v)) *
    // p(u, v) <= X. We want to figure out if there is a valid path from S to
    // any of the exists that satisfies this.
    //
    // The core observation is that after we have settled on X, we are
    // interested in the lowest time t we reach any vertex u. This can be done
    // with a Dijkstra, but by only allowing edges that don't violate the X
    // constraint. Note that the graph could be dense, so we opt for the
    // quadratic Dijkstra implementation.
    //
    // The time complexity is overall O(N^2 log MAX).

    int low = 0, high = h, mid, ret = -1;
    vector<int> best_path;

    while(low <= high) {
        mid = (low + high) / 2;
        auto [ok, path] = check(mid);
        if(ok) {
            ret = mid;
            best_path = path;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }

    if(ret == -1) {
        cout << "NO\n";
    } else {
        cout << "YES\n";
        cout << ret << "\n";
        cout << best_path.size() << " " << best_path << "\n";
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
p240.ans1
======================
3
3 4 1 3

=================
statement.txt
======================
240. Runaway
time limit per test: 0.25 sec.
memory limit per test: 16384 KB
input: standard
output: standard



Damn!... How it can be happened to you - one of the best agents of FBI? You were imprisoned for crime; you were even not able to do. "Spy, traitor, murderer", they said. It sounds banal, but you were tripped up by some secret terroristical organization, and your friends (oh: ex-friends, I mean) didn't want to help you. You are alone: and it seems to be no ways to exit. There are only thick lead walls around you. You are in underground prison. Wait: what's happening? You hear screams and explosions nearby. What a hell!?... <Darkness over you and you lose consciousness>
You wake up and look around you. Doorlock of your cell is seriously damaged, so you can open the door easily. Wait: what a strange heat? You look into corridor and quickly realize situation. Prison was attacked from air by napalm-bomber. Napalm is still over prison, but it quickly burns its road down. The temperature everywhere in prison is slowly raising, in different parts of prison speed of heating is not the same, but everywhere it is non-negative value. You know, that corridors of a prison have toral shape. It was offered by D. Kurov scientist just to check his geometry skills. But it does not matter to you, and the only thing, important to you now, is that there are several exits from this prison. Fortunately, you know the map of prison (it is on the wall of corridor, marked as "Evacuation Plan"). Also you know the approximate points of falling napalm bombs (you heard that information in moment of losing consciousness from internal prison communicator), so you can predict speeds of heat growing for all corridors. You have already got evacuation fire-resistant suit which can resist heat of H degrees Centigrade (if temperature is greater than H, your character will die). You must construct a way to get out from prison in such a manner such that maximal heat of your suit on this way is minimal possible (temperature of suit is always equal to current temperature in corridor).
Prison consists of M corridors and N corridor junctions. Also E of N junctions are exits, and you are initially located at junction number S (junctions are numbered from 1 to N). Corridors have their initial heat Ri, and non-negative speed of heat raising Pi (in degrees by second), also corridors have lengths Ti - time you need to run over them (in seconds). You must consider that junctions always have temperature 0.

Input
On first line of input file there are only numbers N, M, H, S and E (1<=N<=100; 1<=S,E<=N; 1<=M,H<=10000). Next M lines describe prison corridors, I-th line of them containing numbers Ai, Bi, Ti, Ri and Pi, where A and B are numbers of junctions, connected by corresponding corridor (1<=Ai,Bi<=N; 1<=Ti<=10000; 0<=Ri,Pi<=10000; Ai<>Bi). At next line there are exactly E numbers Fi - numbers of junctions, which are exits (1<=Fi<=N). There are no multiple corridors between any two junctions. All corridors are two-sided. All numbers are integers.

Output
On the first line must be exactly one word "YES" (if you can stay alive and get out from prison) or "NO" (in other case). In case of positive answer, second line of output file must contain maximal heat of suit on the best way, then on the third line there must be the best way itself (if there are many best ways, you can output any one of them) in form: Z - number of junctions in the way, then Z numbers - numbers of junctions in best way in order of passing it (start junction assumed to be passed, even if you make no moves).

Sample test(s)

Input
4 4 10 4 1
1 2 1 0 1
1 3 2 1 0
1 4 3 0 1
2 3 4 2 2
3

Output
YES
3
3 4 1 3

=================
