1. **Abridged problem statement**

You are given:

- An integer \(N\) (1 ≤ N ≤ 3).
- Positive integers \(c[1], \dots, c[N]\) (1 ≤ \(c[i]\) ≤ 10^6).
- A positive integer \(V\) (1 ≤ V ≤ 10^6).

You must find non‑negative integers \(x[1], \dots, x[N]\) such that:

\[
c_1 x_1 + c_2 x_2 + \dots + c_N x_N = V
\]

and the sum

\[
f = x_1 + x_2 + \dots + x_N
\]

is minimized.

Output the minimal possible value of \(f\), or -1 if no such non‑negative integer solution exists.


---

2. **Detailed editorial**

### 2.1. Reformulation

We want to solve:

- Minimize \(x_1 + \dots + x_N\)
- Subject to: \(c_1 x_1 + \dots + c_N x_N = V\)
- With: \(x_i \in \mathbb{Z}_{\ge 0}\), \(N \le 3\)

This is exactly the *unbounded coin change* problem with:

- coin denominations: \(c[i]\)
- value to make: \(V\)
- cost of each coin: 1

We want the **minimum number of coins** to make total value \(V\) (or say impossible).

### 2.2. Constraints and feasibility of DP

- \(N \le 3\) (very small)
- \(V \le 10^6\) (up to one million)

A standard dynamic programming solution for coin change has:

- dp[v] = minimum coins to obtain value v
- Time: \(O(N \cdot V)\) → at most \(3 \cdot 10^6\), perfectly fine in 0.25s in C++.
- Memory: dp has size \(V+1\) (~1,000,001 ints) → fine.

We don’t need anything fancier (e.g. number theory, diophantine analysis) because this DP is easily fast enough and simple.

### 2.3. DP definition

Let `dp[v]` be:

- `dp[v]` = minimum number of coins (variables) needed to get sum `v`
- If impossible, `dp[v] = INF` (some very large number, like `INT_MAX`).

Base case:

- `dp[0] = 0` (you need 0 coins to form value 0)

Transition:

To compute `dp[v]` for v ≥ 1:

For each coin type i:

- If we can use coin `c[i]` (i.e., `v >= c[i]`) and forming `v - c[i]` is possible (`dp[v - c[i]] != INF`), then:

  `dp[v] = min(dp[v], dp[v - c[i]] + 1)`

Because using coin `c[i]` to reach `v` means we use one coin plus the optimal way to form `v - c[i]`.

Answer:

- If `dp[V]` is still `INF`, then no combination of coins yields V → print `-1`
- Otherwise print `dp[V]`.

### 2.4. Correctness argument

1. **Feasibility and coverage**

   We fill `dp[v]` from `v = 0` up to `V`.  
   For every v, dp[v] is derived from some dp[v - c[i]] where `v - c[i] >= 0`. With dp[0] initialized as 0, dynamic programming ensures that if there exists any multiset of coins summing to v, we can build v iteratively from 0 upward.

2. **Optimality**

   The recurrence:

   \[
   dp[v] = \min_{i: v \ge c[i], dp[v - c[i]] \ne INF} (dp[v - c[i]] + 1)
   \]

   always takes the minimum over all one-step extensions from a smaller achievable sum `v - c[i]`. Because:

   - Each valid combination for v ends with choosing some coin `c[i]` that leaves a sum `v - c[i]`.
   - The optimal combination for `v - c[i]` uses `dp[v - c[i]]` coins.
   - Adding one more coin yields total coins `dp[v - c[i]] + 1`.

   Hence dp[v] is the minimum number of coins over all possible ways to achieve v.

3. **Equivalence to original problem**

   Each variable \(x_i\) represents the number of times we choose coin \(c[i]\). The constraint

   \[
   \sum c_i x_i = V
   \]

   exactly matches forming value V from coins `c[i]` with unlimited multiplicity (since \(x_i\) are non‑negative integers).

   The objective function

   \[
   f = \sum x_i
   \]

   is the total number of coins used. Our DP minimizes this number. Therefore the DP solution is exactly the minimum value of the original objective function over all feasible integer assignments.

### 2.5. Edge cases

- **No solution**: If gcd of all `c[i]` does not divide V, then no solution exists. The DP naturally outputs `INF` for `dp[V]`; we print -1.
- **Single coin type (N = 1)**:
  - Feasible only if `V % c[1] == 0`; then answer is `V / c[1]`. DP will compute that correctly as repeated use of coin `c[1]`.
- **V smaller than all c[i]**:
  - Then no v ≥ 1 will get updated; `dp[V]` stays `INF` → output -1.
- **Big values of `c[i]` (up to 10^6)**:
  - Still ok because we only go up to v = V, and `v >= c[i]` ensures we never index negative values.

### 2.6. Complexity

- Time: \(O(N \cdot V) \le 3 \cdot 10^6\) primitive operations.
- Memory: \(O(V)\) integers (~4–8 MB), fit easily into 64 MB.

This fits comfortably within the given limits.


---

3. **C++ solution with detailed comments**

Below is the provided C++ code, augmented with line‑by‑line comments.

```cpp
#include <bits/stdc++.h>   // Includes most standard C++ headers in one go

using namespace std;

// Overload operator<< to print a pair<T1, T2>
template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    // Print "first second"
    return out << x.first << ' ' << x.second;
}

// Overload operator>> to read a pair<T1, T2>
template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    // Read into first and second
    return in >> x.first >> x.second;
}

// Overload operator>> to read a vector<T>
template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    // Read all elements in order
    for (auto& x: a) {
        in >> x;
    }
    return in;
};

// Overload operator<< to print a vector<T>
template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    // Print all elements separated by spaces
    for (auto x: a) {
        out << x << ' ';
    }
    return out;
};

int n;          // Number of variables / coin types
vector<int> c;  // Coefficients c[i] (coin denominations)
int V;          // Target value to achieve

// Read input according to the problem specification
void read() {
    cin >> n;             // Read N
    c.resize(n);          // Resize vector c to N elements
    cin >> c;             // Read all N coefficients into c
    cin >> V;             // Read target value V
}

void solve() {
    // Dynamic programming for unbounded coin change:
    //   dp[v] = minimal number of coins needed to get total value v
    //   or INT_MAX if not possible.

    // Initialize dp array with size V+1 (0..V), all set to INT_MAX
    vector<int> dp(V + 1, INT_MAX);

    // Base case: 0 coins needed to obtain sum 0
    dp[0] = 0;

    // Compute dp[v] for all v from 1 to V
    for (int v = 1; v <= V; v++) {
        // Try using each coin type c[i]
        for (int i = 0; i < n; i++) {
            // We can only use coin c[i] if v >= c[i]
            // and if the remainder v - c[i] is achievable (dp[v - c[i]] != INT_MAX)
            if (v >= c[i] && dp[v - c[i]] != INT_MAX) {
                // If using c[i] gives a better (smaller) coin count, update dp[v]
                dp[v] = min(dp[v], dp[v - c[i]] + 1);
            }
        }
    }

    // After filling dp, check if dp[V] is still INT_MAX (i.e., unreachable)
    if (dp[V] == INT_MAX) {
        // No solution exists; print -1
        cout << -1 << endl;
    } else {
        // Solution exists; print the minimal number of coins
        cout << dp[V] << endl;
    }
}

int main() {
    ios_base::sync_with_stdio(false); // Turn off sync with C streams for speed
    cin.tie(nullptr);                 // Untie cin from cout for faster I/O

    int T = 1;                        // Number of test cases (here fixed to 1)
    // cin >> T;                      // Could be used if multiple tests

    for (int test = 1; test <= T; test++) {
        read();                       // Read input for this test
        // cout << "Case #" << test << ": ";
        solve();                      // Compute and output answer
    }

    return 0;                         // Successful termination
}
```

---

4. **Python solution with detailed comments**

```python
import sys

def main():
    data = sys.stdin.read().strip().split()
    # Use an iterator to consume tokens in order
    it = iter(data)

    # Read N
    n = int(next(it))
    # Read coefficients c[0..n-1]
    c = [int(next(it)) for _ in range(n)]
    # Read target value V
    V = int(next(it))

    # We solve the unbounded coin change problem:
    # dp[v] = minimum number of coins needed to form value v
    # If impossible, dp[v] will remain as a large sentinel (INF)

    INF = 10**18  # A large number to represent "infinity"
    dp = [INF] * (V + 1)

    # Base case: sum 0 can be formed with 0 coins
    dp[0] = 0

    # For each value v from 1 to V, compute dp[v]
    for v in range(1, V + 1):
        # Try using each coin denomination c[i]
        for coin in c:
            if v >= coin:
                # If dp[v - coin] is not INF, then v - coin is achievable
                prev = dp[v - coin]
                if prev != INF:
                    # One more coin than the best way to get v - coin
                    cand = prev + 1
                    if cand < dp[v]:
                        dp[v] = cand

    # After filling dp, check if V is reachable
    if dp[V] == INF:
        # No combination of c[i] sums to V
        print(-1)
    else:
        # Print minimal number of coins = minimal sum of x[i]
        print(dp[V])

if __name__ == "__main__":
    main()
```

**Notes on the Python version:**

- It mirrors the C++ logic exactly.
- Time complexity is still \(O(N \cdot V)\). For N ≤ 3 and V ≤ 10^6, this is borderline but typically acceptable in CP Python if implemented tightly; if needed, small optimizations (like reordering loops to iterate coins outside and v inside) can help.
- Memory usage: dp is of length V+1; about 8 MB for Python integers, which is fine for most judges.


---

5. **Compressed editorial**

We must minimize \(x_1 + \dots + x_N\) subject to \(\sum c_i x_i = V\), \(x_i \ge 0\), \(N \le 3\), \(V \le 10^6\). This is exactly the minimum‑coin unbounded coin change problem with denominations \(c[i]\) and target V.

Define `dp[v]` = minimum number of coins to make value v, or `INF` if impossible. Initialize `dp[0] = 0`, others to `INF`. For `v` from 1 to V, for each coin `c[i]`, if `v >= c[i]` and `dp[v - c[i]] != INF`, update:

`dp[v] = min(dp[v], dp[v - c[i]] + 1)`.

At the end, if `dp[V] == INF`, output -1 (no feasible integer solution). Otherwise output `dp[V]`, which equals \(\min \sum x_i\) over all integer solutions of \(\sum c_i x_i = V\). Complexity: `O(N * V) ≤ 3 * 10^6` operations and `O(V)` memory, well within limits.