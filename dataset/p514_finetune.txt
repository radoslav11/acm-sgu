<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

514. Polygon
Time limit per test: 1.25 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard

You are given lengths of sides of some polygon. You must find the infimum of the possible areas of simple polygons with such side lengths. Infimum of a set of real numbers A is the exact upper bound of the set L of all real numbers y such that for any x ∈ A holds y ≤ x.

A simple polygon is a polygon without self-intersections and self-touchings.

Input
The first line contains integer n, 3 ≤ n ≤ 10 — the number of sides of the polygon. The second line contains n integers a1, a2,..., an, such that  for any 1 ≤ i ≤ n (this means that there exists a simple polygon with sides a1, a2,..., an. Also, 1 ≤ ai ≤ 100.

Output
Output one real number — the answer to the problem. Your answer will be considered correct if absolute or relative error is less than 10-6.

Example(s)
sample input
sample output
3
3 4 5
6.0000000000

sample input
sample output
4
8 4 3 5
4.4721359550

sample input
sample output
10
5 5 5 5 5 5 5 5 5 5
0.0000000000

<|response|>
1. Abridged Problem Statement  
   You are given n side lengths a₁,…,aₙ (3 ≤ n ≤ 10, 1 ≤ aᵢ ≤ 100), and you know at least one simple (non-self-intersecting) polygon exists with these sides. Find the infimum (greatest lower bound) of the areas of all such simple polygons. Output it with absolute or relative error ≤10⁻⁶.

2. Key Observations  
   - Any simple polygon whose edges in order are vectors v₁, v₂,…,vₙ can be continuously “flattened” so that many edges align into three directions, shrinking the area toward that of a triangle.  
   - Concretely, partition the n sides into three “super-edges” X, Y, Z (in cyclic order) and choose for each side whether it contributes +aᵢ or –aᵢ to its assigned super-edge’s total length. Let x, y, z be the signed sums.  
   - If the triple (|x|,|y|,|z|) satisfies the triangle inequalities, it defines a (possibly degenerate) triangle whose area can be computed by Heron’s formula. As you vary all assignments, the minimal triangle area you can achieve equals the infimum area of the original polygon problem.  
   - Since n≤10, we can afford a brute-force search over all 6ⁿ assignments (each side has 3 groups × 2 signs).

3. Full Solution Approach  
   a. Read n and the array a of side lengths.  
   b. Define a recursive function dfs(i, x, y, z) that processes sides from index i to n–1, keeping current signed sums x,y,z.  
   c. If i==n, check whether |x|,|y|,|z| can form a valid triangle (triangle inequalities).  
      – If yes, compute area via Heron’s formula:  
        s = (A+B+C)/2;  area = √[s(s–A)(s–B)(s–C)] with A=|x|,B=|y|,C=|z|.  
      – Otherwise return +∞.  
   d. Otherwise (i<n), let ℓ = a[i]. Recurse on six possibilities:  
      dfs(i+1, x+ℓ, y, z), dfs(i+1, x–ℓ, y, z), dfs(i+1, x, y+ℓ, z), …, dfs(i+1, x, y, z–ℓ).  
   e. Track the minimum returned area. That minimum is the answer.  
   f. Print it with fixed precision. If no valid triangle ever arises, the infimum is zero (all assignments invalid means you can collapse to area=0).

4. C++ Implementation with Detailed Comments  
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
vector<int> a;
// We will carry a global best to avoid passing large values around
double bestArea;

// Compute triangle area by Heron's formula
double heron(double A, double B, double C) {
    double s = (A + B + C) * 0.5;
    return sqrt(max(0.0, s * (s - A) * (s - B) * (s - C)));
}

// DFS over side index i, signed sums x,y,z
void dfs(int i, int x, int y, int z) {
    if (i == n) {
        // All sides assigned. Check triangle inequalities on |x|,|y|,|z|
        double A = fabs(x), B = fabs(y), C = fabs(z);
        if (A + B >= C && B + C >= A && C + A >= B) {
            // Valid or degenerate triangle
            double area = heron(A, B, C);
            bestArea = min(bestArea, area);
        }
        return;
    }
    int len = a[i];
    // Assign this side to super-edge X (+/-)
    dfs(i + 1, x + len, y, z);
    dfs(i + 1, x - len, y, z);
    // Assign to Y
    dfs(i + 1, x, y + len, z);
    dfs(i + 1, x, y - len, z);
    // Assign to Z
    dfs(i + 1, x, y, z + len);
    dfs(i + 1, x, y, z - len);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    a.resize(n);
    for (int &v : a) cin >> v;

    // Initialize bestArea with a large number
    bestArea = 1e18;
    // Start DFS with zero sums
    dfs(0, 0, 0, 0);

    // If bestArea was never updated, we can achieve zero area
    if (bestArea > 1e17) bestArea = 0.0;

    // Print with 10 decimal places
    cout << fixed << setprecision(10) << bestArea << "\n";
    return 0;
}
```

5. Python Implementation with Detailed Comments  
```python
import sys
sys.setrecursionlimit(10**7)
from math import sqrt

# Read input
n = int(sys.stdin.readline())
a = list(map(int, sys.stdin.readline().split()))

# Heron's formula for triangle area
def heron(A, B, C):
    s = 0.5 * (A + B + C)
    val = s * (s - A) * (s - B) * (s - C)
    # Numerical safety
    return sqrt(max(0.0, val))

best = float('inf')

# Recursively assign side i to super-edges X, Y, or Z with +/−
def dfs(i, x, y, z):
    global best
    if i == n:
        A, B, C = abs(x), abs(y), abs(z)
        # Check triangle inequality
        if A + B >= C and B + C >= A and C + A >= B:
            area = heron(A, B, C)
            if area < best:
                best = area
        return
    length = a[i]
    # Try six options
    dfs(i+1, x + length, y, z)
    dfs(i+1, x - length, y, z)
    dfs(i+1, x, y + length, z)
    dfs(i+1, x, y - length, z)
    dfs(i+1, x, y, z + length)
    dfs(i+1, x, y, z - length)

# Kick off recursion
dfs(0, 0, 0, 0)

# If never updated, infimum is zero
if best == float('inf'):
    best = 0.0

# Output result
print(f"{best:.10f}")
```