p428.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

void solve() {
    // The hard part in the problem is the uniqueness of the rebus solution.
    // However, this can be done by forcing one of the two numbers to be unique.
    // Let's take AA..AA, and assume that A will be mapped to 1. Then to
    // guarantee uniqueness, we also need to make sure the digits to letters are
    // not permutable. This can be done by making an ordering. In particular, we
    // want to use at least 9-1=8 different letters and add a condition of the
    // type A < B. This can be forced by having some digits where l[i] = A, r[i]
    // = letter, and result[i] = next(letter). We have to be careful about
    // buffers, so to guarantee this we will make sure l[i-1] = r[i-1] = A, and
    // result[i-1] = B. To make this concrete, let's take A-I. A corresponds to
    // 1, B to 2, C to 3 and so on until I to 9. We now need to place the 8
    // constraints. We can essentially create a string of length 8*2=16, where
    // odd positions are enforcing the no carry requirement, while even will
    // enforce the unique order of the letters. Then it's enough to just permute
    // the order of constraints.

    string perm = "ABCDEFGH";

    for(int steps = 0; steps < 1000; steps++) {
        next_permutation(perm.begin(), perm.end());

        string l, r, result;
        for(int i = 0; i < 8; i++) {
            l.push_back('A');
            l.push_back('A');
            r.push_back('A');
            r.push_back(perm[i]);
            result.push_back('B');
            result.push_back(perm[i] + 1);
        }
        cout << l << "+" << r << "=" << result << endl;
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
statement.txt
======================
428. Rebus
Time limit per test: 0.5 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard



An addition rebus is a puzzle where you get an addition equation, like ABC+CBA=BDB, and you're asked to replace each letter with a digit (from 0 through 9) in such a way that:
Equal letters are replaced with equal digits.
Different letters are replaced with different digits.
None of the resulting numbers starts with 0, unless the entire number is just 0.
The resulting equation holds.


A proper addition rebus is an addition rebus with exactly one solution. An aligned addition rebus is an addition rebus where all three involved numbers have the same length (number of digits). The above addition rebus is aligned, but isn't proper: 143+341=484 and 341+143=484 are its two possible different solutions (and there are more).

Find 1000 different proper aligned addition rebuses. Two rebuses are different if there is no one-to-one mapping from the set of 26 English letters on itself that transfers one of those rebuses into another. For example, ABC+CBA=BDB and XAY+YAX=AZA are not different, while ABC+CBA=BDB and ABC+DEF=GHI are different.

Input
The input file will be empty.

Output
Output any 1000 different proper aligned addition rebuses, one per line. Each rebus may only use capital English letters, symbols '+' and '='. Each rebus must be at most 100 characters long.

Example(s)
Note that this example output doesn't contain the required 1000 rebuses, it contains just two.

sample input
sample output
 
AABC+AABB=DBCB
RRR+TTR=EDT


=================
