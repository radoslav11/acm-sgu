p159.ans2
======================
2
1B3854
A08369

=================
p159.in2
======================
12 6

=================
p159.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

int b, n;

void read() { cin >> b >> n; }

void pop_carry(int pos, vector<int>& carry) {
    if(pos >= n || carry[pos] < b) {
        return;
    }

    int full = carry[pos] / b;
    carry[pos] %= b;
    if(pos + 1 < n) {
        carry[pos + 1] += full;
        pop_carry(pos + 1, carry);
    }
}

void rec(int pos, vector<int>& carry, vector<int>& x, vector<string>& ans) {
    if(pos == n) {
        string candidate = "";
        for(int i = n - 1; i >= 0; i--) {
            if(x[i] >= 10) {
                candidate.push_back(x[i] - 10 + 'A');
            } else {
                candidate.push_back(x[i] + '0');
            }
        }
        ans.push_back(candidate);
        return;
    }

    vector<int> carry_save = carry;
    for(int d = (pos == n - 1) && (n != 1); d < b; d++) {
        x.push_back(d);
        if((carry[pos] + (1 + (pos != 0)) * x[0] * x[pos]) % b != x[pos]) {
            x.pop_back();
            continue;
        }

        for(int j = 0; j <= pos; j++) {
            int val = (1 + (pos != j)) * x[pos] * x[j];
            if(pos + j < n) {
                carry[j + pos] += val;
            }
            pop_carry(pos + j, carry);
        }

        if(carry[pos] == x[pos]) {
            rec(pos + 1, carry, x, ans);
        }

        carry = carry_save;
        x.pop_back();
    }
}

void solve() {
    // The first thing we should notice is that the solution wants us to
    // output all self-replicating numbers. This should immediately suggest
    // looking at brute force solutions. In particular, the number of such
    // numbers is likely not very high. Let us start with considering how
    // a self-replicating number would. Let X = SUM x[i] * b^i. Then we have:
    //
    //     X^2 = X   (mod b^n)
    //     (SUM x[i] * b^i) * (SUM x[i] * b^i) = X   (mod b^n)
    //     SUM x[i] * x[j] * b^(i + j) = X   (mod b^n)
    //
    // In particular, we can notice that all terms with i+j >= n get ignored
    // because of mod b^n. Furthermore, if we start building X from i = 0, we
    // can notice that we can incrementally add the contribution with the
    // previous digits. Lets do a brute force starting from i = 0 and going,
    // where we will keep carry[k] for each b^k. We will try every possible
    // value for x[i], but we know that for i > 0 it should satisfy that:
    //
    //     (carry[i] + 2 * x[i] * x[0]) = x[i]   (mod b)
    //     carry[i] = (1 - 2 * x[0]) * x[i]   (mod b)
    //
    // Most importantly, this means that there are either 0 or 1 solutions after
    // i = 0. The constraint is b <= 36, so we don't have to be careful about
    // quickly finding x[i], but this makes the brute force viable - after
    // choosing x[0] the number is determined (if it's possible).

    vector<int> carry(n, 0), x;
    vector<string> ans;
    rec(0, carry, x, ans);

    cout << ans.size() << endl;
    for(int i = 0; i < (int)ans.size(); i++) {
        cout << ans[i] << endl;
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
p159.ans1
======================
1
9376

=================
statement.txt
======================
159. Self-Replicating Numbers
time limit per test: 0.5 sec.
memory limit per test: 65536 KB
input: standard input
output: standard output



Vasya's younger brother Misha is fond of playing with numbers. Two days ago he discovered that 9376^2 = 87909376 - the last four digits constitute 9376 again. He called such numbers self-replicating.
More precisely, an n-digit number is called self-replicating if it is equal to the number formed by the last n digits of its square. Now Misha often asks Vasya to help him to find new such numbers. To make the things worse, Vasya's brother already knows what the scales of notation are, so he asks Vasya to find, for example, hexadecimal or binary self-replicating numbers.
Vasya wants to help his brother, but unfortunately he is very busy now: he is seriously preparing and training for the next ACM Regional Contest. So he asked you to write a program that for a given base b and length n will find all n-digit self-replicating numbers in the scale of notation with base b.

Input
The only line of the input contains two integer numbers b and n separated by a single space, the base b of the scale of notation (2 <= b <= 36) and the required length n (1 <= n <= 2000).

Output
The first line of the output contains K - the total number of self-replicating numbers of length n in base b. Next K lines contain one n-digit number in base b each. Uppercase Latin letters from A to Z must be used to represent digits from 10 to 35. The self-replicating numbers can be listed in arbitrary order.

Sample test(s)

Input
Sample input #1
10 4

Sample input #2
12 6

Output
Sample output #1
1
9376

Sample output #2
2
1B3854
A08369

Note
Author:	Nikolay Durov
Resource:	ACM ICPC 2002-2003 NEERC, Northern Subregion
Date:	November, 2002

=================
p159.in1
======================
10 4

=================
