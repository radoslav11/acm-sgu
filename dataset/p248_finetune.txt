<|instruction|>
Solve the below problem. The solution should start with an abridged problem statement. Then key observations. Then full solution based on the observations. Then C++ and Python implementations with comments.

248. Integer Linear Programming
time limit per test: 0.25 sec.
memory limit per test: 65536 KB
input: standard
output: standard



You are to solve some problem of integer linear programming. It is posed in the following way. Let x[i] be a variable which is required to be a non-negative integer (for any i from [1..N]). The goal is to minimize the function f(x[1], x[2],..., x[N])=x[1]+x[2]+...+x[N] (objective function) satisfying the constraint c[1]*x[1]+c[2]*x[2]+...+c[N]*x[N]=V.
The point X=(x[1], x[2],..., x[N]) that satisfies the constraint is called "feasible". All feasible points form a feasible set.
To make things clear, let us consider the following example N=2, c[1]=2, c[2]=4, V=6. There are only two feasible points: (1, 1) and (3, 0).
Clearly, the point (1, 1) is the optimal solution, because f(1, 1)<f(3, 0).

Input
The first line of input contains a single positive integer N (0<N<=3). The second line contains N positive integers c[i] separated by whitespaces (0<c[i]<=10^6). The last line contains positive integer V (0<V<=10^6).

Output
On the first line of the output file print the minimal possible value of the function f, or "-1" (without quotes) if the problem has no solution.

Sample test(s)

Input
Test #1
2
2 4
6

Test #2
2
7 4
9

Output
Test #1
2

Test #2
-1

<|response|>
1. **Abridged problem statement**

You are given:

- An integer \(N\) (1 ≤ N ≤ 3),
- Positive integers \(c[1], \dots, c[N]\) (1 ≤ \(c[i]\) ≤ 10^6),
- A target value \(V\) (1 ≤ V ≤ 10^6).

Find non‑negative integers \(x[1], \dots, x[N]\) such that

\[
c_1 x_1 + c_2 x_2 + \dots + c_N x_N = V
\]

and the sum

\[
f = x_1 + x_2 + \dots + x_N
\]

is minimized.

Output the minimal possible value of \(f\), or -1 if there is no such solution.


---

2. **Key observations**

1. The equation
   \[
   c_1 x_1 + \dots + c_N x_N = V,\quad x_i \in \mathbb{Z}_{\ge 0}
   \]
   is exactly the situation where you have coin denominations \(c[i]\) and you want to make value \(V\) using any number of each coin.

2. The objective
   \[
   f = x_1 + \dots + x_N
   \]
   is simply the total number of coins used.

   So this is precisely the classic **unbounded coin change problem**:
   - Denominations = \(c[1..N]\),
   - Target sum = \(V\),
   - Cost of each coin = 1,
   - Minimize the number of coins.

3. Constraints are small:
   - \(N \le 3\),
   - \(V \le 10^6\).

   This allows a standard dynamic programming (DP) solution with complexity \(O(N \cdot V) \le 3 \cdot 10^6\), which is efficient within the time and memory limits.

4. A solution may not exist (e.g., denominations 7 and 4, target 9). Our method must detect and report -1 in that case.

5. There is no need for advanced number theory or linear programming methods; the DP for coin change is straightforward and sufficient.


---

3. **Full solution approach**

We solve it via 1D DP for unbounded coin change.

### 3.1 DP definition

Let `dp[v]` be the minimum number of coins needed to obtain total value `v`.

- If `v` cannot be formed from the given denominations, set `dp[v] = INF` (a very large number representing “impossible”).

We want `dp[V]`. If it is `INF`, there is no solution. Otherwise, it equals the minimal value of \(x_1 + \dots + x_N\).

### 3.2 Initialization

- Array size: `dp[0..V]`.
- Set:
  - `dp[0] = 0` (0 coins needed to make sum 0),
  - `dp[v] = INF` for all `v > 0`.

### 3.3 Transition

For each `v` from 1 to `V`:

- Try each coin `c[i]` (i = 1..N):
  - If `v >= c[i]` and `dp[v - c[i]]` is not `INF` (i.e., `v - c[i]` can be formed),
    then we can form `v` by adding one coin `c[i]` to a best solution for `v - c[i]`.

So:

\[
dp[v] = \min_{i: v \ge c[i]} \left( dp[v - c[i]] + 1 \right)
\]

Implementation-wise:

```cpp
dp[v] = min(dp[v], dp[v - c[i]] + 1);
```

whenever the left side is valid.

### 3.4 Final answer

After filling the DP:

- If `dp[V]` is still `INF` → print `-1` (no solution),
- Else → print `dp[V]`.

This `dp[V]` is exactly the minimum number of coins, which matches the minimum sum \(x_1 + \dots + x_N\).

### 3.5 Correctness (sketch)

- **Feasibility:**  
  We build solutions incrementally from 0 up to V. Any achievable sum can be formed by repeatedly adding coins to smaller achievable sums, which the DP explores.

- **Optimality:**  
  For each `v`, we consider all last coins that could be used to form `v`. For each coin `c[i]`, we optimally form `v - c[i]` and add 1. By taking the minimum over all i, we obtain the minimal number of coins to form `v`.

- **Equivalence to original ILP problem:**  
  Each \(x_i\) is “how many times we use coin \(c[i]\)”. The constraint \(\sum c_i x_i = V\) is exactly forming \(V\) with those coins, and the objective \(\sum x_i\) is the number of coins. So the coin-change optimum equals the ILP optimum.

### 3.6 Complexity

- Time: \(O(N \cdot V)\), with \(N \le 3\), \(V \le 10^6\) → at most ~3 million simple operations.
- Memory: `dp` size `V + 1` → about 1e6 integers (a few MB).

Well within the given limits.


---

4. **C++ implementation with detailed comments**

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    if (!(cin >> N)) {
        return 0; // No input
    }

    vector<int> c(N);
    for (int i = 0; i < N; ++i) {
        cin >> c[i];      // Read coefficients / coin denominations
    }

    int V;
    cin >> V;             // Target value

    // We will use a large value as "infinity" to represent "impossible".
    // INT_MAX might overflow when we add 1 to it, so we subtract some margin.
    const int INF = INT_MAX / 2;

    // dp[v] = minimal number of coins to make sum v
    // If dp[v] == INF, then v is not reachable.
    vector<int> dp(V + 1, INF);

    // Base case: to make sum 0, we need 0 coins.
    dp[0] = 0;

    // Compute dp[v] for all v from 1 to V
    for (int v = 1; v <= V; ++v) {
        // Try each coin type
        for (int i = 0; i < N; ++i) {
            int coin = c[i];
            if (v >= coin) {              // We can use this coin
                if (dp[v - coin] + 1 < dp[v]) {
                    dp[v] = dp[v - coin] + 1;
                }
            }
        }
    }

    // If dp[V] is INF, we couldn't form V from the given coins.
    if (dp[V] >= INF) {
        cout << -1 << '\n';
    } else {
        cout << dp[V] << '\n';
    }

    return 0;
}
```

Notes on the C++ version:

- Uses `INT_MAX / 2` to avoid overflow when doing `dp[v - coin] + 1`.
- Single test case (as in the problem).
- Time complexity and memory usage fit comfortably in constraints.


---

5. **Python implementation with detailed comments**

```python
import sys

def main():
    data = sys.stdin.read().strip().split()
    if not data:
        return

    it = iter(data)

    # Read N
    N = int(next(it))
    # Read coefficients / coin denominations
    c = [int(next(it)) for _ in range(N)]
    # Read target V
    V = int(next(it))

    # A large sentinel value to represent "infinity" (impossible state)
    INF = 10**18

    # dp[v] = minimal number of coins to make sum v
    dp = [INF] * (V + 1)
    dp[0] = 0  # Base case: need 0 coins to make sum 0

    # Outer loop over v or over coins are both valid.
    # With N <= 3 and V <= 1e6, either order is fine.
    for v in range(1, V + 1):
        for coin in c:
            if v >= coin:
                prev = dp[v - coin]
                if prev + 1 < dp[v]:
                    dp[v] = prev + 1

    # Check if V is reachable
    if dp[V] >= INF:
        print(-1)
    else:
        print(dp[V])

if __name__ == "__main__":
    main()
```

Notes on the Python version:

- Mirrors the C++ logic.
- Uses a large integer `INF` to mark unreachable sums.
- Complexity is still \(O(N \cdot V)\); with N ≤ 3 this is acceptable in most Python environments for V up to 1e6, especially with simple loops and no overhead from function calls.