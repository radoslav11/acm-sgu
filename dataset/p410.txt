## 1) Abridged problem statement

There are **N planets**, planet *i* initially has **a[i]** mistkafers.

Each day you must choose exactly one action:

- **Flying mission:** all N pferds fly; each planet must give **1** mistkafer (so all **a[i] ≥ 1**), then all counts decrease:  
  `a[i] := a[i] - 1` for all i.
- **Science mission to planet j:** no flight that day; instead clone on planet j:  
  `a[j] := 2 * a[j]`.

Goal: make all `a[i] = 0` in the **minimum number of days**.  
Output that minimum **K**; if `K ≤ 1000`, also output a valid day-by-day plan.

Constraints: `1 ≤ N ≤ 1e5`, `1 ≤ a[i] ≤ 1e9`.

---

## 2) Detailed editorial (explaining the provided solution idea)

### Key reframing
A flying mission is equivalent to **subtracting 1 from every planet simultaneously**, but it is only allowed while all planets are positive.

A science mission is **multiply one chosen planet by 2**.

We need the minimum number of days (operations) to reach all zeros.

---

### Step 1: You need at least `M = max(a[i])` flying days
Let `M = max(a[i])`. Consider the planet that initially has `M`.

- The **only** operation that decreases a planet is **flying** (subtract 1).
- Cloning only increases.

So to reduce that max planet from `M` to `0`, we need **at least `M`** flying missions.

Thus, answer `K ≥ M`.

The solution sets `ans = M` and plans to do exactly `M` flying days.

So the question becomes: can we ensure that **every other planet** still has enough mistkafers to survive `M` flying days (i.e., be ≥1 at each of the first M flights), possibly by inserting cloning days?

---

### Step 2: What must each planet achieve?
If we perform exactly `M` flights, then each planet must start those flights with at least `M` mistkafers (because it loses 1 per flight and must never hit 0 early).

So for each planet with initial `x = a[i] < M`, we must add some science days (doublings) so that its count becomes **at least M** before (or by some point during) the flight sequence.

However, cloning days pause flying, so they add to total days. We want the **fewest** cloning days overall.

---

### Step 3: Optimal way to “synchronize” a planet with the maximum
Suppose a planet has current value `x` (initially `a[i]`), and the global maximum is `M` (we plan to do `M` flights total).

We would like to make this planet reach **exactly M** at some moment *right before* a flying mission begins, without ever creating a new maximum beyond M (creating a new maximum would increase required number of flights).

A clever trick:

If at some time we have:
- planet value is `x`
- remaining number of flights is such that the “target maximum” is still `M` (we’re not changing M)

If we do `s` flying missions first, then both the planet and the max decrease by `s`:
- planet becomes `x - s`
- max becomes `M - s`

Now if we clone (double) once:
- planet becomes `2(x - s)`

We want:
\[
2(x - s) = M - s
\]
Solve:
\[
2x - 2s = M - s \Rightarrow s = 2x - M
\]

So if `s = 2x - M` is feasible (i.e., `0 ≤ s ≤ x`), then:
- wait (fly) exactly `s` days,
- then clone once,
and the planet becomes perfectly aligned with the maximum trajectory: after that, it will stay “in sync” and never be the reason flights must stop early.

**Feasibility condition:** `0 ≤ 2x - M ≤ x`.

If this holds, we need **exactly 1 clone** for this planet (at the right time).

---

### Step 4: If not feasible, double early until it becomes feasible
If `x` is too small, `2x - M < 0`. Then we cannot find a nonnegative `s`.

In that case, we should clone **immediately** (before any flights) to increase `x`:
- `x := 2x`
- count one more day

Repeat until `x` becomes big enough that `2x - M >= 0`, i.e. `x >= M/2`.

Once `x >= M/2`, one final well-timed clone will be enough to match M (because then `s = 2x - M` becomes ≥ 0, and also `s ≤ x` will hold automatically when `x ≤ M` (and we never want to exceed M with repeated doubling, we stop as soon as we can do the timed clone).

So per planet:
- do some number of **pre-doublings** (immediate science days) to get `x` closer to M,
- then schedule **one last clone** at day `s` (after `s` flights), where `s = 2x - M`.

This is what the code does.

---

### Step 5: Why is the total number of days minimal?
- We already argued **at least `M` flights** are necessary.
- For each planet with `x < M`, it must increase at least up to `≥ M` at some point. The only way is doubling.
- The strategy above uses the **minimum number of doublings** per planet:
  - you double only while `x < M/2` (each such doubling is unavoidable because after any number of flights, both x and M decrease together, so the ratio doesn’t improve in your favor; the only way to make `2x - M` nonnegative is to increase x).
  - once `x >= M/2`, **one** additional clone suffices (and you can’t do it with zero clones because x < M).
- Also, it never creates a new maximum beyond M, so `M` flights remain enough.

Thus total days = `M + (number of science missions)` is minimal.

---

### Constructing the plan (when K ≤ 1000)
The code outputs:
1) all **pre-ops** science missions first (these happen before any flights).
2) then for each flight day `i = 0..M-1`:
   - perform any scheduled science missions whose computed `s` equals `i` (meaning: do them right before the (i+1)-th flight),
   - then output `"flying mission"`.

That exactly matches the intended timing.

Complexities:
- Each planet is doubled at most `O(log M)` times, so total work is fine for `N=1e5`.
- Memory and time fit easily.

---

## 3) Provided C++ solution with detailed line-by-line comments

```cpp
#include <bits/stdc++.h>
using namespace std;

// Pretty-print for pairs (not actually used in this solution).
template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

// Read pairs (not actually used).
template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

// Read an entire vector: for each element, read from stream.
template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for (auto& x: a) {
        in >> x;
    }
    return in;
};

// Print a vector (not actually used).
template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for (auto x: a) {
        out << x << ' ';
    }
    return out;
};

int n;                 // number of planets
vector<int64_t> a;     // mistkafers per planet (64-bit because values can grow by doubling)

void read() {
    cin >> n;
    a.resize(n);
    cin >> a;          // uses the overloaded operator>> above
}

void solve() {
    // Let M be the maximum initial amount. We need at least M flying missions
    // because the planet with M must be decremented M times.
    int64_t M = *max_element(a.begin(), a.end());
    int64_t ans = M;   // start answer with M flights; we will add science days

    // ops[t] will store planets that must be cloned right before the (t+1)-th flight,
    // i.e. after exactly t flights have already happened.
    // We only need to store detailed plan if answer <= 1000. This array size is
    // limited to 1024 to avoid huge memory when M is large; storing is conditional anyway.
    vector<vector<int>> ops(min(M, 1024ll));

    // pre_ops stores planets that we clone at the very beginning (before any flights).
    vector<int> pre_ops;

    // Process each planet independently and decide how many doubles are needed.
    for (int i = 0; i < n; i++) {
        int64_t x = a[i];   // current amount on this planet

        // If x < M, it cannot survive M flights unless we clone it.
        while (x < M) {
            // If after s flights we clone once, we want:
            // 2*(x - s) == (M - s)  =>  s = 2*x - M
            int64_t s = 2 * x - M;

            // If s is feasible (0 <= s <= x), we can schedule ONE final clone
            // at time s (after s flights). That will align this planet with M.
            if (s >= 0 && s <= x) {
                ans++; // this scheduled clone consumes one day

                // If we might output the plan (ans <= 1000), store this operation
                // in ops[s]. The code conservatively checks s <= 1000.
                if (0 <= s && s <= 1000) {
                    ops[s].push_back(i + 1); // store 1-based planet index
                }
                break; // done with this planet
            }

            // Otherwise x is too small (typically x < M/2), so we clone immediately
            // (before flights) to increase it.
            pre_ops.push_back(i + 1); // record this early clone
            ans++;                    // one more day
            x *= 2;                   // perform the doubling
        }
    }

    // Output minimal number of days.
    cout << ans << endl;

    // If small enough, output an explicit schedule.
    if (ans <= 1000) {
        // First, all early doublings (science missions before any flights).
        for (int pos: pre_ops) {
            cout << "science mission to the planet " << pos << endl;
        }

        // Then we perform M flight-days.
        // Before each flight i, do any scheduled clones that must happen after i flights.
        for (int i = 0; i < M; ++i) {
            for (int pos: ops[i]) {
                cout << "science mission to the planet " << pos << endl;
            }
            cout << "flying mission" << endl;
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1; // single test
    for (int test = 1; test <= T; test++) {
        read();
        solve();
    }
    return 0;
}
```

---

## 4) Python solution (same approach, with detailed comments)

```python
import sys

def solve() -> None:
    data = sys.stdin.read().strip().split()
    n = int(data[0])
    a = list(map(int, data[1:1+n]))

    # M = maximum initial mistkafers.
    # At least M flying days are required to reduce that planet to 0.
    M = max(a)
    ans = M  # start with M flights, add science days as needed

    # If ans <= 1000 we must output a schedule.
    # We'll still compute operations, but only store those we might print.
    pre_ops = []  # planets cloned before any flights (1-based indices)

    # ops[s] = list of planets to clone after exactly s flights (i.e., before flight s+1)
    # Only meaningful when M is small; cap for safety.
    ops_cap = min(M, 1024)
    ops = [[] for _ in range(ops_cap)]

    for i, x0 in enumerate(a):
        x = x0
        # While planet's current value is below M, we need some doublings.
        while x < M:
            # If we fly s days, values become x-s and M-s.
            # One clone then makes this planet 2*(x-s). We want it to equal M-s:
            # 2*(x-s) = M-s  ->  s = 2x - M
            s = 2 * x - M

            # If s is feasible (0 <= s <= x), one scheduled clone at time s solves it.
            if 0 <= s <= x:
                ans += 1
                # Store only if it can be printed in a <=1000-day plan.
                if s <= 1000 and s < ops_cap:
                    ops[s].append(i + 1)  # store 1-based planet index
                break

            # Otherwise x is too small; clone immediately (before flights) and try again.
            pre_ops.append(i + 1)
            ans += 1
            x *= 2

    out_lines = [str(ans)]

    # If answer is small, output a concrete plan:
    if ans <= 1000:
        # First, all early science missions.
        for p in pre_ops:
            out_lines.append(f"science mission to the planet {p}")

        # Then M times: (optional scheduled science missions) + flying.
        for day in range(M):
            if day < ops_cap:
                for p in ops[day]:
                    out_lines.append(f"science mission to the planet {p}")
            out_lines.append("flying mission")

    sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
    solve()
```

---

## 5) Compressed editorial

- Let `M = max(a)`. The max planet can only decrease via flying, so at least `M` flying days are necessary ⇒ answer ≥ `M`.
- Plan to do exactly `M` flights; then each other planet must be “boosted” via doubling so it never hits 0 early.
- For a planet with value `x < M`, after `s` flights it becomes `x-s`, and max becomes `M-s`. If we clone then, it becomes `2(x-s)`. Choose `s` so `2(x-s)=M-s` ⇒ `s=2x-M`.
- If `s` is feasible (`0 ≤ s ≤ x`), one timed clone at that `s` makes the planet align with `M` and it will last all flights.
- If `2x-M < 0` (i.e., `x < M/2`), clone immediately (`x*=2`) until `x ≥ M/2`, then do the final timed clone.
- Total days = `M +` (number of clones), and this is minimal because `M` flights are unavoidable and the number of required doublings per planet is minimized by doubling only until it becomes possible to align with one final clone.
- If total ≤ 1000, output: all early clones, then for each `i=0..M-1` output clones scheduled at `i`, then a flying mission.