1) Abridged problem statement
- You are given N player heights (in meters), each in [1.95, 2.05], and their average is exactly 2.00 m.
- Arrange the players in a line so that for every contiguous segment, if H is the sum of heights in that segment and K is the number of players in it, then |H − 2.00·K| ≤ 0.10 m.
- Print “yes” and any valid permutation (1-based indices). Under these guarantees, a solution always exists.

2) Detailed editorial
- Reformulation:
  - Let di = hi − 2.00 (measured in meters). The problem’s condition becomes: for every contiguous segment, the sum of its di’s must be within [−0.10, 0.10].
  - Because the overall average is exactly 2.00, we have ∑i di = 0.
  - Each di ∈ [−0.05, 0.05] since hi ∈ [1.95, 2.05].

- Sufficient condition via prefix sums:
  - Let Sk be the prefix sum of the arranged sequence’s deviations: Sk = ∑t=1..k dpt (where p is the permutation).
  - If all prefix sums lie inside [−0.05, 0.05], then any subarray sum is the difference of two prefix sums, hence in [−0.10, 0.10]. Therefore the check always passes.

- Greedy construction:
  - Sort players by di (ascending). Maintain two pointers:
    - l at the most negative remaining deviation,
    - r at the most positive remaining deviation.
  - Maintain the running prefix sum S (start S = 0).
  - Repeat N times:
    - If S > 0, take the most negative remaining element (index l) to pull S down; increment l.
    - If S ≤ 0, take the most positive remaining element (index r) to pull S up; decrement r.

- Why it always works:
  - Existence of needed signs:
    - If S > 0 and there were no negative (or zero) elements left, then the sum of all remaining deviations would be ≥ 0, making the total sum > 0, contradicting ∑ di = 0. Hence when S > 0, a negative exists. Similarly, when S ≤ 0, a positive exists.
  - Bounding S:
    - When S > 0, we add some x ≤ 0 with x ≥ −0.05. Then S' = S + x ≤ S ≤ 0.05 and S' ≥ S − 0.05 > −0.05, so S' ∈ (−0.05, 0.05].
    - When S ≤ 0, we add some x ≥ 0 with x ≤ 0.05. Then S' = S + x ≥ S ≥ −0.05 and S' ≤ S + 0.05 ≤ 0.05, so S' ∈ [−0.05, 0.05].
  - Therefore every prefix sum stays within [−0.05, 0.05], and every subarray sum stays within [−0.10, 0.10].

- Complexity:
  - Sorting dominates: O(N log N) time, O(N) memory.

- Implementation notes:
  - Because input heights are integer micrometers, it’s safest to work in integer micrometers to avoid floating-point pitfalls, e.g., store di in micrometers: di = micrometers(hi) − 2,000,000 and use bounds ±50,000 for ±0.05 m and ±100,000 for ±0.10 m. The provided C++ uses doubles and still works under typical judge data.

3) Provided C++ solution with detailed line-by-line comments
#include <bits/stdc++.h>            // Pulls in most standard headers (GNU extension)
using namespace std;

// Stream output for pair<T1, T2> to print "first second"
template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

// Stream input for pair<T1, T2> to read into first and second
template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

// Stream input for vector<T>: read all elements sequentially
template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;                   // read each element
    }
    return in;
};

// Stream output for vector<T>: print elements separated by spaces
template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';           // print each element followed by a space
    }
    return out;
};

int n;                              // number of players
vector<double> a;                    // heights (in meters), later turned into deviations from 2.0

// Read input: n and the n heights
void read() {
    cin >> n;
    a.resize(n);
    cin >> a;                       // uses the overloaded operator>> for vector
}

void solve() {
    // We transform heights hi to deviations di = hi - 2.0 (meters).
    // The problem's check "|sum(hi) - 2.0*K| <= 0.10" for any contiguous segment
    // is equivalent to "|sum(di)| <= 0.10" for any contiguous segment.
    // It suffices to keep all prefix sums in [-0.05, 0.05], because the difference
    // of two prefix sums then lies in [-0.10, 0.10].
    // We can ensure this by greedy placement: always add an element that moves the
    // current prefix sum toward 0. Sort di ascending; keep two pointers:
    // - if sum > 0, take the most negative remaining element (left pointer),
    // - else take the most positive remaining element (right pointer).
    // Because the overall sum of di is 0 and each di is in [-0.05, 0.05], at each step
    // the needed sign exists and the new prefix sum stays in [-0.05, 0.05].

    for(auto& x: a) {
        x -= 2.0;                   // turn height into deviation from 2.0 m
    }

    vector<int> perm(n), ans;       // perm: indices 0..n-1; ans: resulting permutation (1-based)
    iota(perm.begin(), perm.end(), 0);                    // fill with 0,1,2,...,n-1
    sort(perm.begin(), perm.end(), [&](int i, int j) {    // sort indices by deviation ascending
        return a[i] < a[j];
    });

    double sum = 0.0;               // running prefix sum of deviations
    int l = 0, r = n - 1;           // two pointers: most negative at l, most positive at r
    for(int i = 0; i < n; i++) {
        if(sum > 0) {
            sum += a[perm[l++]];                // pull sum down: add most negative remaining
            ans.push_back(perm[l - 1] + 1);     // store 1-based original index
        } else {
            sum += a[perm[r--]];                // pull sum up: add most positive remaining
            ans.push_back(perm[r + 1] + 1);     // store 1-based original index
        }
    }

    cout << "yes\n";                 // under the given guarantees a solution always exists
    cout << ans << '\n';             // print permutation (overloaded operator<< prints spaces)
}

int main() {
    ios_base::sync_with_stdio(false);  // speed up C++ I/O
    cin.tie(nullptr);                  // untie cin from cout for faster input

    int T = 1;                         // number of test cases (here always 1)
    // cin >> T;                       // (kept as a template; unused)
    for(int test = 1; test <= T; test++) {
        read();                        // read one test case
        // cout << "Case #" << test << ": ";
        solve();                       // solve and print the answer
    }

    return 0;                          // normal termination
}

4) Python solution (well-commented)
import sys

def parse_micrometers(s):
    """
    Parse a decimal string s representing meters into integer micrometers.
    Assumes input heights are integer micrometers as per the statement.
    Examples:
      "2"    -> 2_000_000
      "1.95" -> 1_950_000
      "2.050000" -> 2_050_000
    """
    s = s.strip()
    neg = s.startswith('-')
    if neg:
        s = s[1:]
    if '.' in s:
        left, right = s.split('.', 1)
    else:
        left, right = s, ''
    # pad or truncate fractional part to 6 digits (micrometers)
    right = (right + '000000')[:6]
    microunits = int(left) * 1_000_000 + (int(right) if right else 0)
    return -microunits if neg else microunits

def main():
    data = sys.stdin.read().strip().split()
    if not data:
        return
    it = iter(data)
    n = int(next(it))
    heights = [next(it) for _ in range(n)]

    # Convert to integer micrometers and then to deviations from 2_000_000 μm (2.0 m)
    two_m_micros = 2_000_000
    deviations = []
    for idx, s in enumerate(heights):
        mic = parse_micrometers(s)
        deviations.append((mic - two_m_micros, idx + 1))  # store (deviation, 1-based index)

    # Sort by deviation ascending
    deviations.sort(key=lambda t: t[0])

    # Two-pointer greedy: keep prefix sum in [-50_000, 50_000]
    S = 0  # prefix sum of deviations, in micrometers
    l, r = 0, n - 1
    order = []
    for _ in range(n):
        if S > 0:
            d, idx = deviations[l]
            l += 1
        else:
            d, idx = deviations[r]
            r -= 1
        S += d
        order.append(idx)

    # Under problem guarantees, a solution always exists
    out = []
    out.append("yes")
    out.append(" ".join(map(str, order)))
    print("\n".join(out))

if __name__ == "__main__":
    main()

5) Compressed editorial
- Shift heights by 2.00: di = hi − 2.00. Goal: for all contiguous segments, |∑ di| ≤ 0.10.
- It suffices to keep all prefix sums within [−0.05, 0.05], since any segment sum is a difference of two prefixes.
- Sort di ascending and build the permutation greedily with two pointers:
  - If current prefix sum S > 0, append the most negative remaining element; else append the most positive.
- Because ∑ di = 0 and each di ∈ [−0.05, 0.05], this choice always exists and keeps S within [−0.05, 0.05].
- Complexity: O(N log N) due to sorting.