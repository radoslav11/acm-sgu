## 1) Abridged problem statement

Given an even integer \(n\) (\(6 \le n \le 100\)), place numbers \(1..n\) into \(n\) dartboard segments ordered as:
outer, inner, outer, inner, … around the circle.

Let the placed sequence be \(a_1, a_2, \dots, a_n\) (cyclically, so \(a_{n+1}=a_1\), \(a_{n+2}=a_2\)). Define risk

\[
R=\sum_{i=1}^{n}(a_i-a_{i+2})^2 + \sum_{i=1}^{n/2}(a_{2i-1}-a_{2i})^2.
\]

Output any permutation of \(1..n\) maximizing \(R\).

---

## 2) Detailed editorial (how to maximize the risk)

### A. Understanding the two kinds of adjacency
The risk has two parts:

1. **Same-layer neighbors around the circle**:  
   \(\sum_{i=1}^{n}(a_i-a_{i+2})^2\) compares segment \(i\) to \(i+2\).  
   Since indices go outer, inner, outer, inner, …, the jump by 2 keeps you on the **same layer**:
   - outer-to-next-outer
   - inner-to-next-inner

2. **Radial (outer-inner) neighbors**:  
   \(\sum_{i=1}^{n/2}(a_{2i-1}-a_{2i})^2\) compares each outer segment with its corresponding inner segment (a “spoke”).

So we want:
- big differences on every spoke (outer vs inner),
- and big differences along each ring (outer ring and inner ring).

Because the term is squared, “very different” is disproportionately better than “moderately different”.

---

### B. Greedy principle: pair extremes on spokes
For the spoke terms \((a_{2i-1}-a_{2i})^2\), the best is to pair small with large:
\[
(1,n), (2,n-1), (3,n-2), \dots
\]
These maximize the absolute differences per pair and thus maximize the squared differences locally.

So we decide that each spoke will contain one such extreme pair.

---

### C. The remaining job: arrange these extreme pairs around the circle
If we only maximize spoke differences, we could still do poorly on ring differences.  
Example: if outer numbers become \(1,2,3,4,\dots\), then adjacent outers differ by 1 → terrible for squared differences.

So after creating extreme pairs \((i, n-i+1)\), we must place them around the circle so that:
- outer ring alternates between low and high values as much as possible,
- inner ring also alternates between low and high values.

A convenient way is to build the final circular order by taking the remaining pairs and inserting them alternatingly to the **front** or **back**, sometimes inverted, to create strong alternation on both rings.

The provided solution:
- starts with the first spoke: \([1, n]\),
- then for each next pair \((x,y)=(i,n-i+1)\) (for \(i=2..n/2\)),
- applies a 4-step pattern (based on index mod 4) deciding:
  - push to back inverted,
  - push to front normal,
  - push to back normal,
  - push to front inverted.

This produces a “woven” arrangement where both outer and inner sequences oscillate between small and large values, increasing \((a_i-a_{i+2})^2\) terms as well, while preserving maximal spoke gaps.

This constructive approach is standard for this classic problem (CF 416B/416C-style constructive maximization); for \(n \le 100\), brute force isn’t needed.

---

### D. Complexity
We build a list of \(n\) numbers using \(O(n)\) operations.  
Time \(O(n)\), memory \(O(n)\).

---

## 3) Provided C++ solution with detailed comments

```cpp
#include <bits/stdc++.h>
using namespace std;

// Helper to print a pair (not actually used in final output)
template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

// Helper to read a pair (not used)
template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

// Helper to read a vector (not used)
template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for (auto& x : a) in >> x;
    return in;
};

// Helper to print a vector (not used)
template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for (auto x : a) out << x << ' ';
    return out;
};

int n;

void read() {
    cin >> n; // read even n
}

void solve() {
    // Idea:
    // 1) Make "spoke" pairs with maximal differences: (1,n), (2,n-1), ...
    // 2) Place these pairs around the circle so that same-layer neighbors
    //    (i and i+2) also have large differences.
    //
    // The algorithm fixes (1,n) first, then distributes the rest of the pairs
    // by pushing to front/back with a 4-step pattern and sometimes inverting
    // the pair order.

    // Build list of remaining extreme pairs (2,n-1), (3,n-2), ...
    list<pair<int,int>> pairs;
    for (int i = 2; 2 * i <= n; i++) {
        pairs.push_back({i, n - i + 1});
    }

    // Start answer with the first pair (1,n):
    // a1=1 (outer), a2=n (inner) for the first spoke.
    list<int> ans = {1, n};

    // We have (n/2 - 1) remaining pairs to place
    for (int idx = 0; idx < n / 2 - 1; idx++) {
        // Take next extreme pair
        auto [x, y] = pairs.front();
        pairs.pop_front();

        // Choose operation based on idx mod 4.
        // This pattern tends to alternate high/low on both rings.
        int op = idx % 4;

        if (op == 0) {
            // push to back, inverted: (y,x)
            ans.push_back(y);
            ans.push_back(x);
        } else if (op == 1) {
            // push to front, normal but note front insertion order:
            // first push x then y, but push_front reverses,
            // so to get [y,x,...] we do x then y.
            ans.push_front(x);
            ans.push_front(y);
        } else if (op == 2) {
            // push to back, normal: (x,y)
            ans.push_back(x);
            ans.push_back(y);
        } else {
            // op == 3: push to front, inverted (x,y) after reversal
            // We want the pair to appear as [x,y,...] at the front;
            // push_front(y) then push_front(x).
            ans.push_front(y);
            ans.push_front(x);
        }
    }

    // Output the constructed permutation
    for (auto x : ans) {
        cout << x << " ";
    }
    cout << "\n";
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;     // single test
    // cin >> T;    // (not used)
    for (int test = 1; test <= T; test++) {
        read();
        solve();
    }
    return 0;
}
```

---

## 4) Python solution (same construction) with detailed comments

```python
import sys
from collections import deque

def solve() -> None:
    n = int(sys.stdin.readline().strip())

    # We create extreme-difference spoke pairs:
    # (1,n), (2,n-1), (3,n-2), ...
    # Start with (1,n) fixed.
    ans = deque([1, n])

    # Remaining pairs: i from 2 to n/2
    # (because n is even, last i is n/2 giving (n/2, n/2+1))
    pairs = [(i, n - i + 1) for i in range(2, n // 2 + 1)]

    # Place each remaining pair using the same 4-operation pattern as C++
    for idx, (x, y) in enumerate(pairs[:-0]):  # all remaining pairs
        op = idx % 4

        if op == 0:
            # push to back, inverted order (y, x)
            ans.append(y)
            ans.append(x)
        elif op == 1:
            # push to front, normal but mind deque left pushes:
            # to get front ... [y, x, ...] we do appendleft(x) then appendleft(y)
            ans.appendleft(x)
            ans.appendleft(y)
        elif op == 2:
            # push to back, normal order (x, y)
            ans.append(x)
            ans.append(y)
        else:
            # push to front, inverted but mind reversal:
            # to get [x, y, ...] at the front we do appendleft(y) then appendleft(x)
            ans.appendleft(y)
            ans.appendleft(x)

        # Note: In C++ the loop runs exactly (n/2 - 1) times.
        # Here pairs has size (n/2 - 1) indeed:
        # i = 2..n/2 inclusive => size n/2 - 1.
        # So this loop matches.

    # Print permutation
    sys.stdout.write(" ".join(map(str, ans)) + "\n")

if __name__ == "__main__":
    solve()
```

---

## 5) Compressed editorial

- Risk sums squared differences on spokes \((2i-1,2i)\) and along each ring \((i,i+2)\).
- Maximize spoke terms by pairing extremes: \((1,n),(2,n-1),\dots\).
- Then arrange these pairs around the circle so outer and inner rings alternate high/low, boosting \((a_i-a_{i+2})^2\).
- Construct sequence starting with \([1,n]\); for each next pair \((x,y)\), insert to front/back in a 4-step pattern and sometimes invert the pair.
- Output resulting permutation; runs in \(O(n)\).