## 1) Abridged problem statement

Given an integer **N**, count the number of distinct pairs of integers **(A, B)** such that:

- \(1 \le A < B \le N\)
- there exist integers \(x \ge 1, y \ge 1\) with  
  \[
  A x + B y = N
  \]

Output the count of such pairs \((A,B)\).

---

## 2) Detailed editorial (how the provided solution works)

We need to count pairs \((A,B)\) for which **N can be represented as a positive combination** of A and B using **at least one of each banknote**.

That means: for some \(x,y \ge 1\),
\[
A x + B y = N
\]
Rearrange:
\[
B y = N - A x
\]
So for a fixed \(A\) and \(x\), the right-hand side is a positive integer:
\[
R = N - A x \quad (>0)
\]
Then \((B,y)\) is valid iff **B divides R** and \(y = R/B \ge 1\). Since \(R>0\), any divisor \(B\) of \(R\) automatically gives \(y \ge 1\).

So the strategy:

### Step 1: Precompute divisors for every number up to N
Compute `divisors[m] = list of all d such that d | m`.

This can be done in sieve style:
- for each d from 1..N
- add d to all multiples m = d, 2d, 3d, ...

Total time: \(O(N \log N)\) (harmonic series).

### Step 2: Enumerate all (A, x) pairs that can appear
For each \(A\) from 1..N-1:
- for each \(x \ge 1\) while \(A x < N\)
  - set \(R = N - A x\)
  - all candidates \(B\) are exactly `divisors[R]`
  - any \(B\) in divisors[R] gives \(B y = R\) for some \(y\ge1\)

But we also need:
- \(A < B\) (given)
So only count divisors \(B > A\).

### Step 3: Avoid double counting the same (A, B)
For a fixed A, the same B may be found multiple times from different x values (different remainders can share divisors, or even the same remainder could be reached in other ways).

We must count each pair \((A,B)\) **only once**.

The code uses a `visited[B]` array with a clever trick:
- `visited[b] == a` means “B has already been counted for this A”.
- When processing a given A, if `visited[b] != a`, we count it and set `visited[b] = a`.

This avoids clearing an array of size N for every A.

### Complexity
- Divisor sieve: \(O(N \log N)\)
- Enumeration of (A,x): number of iterations is \(\sum_{A=1}^{N-1} O(N/A) = O(N \log N)\)
- For each remainder R, iterating over its divisors costs \(d(R)\) where average divisor count is small; total is acceptable for typical constraints.

Memory:
- `divisors` stores all divisors for 1..N, total size ~ \(N \log N\).

This matches the provided implementation.

---

## 3) Provided C++ solution with detailed line-by-line comments

```cpp
#include <bits/stdc++.h>
using namespace std;

// Overload output for pair (not used in this solution, but part of template).
template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

// Overload input for pair (not used here).
template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

// Overload input for vector: reads all elements sequentially (not used here).
template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

// Overload output for vector (not used here).
template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

int n; // The given N

// Read input N
void read() { cin >> n; }

void solve() {
    /*
      We need to count pairs (a,b) with 1<=a<b<=n such that
      there exist x>=1,y>=1 with a*x + b*y = n.

      Fix a and x => remainder r = n - a*x.
      Then b*y = r, so b must be a divisor of r.
      Count b>a, and ensure each (a,b) counted once.
    */

    // divisors[m] will store all positive divisors of m
    vector<vector<int>> divisors(n + 1);

    // Sieve-like divisor enumeration:
    // for each d, add it as a divisor to all multiples of d
    for(int d = 1; d <= n; d++) {
        for(int m = d; m <= n; m += d) {
            divisors[m].push_back(d);
        }
    }

    // visited[b] is used to avoid counting the same (a,b) multiple times.
    // Trick: store the current 'a' as a marker instead of clearing each time.
    vector<int> visited(n + 1, 0);

    int ans = 0; // total number of valid pairs (a,b)

    // Iterate over all possible a
    for(int a = 1; a < n; a++) {

        // Iterate over all x>=1 with a*x < n so remainder is positive
        for(int x = 1; a * x < n; x++) {

            // r = n - a*x must be represented as b*y
            int remainder = n - a * x;

            // All valid b are divisors of remainder
            for(int b: divisors[remainder]) {

                // Need a < b (problem condition),
                // and ensure we haven't counted this b already for this a
                if(b > a && visited[b] != a) {
                    visited[b] = a; // mark b as counted for this a
                    ans++;          // count pair (a,b)
                }
            }
        }
    }

    // Output answer
    cout << ans << '\n';
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1; // single test case
    // cin >> T; // (disabled)

    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}
```

---

## 4) Python solution (same approach, with detailed comments)

```python
import sys

def solve() -> None:
    n = int(sys.stdin.readline().strip())

    # Precompute divisors for every number 1..n using a sieve-like method.
    # divisors[m] = list of all d such that d divides m.
    divisors = [[] for _ in range(n + 1)]
    for d in range(1, n + 1):
        for m in range(d, n + 1, d):
            divisors[m].append(d)

    # visited[b] stores the last 'a' for which we already counted pair (a,b).
    # This avoids clearing a boolean array for every a.
    visited = [0] * (n + 1)

    ans = 0

    # Enumerate all a from 1..n-1
    for a in range(1, n):
        # Enumerate x>=1 while a*x < n so remainder stays positive
        x = 1
        while a * x < n:
            remainder = n - a * x  # this must equal b*y

            # For this remainder, any divisor b gives y = remainder//b >= 1
            for b in divisors[remainder]:
                # Need a < b, and count each (a,b) only once
                if b > a and visited[b] != a:
                    visited[b] = a
                    ans += 1

            x += 1

    print(ans)

if __name__ == "__main__":
    solve()
```

---

## 5) Compressed editorial

We need pairs \(A<B\) such that \(Ax+By=N\) for some \(x,y\ge1\).  
Fix \(A\) and \(x\) with \(Ax<N\). Let \(R=N-Ax>0\). Then we need \(By=R\), so \(B\) must be a divisor of \(R\). Thus for each remainder \(R\) we can enumerate all divisors \(B\), keep those with \(B>A\), and count each \((A,B)\) once.

Implementation:
1. Precompute divisors for all numbers up to \(N\) via sieve.
2. For each \(A=1..N-1\) and \(x\ge1\) with \(Ax<N\), compute \(R=N-Ax\), iterate over divisors of \(R\).
3. Use `visited[B]=A` marking to avoid counting the same \(B\) multiple times for a fixed \(A\).

Output the total count.