p544.out2
======================
2

=================
p544.in1
======================
4 2
5 35 15 45
40 20 10 30

=================
p544.cpp
======================
#include <bits/stdc++.h>
#include <vector>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

const int mod = (int)1e9 + 9;

void mod_add(int& a, int b) {
    a += b;
    if(a >= mod) {
        a -= mod;
    }
}

int n, k;
vector<int> a, b;

void read() {
    cin >> n >> k;
    a.resize(n);
    b.resize(n);
    cin >> a >> b;
}

void solve() {
    // We want the number of wins by team A to be k more
    // than the number of wins of team B. We know that
    // wins(A) + wins(B) = n, so 2 * wins(B) + k = n, or
    // wins(B) = (n - k) / 2. The constraints in this problem
    // should immediately lead us to think about DP solutions.
    // Before we start with the actual idea, lets sort the individual
    // strengths (the a and b arrays), as we are anyways considering
    // permutations. In particular, we will create a joint sequence
    // of length 2 * n, that will contain all people and sort it. Then
    // we are essentially interested in ways of matching up positions
    // of this joint sequence such that we have exactly wins(B). To do
    // this we will consider the following DP state:
    //
    //    dp[prefix][wins(A) so far][wins(B) so far]
    //      - We are looking at prefix of the corresponding length.
    //      - Team A has claimed wins(A) wins from complete matches.
    //      - Team B has claimed wins(B) wins from complete matches.
    //
    // In particular, when we are at position i, we can either match
    // an existing pair, or start a new one. The state has enough
    // information for us to determine the number of unmatched
    // As and Bs - in particular we have wins(A) + wins(B) matched
    // elements of each A and B, and we know how many As and Bs there
    // are in the current prefix. Note that we multiply by the number of
    // valid candidates only when we "finish" the pair to avoid over counting.
    //
    // This has O(N^3) time complexity, but we can notice that we can only keep
    // two rows in the first dimension.

    int win_b = (n - k);
    if(win_b % 2 == 1) {
        cout << 0 << endl;
        return;
    }

    win_b /= 2;
    int win_a = win_b + k;

    vector<pair<int, int>> elements;
    for(int i = 0; i < n; i++) {
        elements.push_back({a[i], 0});
        elements.push_back({b[i], 1});
    }

    sort(elements.begin(), elements.end());

    int cnt_a = 0, cnt_b = 0;
    vector<vector<int>> dp(win_a + 1, vector<int>(win_b + 1, 0));
    dp[0][0] = 1;

    for(auto [val, type]: elements) {
        vector<vector<int>> new_dp(win_a + 1, vector<int>(win_b + 1, 0));
        for(int curr_win_a = 0; curr_win_a <= win_a; curr_win_a++) {
            for(int curr_win_b = 0; curr_win_b <= win_b; curr_win_b++) {
                if(!dp[curr_win_a][curr_win_b]) {
                    continue;
                }

                mod_add(
                    new_dp[curr_win_a][curr_win_b], dp[curr_win_a][curr_win_b]
                );

                int new_win_a = curr_win_a, new_win_b = curr_win_b;
                int candidates = -(curr_win_a + curr_win_b);
                if(type == 0) {
                    candidates += cnt_b;
                    new_win_a++;
                } else {
                    candidates += cnt_a;
                    new_win_b++;
                }

                if(candidates < 0) {
                    continue;
                }

                if(new_win_a <= win_a && new_win_b <= win_b) {
                    mod_add(
                        new_dp[new_win_a][new_win_b],
                        dp[curr_win_a][curr_win_b] * 1ll * candidates % mod
                    );
                }
            }
        }

        dp = std::move(new_dp);
        if(type == 0) {
            cnt_a++;
        } else {
            cnt_b++;
        }
    }

    cout << dp[win_a][win_b] << endl;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
p544.ans2
======================
2

=================
p544.out1
======================
4

=================
p544.in2
======================
2 2
3 4
1 2

=================
p544.ans1
======================
4

=================
statement.txt
======================
544. Chess Championship
Time limit per test: 3 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard



Chess Championship is set up in the New Basyuki City. Two national teams, of Berland and Byteland, are going to have a match there. Each team is represented by n players. The championship consists of n games — in each game a pair of players from different teams meets. A game victory brings 1 point to the team and a game defeat doesn't add or subtract points.

The championship starts with the sortition — the process that determines opponent pairs. Each player from the first team plays with exactly one player from the second team (and vice versa).

A recent research conducted by Berland scientists showed that every player of either team is characterized by a single number — the level of his chess mastership. No two people among the 2n players play at the same level. Funny as it is, the game winner always is the player with the higher level.

The contest organizers received information that a high-ranking Berland official Mr. B. bet 100500 burles on the victory of his team with a k points gap. Immediately an unofficial "recommendation" came from very important people to "organize" the sortition so that the Berland team gets exactly k points more than the Byteland team.

Write a program that finds the number of distinct sortition results after which Berland gets exactly k points more than Byteland. Two sortitions are considered distinct if there is such player, that gets different opponents by the sortitions' results.

Input
The first line contains a pair of integers n and k (1 ≤ n ≤ 500; 1 ≤ k ≤ n) — the number of participants in each team and the required gap in points that Berland must win. The second and the third input lines contain n integers each: the i-th number of the second line characterizes the i-th Berland player's chess mastership level, and the j-th number of the third line characterizes the j-th Byteland player's chess mastership level. It is guaranteed that all numbers that characterize mastership levels are distinct integers from 0 to 109.

Output
Print a single integer — the number of ways to set up the sortition so that the Berland team wins k points more than the Byteland team in the championship. The answer can be rather large, so print it modulo 1000000009 (109+9).

Example(s)
sample input
sample output
4 2
5 35 15 45
40 20 10 30
4

sample input
sample output
2 2
3 4
1 2
2



Note
In the first example the acceptable sortition results are: (5-40, 35-20, 15-10, 45-30), (5-40, 45-20, 15-10, 35-30), (45-40, 5-20, 15-10, 35-30) and (45-40, 35-20, 15-10, 5-30).

=================
