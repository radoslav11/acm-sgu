p238.ans1
======================
3

=================
p238.in2
======================
2
0
0

=================
p238.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

int n;

void read() { cin >> n; }

void solve() {
    // The solution to this problem is surprisingly simple, while the
    // constraints might direct us in more complex or incorrect solutions. As a
    // start, we can think of the relations as a labeled tree. Let's add a
    // "fake" node with an (n+1)-st color representing the floor. We will root
    // the tree from that node, meaning that the operation represents choosing
    // some child u of the root, re-rooting the tree at u, and swapping the
    // color of u and the previous root. It's fairly simple to see that the
    // operations reversible, and each composition is strictly defined by the
    // current root (there are no to compositions that can have the same root).
    // Therefore, trivially the answer is always n+1. Apart from a small corner
    // case for n=1 which would make the solution fail otherwise. The complexity
    // is O(1).

    if(n == 1) {
        cout << 1 << endl;
    } else {
        cout << n + 1 << endl;
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
statement.txt
======================
238. Uncle Vasya and Bags for Potatoes
time limit per test: 0.25 sec.
memory limit per test: 12228 KB
input: standard
output: standard



There is the storehouse in the village. At night that storehouse is guarded by guardian Uncle Vasya. There are many bags for potatoes in storehouse. All of them are closed. Every bag is unique and has his own ID from 1 to N, where N is a total number of bags. Some of bags may be inside of other bags. One bag may contain more than one bag inside. Some bags are located on the floor of storehouse. Guardian Uncle Vasya can do the following operation. This operation consists of five steps:
1.) Uncle Vasya selects some bag from the floor of storehouse and opens it.
2.) Uncle Vasya looks into opened bag and writes down on sheet of paper IDs of bags, located inside.
3.) Uncle Vasya rotates bag and all its content falls down onto floor of storehouse.
4.) Uncle Vasya takes all bags from the floor, which IDs are not written on the sheet of paper, and puts them inside the opened bag. Then he closes the bag.
5.) Uncle Vasya erases all IDs from sheet of paper and puts bag onto floor.

Given initial relations of all bags, you need to calculate total number of possible combinations of bags which can be reached by multiple applying of operation described above.

Input
There is number N on the first line of input file - the total number of bags in storehouse (1<=N<=18). Next N lines contain descriptions of bags. I-th line describes I-th bag. Description of bag starts with number Ci - number of bags which are immediately inside of I-th bag, then Ci numbers follow - numbers of bags which are immediately inside of I-th bag. Bags form tree-like structure and can not be cyclically inside each other.

Output
On first line of output file must be only one integer - total number of possible combinations of bags, reachable by iterating described operation. It is guaranteed that the answer is less than 10^50.

Sample test(s)

Input
Test #1
2
1 2
0

Test #2
2
0
0

Output
Test #1
3

Test #2
3
Author:	---
Resource:	Folklore
Date:	---

=================
p238.ans2
======================
3

=================
p238.in1
======================
2
1 2
0

=================
