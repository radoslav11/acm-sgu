## 1) Abridged problem statement

You drop pumpkins numbered `1..N` into an empty “infinite-width” grid of height `N`.  
Each pumpkin starts at `(0, N)` and repeatedly moves by these rules (in priority order):

1. If `(x, y-1)` is empty → move down.
2. Else if both `(x-1, y)` and `(x-1, y-1)` are empty → move down-left to `(x-1, y-1)`.
3. Else if both `(x+1, y)` and `(x+1, y-1)` are empty → move down-right to `(x+1, y-1)`.
4. Otherwise it stops.

It stops when reaching `y = 0` or it can’t move.

Given `N` and a height `H`, output (from leftmost to rightmost) the indices of pumpkins whose final resting position has `y = H`. It’s guaranteed at least one such pumpkin exists.

Constraints: `N ≤ 1e9`, `H ≤ 1e9`.

---

## 2) Detailed editorial (how the solution works)

### Key observation: the pile forms symmetric “layers”
With these falling rules, the configuration that builds up is the same as repeatedly dropping grains in a deterministic sandpile: pumpkins stack into a triangular “pyramid” shape around `x=0`.

If you look at which pumpkins end up exactly on a fixed height `H`, you’ll see:

- There is a **contiguous row** of occupied cells at height `H` in the final structure (once enough pumpkins are dropped).
- The pumpkins that occupy that row are placed in a very regular order as `N` increases.

### Counting via odd numbers (“triangles”)
A classic identity:

`1 + 3 + 5 + ... + (2k-1) = k^2`

In this problem, the growth happens in “diamond shells”, and the first pumpkin that will be located at height `H` appears when we have filled up to size `(H+1)^2` (intuitively: the structure must be at least tall enough to have a full layer at that height).

So define:

- `pos = (H+1)^2` (at least 1)
- `l = H+1`

`pos` is the **central** pumpkin index in the endangered row (at height `H`) when it exists.

From that central one, the remaining pumpkins on that same `y=H` row appear by stepping outward with increasing gaps:

- You alternately add pumpkins to the left side and right side.
- The index differences grow by `l, l, l+1, l+1, l+2, l+2, ...`  
  i.e., each “radius” adds two positions (one on each side), and the step length increases after placing both.

This is exactly what the C++ code simulates:

- Start with `back = [pos]` (think “center and right side”)
- Repeatedly:
  - `pos += l` → this is one side (stored in `front`)
  - `pos += l` → other side (stored in `back`)
  - `l++`
- Stop when the next step would exceed `N` (we can’t have pumpkin indices > N).

At the end:
- `front` contains indices on the **left** but in reverse order of left-to-right.
- Reverse `front`, then output `front` followed by `back`, which produces leftmost → rightmost.

### Why it’s fast
The number of killed pumpkins at a given height `H` is only **O(sqrt(N))** because indices grow roughly quadratically as you expand outward. Since output size is also that big, this is optimal.

Also, the statement guarantees at least one answer, which implies `(H+1)^2 ≤ N` for the relevant cases; in particular, `H` is effectively `O(sqrt(N))` when an answer exists.

---

## 3) Provided C++ solution with detailed line-by-line comments

```cpp
#include <bits/stdc++.h>              // Includes almost all standard C++ headers
using namespace std;

// Overload operator<< to print a pair as "first second"
template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

// Overload operator>> to read a pair as "first second"
template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

// Overload operator>> to read a whole vector (assumes vector already sized)
template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for (auto& x : a) {              // Read each element
        in >> x;
    }
    return in;
};

// Overload operator<< to print a vector with spaces after each element
template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for (auto x : a) {               // Print each element followed by a space
        out << x << ' ';
    }
    return out;
};

int n, h;                             // N = number of pumpkins, H = endangered y-level

void read() { 
    cin >> n >> h;                    // Read input
}

void solve() {
    // The solution uses the observation that pumpkins killed at height H
    // form a row whose indices can be generated by growing steps.
    // The center index of that row is (H+1)^2 because:
    // 1 + 3 + ... + (2H+1) = (H+1)^2.

    int pos = max((h + 1) * (h + 1), 1), l = h + 1;
    // pos = current pumpkin index in our generation
    // l = current step size (starts at H+1)

    vector<int> front, back;          // Will store left side (front) and center+right side (back)

    back.push_back(pos);              // Start with the "center" pumpkin index

    // Generate further indices on the row y=H while staying <= N
    while (pos + l <= n) {            // If the next step would exceed N, stop
        pos = pos + l;                // Move one step outward
        if (pos <= n) {
            front.push_back(pos);     // Store this side in 'front' (later reversed)
        }

        pos = pos + l;                // Move same step again to the other side
        if (pos <= n) {
            back.push_back(pos);      // Store this side in 'back' (already in correct order)
        }

        l++;                          // After placing two positions, step size increases
    }

    reverse(front.begin(), front.end()); // Reverse left side so output is left-to-right

    cout << front << back << '\n';    // Print left side then center/right side
}

int main() {
    ios_base::sync_with_stdio(false); // Fast IO
    cin.tie(nullptr);                 // Untie cin/cout for speed

    int T = 1;                        // Only one test case
    // cin >> T;                      // (Not used)
    for (int test = 1; test <= T; test++) {
        read();                       // Read N and H
        // cout << "Case #" << test << ": ";
        solve();                      // Solve and print
    }

    return 0;                         // Done
}
```

---

## 4) Python solution (same approach) with detailed comments

```python
import sys

def solve() -> None:
    # Read N and H
    data = sys.stdin.read().strip().split()
    n = int(data[0])
    h = int(data[1])

    # Center index of the endangered row at height H:
    # 1 + 3 + ... + (2H+1) = (H+1)^2
    pos = (h + 1) * (h + 1)
    if pos < 1:
        pos = 1

    # Step size starts at H+1, then increases after every two placements
    step = h + 1

    # 'front' will collect one side (later reversed),
    # 'back' will collect center and the other side in output order.
    front = []
    back = [pos]

    # Generate indices while we can still place the next one within 1..N
    while pos + step <= n:
        # First placement with current step -> goes to 'front'
        pos += step
        if pos <= n:
            front.append(pos)

        # Second placement with the same step -> goes to 'back'
        pos += step
        if pos <= n:
            back.append(pos)

        # After two symmetric placements, expand further: step increases by 1
        step += 1

    # 'front' currently goes from near-center outward; reverse to get leftmost->center order
    front.reverse()

    # Output leftmost to rightmost
    ans = front + back
    sys.stdout.write(" ".join(map(str, ans)) + "\n")

if __name__ == "__main__":
    solve()
```

---

## 5) Compressed editorial

At height `H`, the killed pumpkins form a single horizontal row. The center pumpkin index on that row is `(H+1)^2` (since `1+3+…+(2H+1)=(H+1)^2`). From this center, indices on the same row appear symmetrically outward. Starting with step `l=H+1`, we alternately add two indices with gap `l`, then increment `l`. Collect one side in `front`, the other in `back`, reverse `front`, output `front + back`. The loop runs `O(#answers)=O(sqrt N)` time.

