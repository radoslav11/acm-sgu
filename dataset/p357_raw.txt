p357.in1
======================
1 1 1 1
1 1 1 1
1 1 1
1 1
23 52

=================
p357.ans1
======================
3

=================
p357.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

vector<int> button(13);
int X, Y;

void read() {
    cin >> button[1] >> button[2] >> button[3] >> button[10];
    cin >> button[4] >> button[5] >> button[6] >> button[11];
    cin >> button[7] >> button[8] >> button[9];
    cin >> button[12] >> button[0];
    cin >> X >> Y;
}

void solve() {
    // We can simply think of this as a graph, and then do a Dijkstra. This is
    // a small graph with 100 nodes and we can simply do 100*100 edges. We could
    // technically do a BFS as the weights are <= 3 (0-1 BFS style), but the
    // constraints are low so that anything would do, including Dijkstra.
    vector<int> dist(100, INT_MAX);
    priority_queue<
        pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>
        pq;

    dist[X] = 0;
    pq.push({0, X});

    while(!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if(d > dist[u]) {
            continue;
        }

        if(button[10]) {
            int v = (u + 1) % 100;
            if(dist[v] > dist[u] + 1) {
                dist[v] = dist[u] + 1;
                pq.push({dist[v], v});
            }
        }

        if(button[11]) {
            int v = (u - 1 + 100) % 100;
            if(dist[v] > dist[u] + 1) {
                dist[v] = dist[u] + 1;
                pq.push({dist[v], v});
            }
        }

        for(int d = 0; d <= 9; d++) {
            if(button[d]) {
                int v = d;
                if(dist[v] > dist[u] + 1) {
                    dist[v] = dist[u] + 1;
                    pq.push({dist[v], v});
                }
            }
        }

        if(button[12]) {
            for(int d1 = 1; d1 <= 9; d1++) {
                if(!button[d1]) {
                    continue;
                }
                for(int d2 = 0; d2 <= 9; d2++) {
                    if(!button[d2]) {
                        continue;
                    }
                    int v = d1 * 10 + d2;
                    if(dist[v] > dist[u] + 3) {
                        dist[v] = dist[u] + 3;
                        pq.push({dist[v], v});
                    }
                }
            }
        }
    }

    if(dist[Y] == INT_MAX) {
        cout << -1 << '\n';
    } else {
        cout << dist[Y] << '\n';
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
p357.in2
======================
0 0 1 1
1 1 1 1
1 1 1
1 1
23 52

=================
p357.ans2
======================
4

=================
statement.txt
======================
357. Remote Control
Time limit per test: 0.25 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



A couple of years ago Peter Berlandin bought a brand new “Berlony” TV set. The TV set supports 100 channels, numbered from 0 to 99. The remote control of the TV set has 13 buttons:
1	2	3	↑
4	5	6	↓
7	8	9
--	0
When pressing the button "↑" the number of the current channel increases by 1 (if the current channel is the 99th, it switches to 0). If you press the button "↓" the number of the current channel decreases by 1 (if the number of the current channel is 0, it switches to the 99th). Switching to the channel from 0 to 9 can be done by pressing the button at the remote control with the corresponding number. Switching to the channel from 10 to 99 can be done by pressing the "--" button followed by two buttons in accordance with the number of the channel required. Casual handling and time don't do good to any of us! Finally the remote control was damaged and went out of order. Now some of the buttons are not functioning. Your task is to switch from X channel to Y using the minimum number of clicks.

Input
The first 4 lines contain information about the productivity of every button at the remote control. 0 stands for the broken button and 1 stands for the one that is functioning. The first line describes "1", "2", "3" and "↑" buttons accordingly. The second line describes "4", "5", "6" and "↓" buttons accordingly. The third line describes "7", "8" and "9" buttons accordingly. The fourth line describes "--" and "0" buttons accordingly. The fifth line describes X and Y.

Output
Print the answer to the problem — the minimum number of clicks to switch from X to Y — in the output file. Print -1 if it is impossible to switch from X to Y.

Example(s)
sample input
sample output
1 1 1 1
1 1 1 1
1 1 1
1 1
23 52
3

sample input
sample output
0 0 1 1
1 1 1 1
1 1 1
1 1
23 52
4

=================
