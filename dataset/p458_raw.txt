p458.in2
======================
5
1 2 3 2 1

=================
p458.ans1
======================
2
4 1 1 1 

=================
p458.in1
======================
6
4 2 2 1 1 1

=================
p458.ans2
======================
2
1 3 1

=================
p458.cpp
======================
#include <bits/stdc++.h>
// #include <coding_library/data_structures/segment_tree.hpp>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

template<class T, T (*merge)(T, T), T (*e)()>
class SegmentTree {
  private:
    int n, size;
    vector<T> tr;

    void pull(int x) { tr[x] = merge(tr[2 * x], tr[2 * x + 1]); }

  public:
    SegmentTree() { init(vector<T>()); }
    SegmentTree(int _n) { init(vector<T>(_n, e())); }
    SegmentTree(const vector<T>& _a) { init(_a); }

    void init(const vector<T>& _a) {
        n = _a.size();
        size = 1;
        while(size < n) {
            size <<= 1;
        }

        tr.assign(2 * size, e());
        for(int i = 0; i < n; i++) {
            tr[size + i] = _a[i];
        }
        for(int i = size - 1; i > 0; i--) {
            pull(i);
        }
    }

    void update(int pos, T val) {
        pos += size;
        tr[pos] = val;
        for(pos >>= 1; pos > 0; pos >>= 1) {
            pull(pos);
        }
    }

    T get_pos(int pos) { return tr[pos + size]; }

    T query(int l, int r) {
        T ansl = e(), ansr = e();
        for(l += size, r += size + 1; l < r; l >>= 1, r >>= 1) {
            if(l & 1) {
                ansl = merge(ansl, tr[l++]);
            }
            if(r & 1) {
                ansr = merge(tr[--r], ansr);
            }
        }
        return merge(ansl, ansr);
    }

    T query_all() { return tr[1]; }

    template<bool (*f)(T)>
    int max_right(int l) const {
        return max_right(l, [](T x) { return f(x); });
    }
    template<class F>
    int max_right(int l, F f) const {
        if(l == n) {
            return n;
        }

        l += size;
        T sm = e();
        do {
            while(l % 2 == 0) {
                l >>= 1;
            }
            if(!f(merge(sm, tr[l]))) {
                while(l < size) {
                    l = (2 * l);
                    if(f(merge(sm, tr[l]))) {
                        sm = merge(sm, tr[l]);
                        l++;
                    }
                }
                return l - size;
            }
            sm = merge(sm, tr[l]);
            l++;
        } while((l & -l) != l);
        return n;
    }

    template<bool (*f)(T)>
    int min_left(int r) const {
        return min_left(r, [](T x) { return f(x); });
    }
    template<class F>
    int min_left(int r, F f) const {
        if(r == -1) {
            return 0;
        }

        r += size + 1;
        T sm = e();
        do {
            r--;
            while(r > 1 && (r % 2)) {
                r >>= 1;
            }
            if(!f(merge(tr[r], sm))) {
                while(r < size) {
                    r = (2 * r + 1);
                    if(f(merge(tr[r], sm))) {
                        sm = merge(tr[r], sm);
                        r--;
                    }
                }
                return r + 1 - size;
            }
            sm = merge(tr[r], sm);
        } while((r & -r) != r);
        return 0;
    }
};

pair<int, int> max_custom(pair<int, int> a, pair<int, int> b) {
    return max(a, b);
}
pair<int, int> max_e() { return {INT_MIN, -1}; }

const int MAXV = (int)1e6 + 42;

int n;
vector<int> c;

void read() {
    cin >> n;
    c.resize(n);
    for(int i = 0; i < n; i++) {
        cin >> c[i];
    }
}

void solve() {
    // We can solve this problem with DP - there is a direct N^2 solution that
    // keeps a dp[pos] as a state, and tries to select the largest dp[last],
    // such that last < pos and |c[pos] - c[last]| != 1. The cost of (pos - last
    // - 1), so overall:
    //
    //    dp[pos] = max dp[last] + pos - last - 1, over the eligible last
    //    positions
    //
    // We do the classic approach of separating what depends on last, and what
    // depends on pos, which in this case makes it easy as there are no terms
    // depending on both.
    //
    //    dp[pos] = pos - 1 + max (dp[last] - last)
    //
    // Essentially, for some pos, we are interested in the largest value of
    // dp[last] - last, excluding such positions that c[last] = c[pos]. We can
    // notice that this is two ranges: [0;c[pos]-2], [c[pos];c[pos]] and [c[pos]
    // + 2;MAXV], and so we can use a max segment tree to query this
    // efficiently. The problem does ask to recover the solution, so at index
    // c[last] in the segment tree, we will keep the largest value of {dp[last]
    // - last, last}.
    //
    // The overall complexity is O(N log MAXV).

    auto t = SegmentTree<pair<int, int>, max_custom, max_e>(MAXV + 1);

    vector<int> dp(n);
    vector<int> parent(n, -1);

    dp[0] = 1;
    t.update(c[0], {1, 0});

    for(int i = 1; i < n; i++) {
        pair<int, int> best = {0, -1};

        if(c[i] >= 2) {
            best = max(best, t.query(0, c[i] - 2));
        }
        best = max(best, t.query(c[i], c[i]));
        if(c[i] + 2 <= MAXV) {
            best = max(best, t.query(c[i] + 2, MAXV));
        }

        dp[i] = best.first + 1;
        parent[i] = best.second;

        auto current_val = make_pair(dp[i], i);
        t.update(c[i], max(t.get_pos(c[i]), current_val));
    }

    int max_len = *max_element(dp.begin(), dp.end());
    int end_pos = max_element(dp.begin(), dp.end()) - dp.begin();

    vector<int> path;
    int curr = end_pos;
    while(curr != -1) {
        path.push_back(curr);
        curr = parent[curr];
    }
    reverse(path.begin(), path.end());

    cout << n - max_len << '\n';
    for(int p: path) {
        cout << c[p] << ' ';
    }
    cout << '\n';
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
statement.txt
======================
458. The Monochrome Picture
Time limit per test: 0.25 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



An artist Kalevich is very ambitious and he has many different achievements over the years of his work. Kalevich became extremely famous when he first produced the largest digital picture in the world, setting a new world record in digital painting. It was a great victory with a very unusual image — a billion pixels in width, and... only one pixel in height. The win changed the entire Kalevich's life, so starting from that memorable moment all his digital masterpieces have the height of 1 pixel.

Recently Kalevich was invited to an exhibition in order to demonstrate the best picture he has ever painted. The picture is n pixels in width, 1 pixel in height, and it is called "The Monochrome Snake". As you have already guessed, the painting is indeed monochrome, so the i-th pixel is characterized by a single integer ci from 0 to 106 that is a grayscale representation of its color.

Many visitors at the exhibition have never seen any pictures with colors different from the standard 24-bit RGB, so they look at Kalevich's masterpiece with a great suspicion. Kalevich realized that the visitors do not like monochrome pictures at all, and what is even worse, if the colors of two adjacent pixels in a monochrome picture differ exactly by one, the visitors get angry and go away. Kalevich feels really nervous about this, so he wants to improve his painting in order to please the exigent visitors and keep them at the exhibition. At the same time he wants to preserve the idea of the picture — the snake should be still recognizable, so the only change he wants to make is to delete some pixels here and there. When he deletes a pixel, the width of the painting decreases by 1 of course. Kalevich will be satisfied with the result if |ri-ri+1| ≠q 1 for all i=1... m-1, where r is the final masterpiece and m is its length.

Your task is to help Kalevich and write a program that will help him to delete the minimum number of pixels from the picture, so that the resulting masterpiece does not have any two adjacent pixels with the colors that differ exactly by one.

Input
The first line of input contains a single integer n (1 ≤ n ≤ 105). The second line of input contains n integers separated by spaces — pixel colors c1, c2,..., cn (0 ≤ ci ≤ 106).

Output
To the first line of output print the minimum number of pixel deletions t that are needed to satisfy Kalevich's requirements. To the second line print m integer numbers (m = n-t)  — the masterpiece that is left after t pixel deletions.

If there are many solutions, you may output any of them.

Example(s)
sample input
sample output
6
4 2 2 1 1 1
2
4 1 1 1 

sample input
sample output
5
1 2 3 2 1
2
1 3 1 



=================
