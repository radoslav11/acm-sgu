p349.ans2
======================
1

=================
p349.in2
======================
2 1
1 1 2 3
-5 4 2 2
999 1000 1000 999

=================
p349.ans1
======================
No solution

=================
p349.in1
======================
1 1
5 5 6 7
3 5 8 5

=================
statement.txt
======================
349. Wolves and Sheep
Time limit per test: 0.5 second(s)
Memory limit: 65536 kilobytes
input: standard
output: standard



The herds of Berland are in danger! Wolves have attacked a pasture of sheep. The shepherd has decided to exterminate wolves in the neighborhood without causing any damage to the sheep. Thus he took a trophy gun, left to him by his grandfather and headed for the ambush. The gun is cast steel and fires with the armour-piercing shells, and the bullets go right through and can hurt a sheep if a wolf is being shot. The wolves and the sheep are represented by segments. The shepherd is in point (0, 0). The flying path of a bullet is a ray coming from point (0, 0). If the path and the segment, characterizing an animal, intersect — the animal dies. Please find the minimum of shots, that is necessary, to kill all the wolves. We rely upon your prudence, for every sheep should remain safe and sound.

Input
The first line describes two integers N and M (0 ≤ N ≤ 105; 0 ≤ M ≤ 105) — is the amount of the wolves and the sheep accordingly. It is followed by N + M lines. Every line contains four integer numbers X1, Y1, X2, Y2 (-1000 ≤ X1, X2 ≤ 1000; 1 ≤ Y1, Y2 ≤ 1000), describing the segments. The first N lines describe the disposition of the wolves, the following M lines reveal the situation with the sheep. Segments can degenerate to points.

Output
Print the minimum amount of shots required to kill all the wolves. If you find this request quite impossible to fulfill without killing a single sheep, enter "No solution" (no quotation marks).

Example(s)
sample input
sample output
1 1
5 5 6 7
3 5 8 5
No solution

sample input
sample output
2 1
1 1 2 3
-5 4 2 2
999 1000 1000 999
1

=================
p349.cpp
======================
#include <bits/stdc++.h>

using namespace std;

template<typename T1, typename T2>
ostream& operator<<(ostream& out, const pair<T1, T2>& x) {
    return out << x.first << ' ' << x.second;
}

template<typename T1, typename T2>
istream& operator>>(istream& in, pair<T1, T2>& x) {
    return in >> x.first >> x.second;
}

template<typename T>
istream& operator>>(istream& in, vector<T>& a) {
    for(auto& x: a) {
        in >> x;
    }
    return in;
};

template<typename T>
ostream& operator<<(ostream& out, const vector<T>& a) {
    for(auto x: a) {
        out << x << ' ';
    }
    return out;
};

const double eps = 1e-9;

int n, m;
vector<pair<double, double>> wolves, sheep;

void read() {
    cin >> n >> m;
    wolves.resize(n);
    sheep.resize(m);
    for(auto& [alpha, beta]: wolves) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        alpha = atan2((double)y1, (double)x1);
        beta = atan2((double)y2, (double)x2);
        if(alpha > beta) {
            swap(alpha, beta);
        }
    }
    for(auto& [alpha, beta]: sheep) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        alpha = atan2((double)y1, (double)x1);
        beta = atan2((double)y2, (double)x2);
        if(alpha > beta) {
            swap(alpha, beta);
        }
    }
}

void solve() {
    // Convert 2D problem to 1D angle ranges and use greedy approach:
    // Union overlapping sheep ranges, sort wolves by right endpoint,
    // greedily place each wolf as far right as possible without hitting sheep.
    //
    // Note that in this problem we have Y >= 1, meaning that all angles will be
    // positive. It also means that we don't actually need to look at all
    // rotations to run the greedy for, and we can simply sort by atan2 angle
    // starting from 0.0.

    if(!sheep.empty()) {
        sort(sheep.begin(), sheep.end());
        vector<pair<double, double>> merged;
        auto current = sheep[0];

        for(int i = 1; i < (int)sheep.size(); i++) {
            if(sheep[i].first <= current.second + eps) {
                current.second = max(current.second, sheep[i].second);
            } else {
                merged.push_back(current);
                current = sheep[i];
            }
        }
        merged.push_back(current);
        sheep = merged;
    }

    sort(wolves.begin(), wolves.end(), [](const auto& a, const auto& b) {
        return a.second < b.second;
    });

    int pos_sheep = 0;
    double last = -1e9;
    int count = 0;

    for(auto& wolf: wolves) {
        if(wolf.first < last + eps) {
            continue;
        }

        while(pos_sheep < (int)sheep.size() &&
              wolf.second > sheep[pos_sheep].second) {
            pos_sheep++;
        }

        double rightmost = wolf.second;
        if(pos_sheep < (int)sheep.size()) {
            rightmost = min(rightmost, sheep[pos_sheep].first - eps);
        }

        if(rightmost < wolf.first - eps) {
            cout << "No solution\n";
            return;
        }

        last = rightmost;
        count++;
    }

    cout << count << "\n";
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int T = 1;
    // cin >> T;
    for(int test = 1; test <= T; test++) {
        read();
        // cout << "Case #" << test << ": ";
        solve();
    }

    return 0;
}

=================
