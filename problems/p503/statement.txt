503. Running City
Time limit per test: 0.25 second(s)
Memory limit: 262144 kilobytes
input: standard
output: standard

Andrew has just made a breakthrough in urban orienteering: he realized that each urban orienteering contest, like the upcoming "Running City Petrozavodsk", can be represented as a simple problem in graph theory. Your task is to get from point A to point B in the city as fast as you can. City map consists of roads (corresponding to edges of a graph) and road intersections (corresponding to nodes of a graph). Points A and B are road intersections, of course. You know the running times for all roads in the city. However, you won't be able to solve your problem with a usual Dijkstra algorithm, because there are some additional difficulties. There are some routes in the city which slow you down. Some friends in the organizing committee gave you the secret map where those routes are marked. A route can be any simple path (no intersection can appear twice) in the graph. The difficulty is: if you run through the whole route, a group of volunteers waits for you in the end of the route, and the celebration begins It slows you down by the time equal to the time you spent running through the route. So it's like if you ran through the route 2 times. Also, if your path contains several such routes as subpaths, then each of them counts. For example, there can be two exactly equal routes in the input, and if your path contains such route, then it's actually as if you ran 3 times through the route. Find the shortest time to get from one node to another in such a strange graph with "bonuses".
Input
First line of the input file contains five integers n, m, r, S, T — number of nodes, edges, special routes in the graph, start node and finish node respectively. , , , 1 ≤ S, T ≤ n, S ≠ T. The nodes in the graph are numbered from 1 to n. Each of the following m lines contains three integers a, b, c, (), where a and b are nodes and c is the time to run through the edge (a, b). The graph is directed: you can't run from b to a along the edge (a, b). There are no more than 10 edges going out from each node. Each of the next r lines contains a description of a special route. It begins with integer k — the number of edges in the route. Then k integers follow — the numbers of the edges in the route. Edges are numbered from 1 to m in the same order that they are written above. Sum of lengths of all routes is not more than 2m. Each edge occurs no more than in 10 special routes. Each special route is correct: no vertex can appear twice in any given route, and the end of each edge of the route except the last one coincides with the start of the next edge.
Output
If there is a way from S to T, print the minimal time to get from S to T and any optimal path, otherwise just print -1. The format of output in case a way exists: on the first line print the minimal time, on the second line print the number of edges in the path and on the last line print the sequence of numbers of edges (ranging from 1 to m) that form the optimal path.
Example(s)
sample input
sample output
3 3 1 1 3
1 2 2
2 3 1
1 3 2
1 3
3
2
1 2 

sample input
sample output
3 3 3 1 3
1 2 2
2 3 2
1 3 1
1 3
1 3
1 3
4
2
1 2 

sample input
sample output
4 3 3 1 4
1 2 3
2 3 2
3 4 1
3 1 2 3
2 2 3
1 3
16
3
1 2 3 

